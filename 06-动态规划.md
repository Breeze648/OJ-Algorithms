# 六、动态规划

## 6-1 背包模型

### 1.AcWing0002 0-1背包问题

有 *N* 件物品和一个容量是 *V* 的背包。每件物品只能使用一次。

第 *i* 件物品的体积是 $v_i$ ，价值是 $w_i$ 。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出最大价值。

#### 输入格式

第一行两个整数，*N*，*V* ，用空格隔开，分别表示物品数量和背包容积。

接下来有 *N* 行，每行两个整数 $v_i,w_i$ ，用空格隔开，分别表示第 *i* 件物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* , *V* ≤ 1000 ,

0 < *vi* , *wi* ≤ 1000



#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
8
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value;
};

int maxTotalValue(vector<Item>& items, int m) {
    // dp[j] represents the maximum value 
    // with total volume no more than j
    vector<int> dp(m + 1, 0);
    for (auto [w, v] : items) {
        // Traverse the backpack capacity in decreasing order
        for (int j = m; j >= w; j--) {
            dp[j] = max(dp[j], dp[j - w] + v);
        }
    }
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value;
    }
    
    cout << maxTotalValue(items, m) << '\n';
    
    return 0;
}
```





### 2.AcWing0003 完全背包问题

有 *N* 种物品和一个容量是 *V* 的背包，每种物品都有无限件可用。

第 *i* 种物品的体积是 *vi*，价值是 *wi* 。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出最大价值。

#### 输入格式

第一行两个整数，*N*，*V* ，用空格隔开，分别表示物品种数和背包容积。

接下来有 *N* 行，每行两个整数 *vi*,*wi*，用空格隔开，分别表示第 *i* 种物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* , *V* ≤ 1000 ,

0 < *vi* , *wi* ≤ 1000



#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
10
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value;
};

int maxTotalValue(vector<Item>& items, int m) {
    // dp[j] represents the maximum value 
    // with total volume no more than j
    vector<int> dp(m + 1, 0);
    for (auto [w, v] : items) {
        // Traverse the backpack capacity in increasing order
        for (int j = w; j <= m; j++) {
            dp[j] = max(dp[j], dp[j - w] + v);
        }
    }
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value;
    }
    
    cout << maxTotalValue(items, m) << '\n';
    
    return 0;
}
```



#### 算法2(46 ms)：

注意和0-1背包问题的区别。在每一轮迭代时，0-1 背包问题中是从大到小遍历背包容量的，而完全背包问题中则是从小到大遍历的。

原因是，0-1 背包问题中，每次更新 `dp[j]` 用到的 `dp` 中的数据是上一轮迭代后的数据，因此，每件物品只会使用一次。

而相对的，在完全背包问题中，每次更新 `dp[j]` 用到的 `dp` 中的数据是这一轮迭代已经更新后的数据，因此，每件物品可能被使用多次。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000, V = 1000;

int volume[N + 1], wealth[N + 1];

int maxWealth(int n, int v) {
    // dp[j] 表示背包容量为 j 时能够获得的最大价值
    int dp[V + 1];
    
    for (int j = 0; j <= v; ++j) {
        dp[j] = 0;
    }
    
    // 进行 n 轮迭代,每轮增加一个可供选择的物品 i
    for (int i = 1; i<= n; ++i) {
        // 从 volume[i] 到 v 遍历背包容量(从小到大遍历)
        for (int j = volume[i]; j <= v; ++j) {
            // 尝试将一件物品 i 装入背包，并更新最大收益
            dp[j] = max(dp[j], dp[j - volume[i]] + wealth[i]);
        }
    }
    
    return dp[v];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, v;
    cin >> n >> v;
    
    for (int i = 1; i <= n; ++i) {
        cin >> volume[i] >> wealth[i];
    }
    
    cout << maxWealth(n, v);
    
    return 0;
}
```





### 3.AcWing0004 多重背包问题 I(朴素暴力枚举)

有 *N* 种物品和一个容量是 *V* 的背包。

第 *i* 种物品最多有 *si* 件，每件体积是 *vi*，价值是 *wi* 。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

#### 输入格式

第一行两个整数，*N*，*V* ，用空格隔开，分别表示物品种数和背包容积。

接下来有 *N* 行，每行三个整数 *vi*,*wi*,*si*，用空格隔开，分别表示第 *i* 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* , *V* ≤ 100

0 < *vi* , *wi* , *si* ≤ 100



#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```



#### Algorithm 1-Brute:

Time Complexit = $O(nms)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value, amount;
};

int maxTotalValue(vector<Item>& items, int m) {
    // dp[j] represents the maximum value 
    // with total volume no more than j
    vector<int> dp(m + 1, 0);
    for (auto [w, v, s] : items) {
        // Traverse the backpack capacity in decreasing order
        for (int j = m; j >= 0; j--) {
            // Try to select k items i
            for (int k = 1; k <= s && j - k * w >= 0; k++) {
                dp[j] = max(dp[j], dp[j - k * w] + k * v);
            }
        }
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value >> item.amount;
    }
    
    cout << maxTotalValue(items, m) << '\n';
    
    return 0;
}
```





### 4.AcWing0005 多重背包问题 II(二进制优化)

有 *N* 种物品和一个容量是 *V* 的背包。

第 *i* 种物品最多有 *si* 件，每件体积是 *vi*，价值是 *wi* 。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

#### 输入格式

第一行两个整数，*N*，*V* ，用空格隔开，分别表示物品种数和背包容积。

接下来有 *N* 行，每行三个整数 *vi* , *wi* , *si* ，用空格隔开，分别表示第 *i* 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* ≤ 1000 ,

0 < *V* ≤ 2000 ,

0 < *vi* , *wi* , *si* ≤ 2000



##### 提示：

本题考查多重背包的二进制优化方法。

#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```



#### 算法思想：

多重背包问题是一个与0-1背包问题类似的组合优化问题，描述如下：给定一个背包容量为 V，有 n 种不同的物品，每种物品的重量为 `wt[i]`，价值为 `val[i]`，每种物品都有数量为 `num[i]` 的限制。问如何选择物品放入背包，使得背包中物品的总价值最大。

算法思想：

1. 创建一个一维数组 `dp`，其中 `dp[i]` 表示背包容量为 `i` 时能够获得的最大价值。
2. 对于每种物品 `i`，使用二进制拆分法将每种物品的数量 $n_i$ 拆分成 $\lfloor log_2(n_i + 1) \rfloor$ 组，前 $ \lfloor log_2(n_i + 1) \rfloor - 1$ 组物品含有的物品 `i` 的个数 $k_i$ 分别为 $1,2,...,2^{\lfloor log_2(n_i + 1) \rfloor - 1}$ ，最后一组包含剩下的所有物品。每组物品捆绑在一起，视为一种新物品。例如，如果一种物品的数量为 10，可以将其拆分成 4 组，含物品 `i` 的个数分别为 1, 2, 4, 3。
3. 对于每种拆分后的物品，使用0-1背包问题中的算法思想进行求解。具体地，从容量 0 开始遍历到背包容量 V，更新 `dp[j]` 的值，更新方法为：`dp[j] = max(dp[j], dp[j - wt[i]] + val[i])`。
4. 最终 `dp[V]` 即为所求的最大价值。

这个算法的时间复杂度是 O(n*V *log(s))，其中 n 表示物品的种类数，V 表示背包的容量，s 表示每种物品的最大数量。



##### Algorithm 1:

Time Complexity = $O(nm \log s)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value, amount;
};

int maxTotalValue(vector<Item>& items, int m) {
    // dp[j] represents the maximum value 
    // with total volume no more than j
    vector<int> dp(m + 1, 0);
    for (auto [w, v, s] : items) {
        // Try to select k items i
        for (int k = 1; s; s -= k, k = min(k * 2, s)) {
            // Traverse the backpack capacity in decreasing order
            int kw = k * w, kv = k * v;
            for (int j = m; j >= kw; j--) {
                dp[j] = max(dp[j], dp[j - kw] + kv);
            }
        }
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value >> item.amount;
    }
    
    cout << maxTotalValue(items, m) << '\n';
    
    return 0;
}
```





### 5.AcWing 0006 多重背包问题 III(hard)

有 *N* 种物品和一个容量是 *V* 的背包。

第 *i* 种物品最多有 $s_i$ 件，每件体积是 $v_i$ ，价值是 $w_i$ 。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

#### 输入格式

第一行两个整数，*N*，*V* ( 0 < *N* ≤ 1000 ,  0 < *V* ≤ 20000 ) ，用空格隔开，分别表示物品种数和背包容积。

接下来有 *N* 行，每行三个整数 $v_i, w_i, s_i$ ，用空格隔开，分别表示第 *i* 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* ≤ 1000

0 < *V* ≤ 20000

0 < $v_i, w_i, s_i$ ≤ 20000



##### 提示

本题考查多重背包的单调队列优化方法。

#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```



#### 算法思想：

1. 状态表示：`f[i][j]` 表示考虑前 `i` 件物品，且总体积不超过 `j` 的条件下，可以获得的最大价值。

2. 初始化基状态：`f[0][j] = f[i][0] = 0` ，表示没有可选择的物品或者背包容积为 0 ，可获取的最大价值为 0 。

3. 状态转移：`f[i][j] = max{f[i - 1][j - k * vi] + k * wi}` ，其中 $0 \leq k \leq s_i \and j - k \times v_i >= 0$ 。

   注：假设 $r = j \bmod v_i$ ，则求 
   $$
   max\{f[i-1][j-k_0 \times v_i] + k_0 \times w_i,
   	f[i-1][j-(k_0 -1)\times v_i] + (k_0 -1)\times w_i, 
   	\dots, 
   	f[i-1][j - 0 \times v_i] + 0 \times w_i\}		\tag{*}
   $$
   等价于求解
   $$
   k_0 \times w_i + max\{f[i - 1][r + 0 \times v_i] - 0 \times w_i, 
   	f[i - 1][r + 1 \times v_i] - 1 \times w_i, 
   	\dots, 
   	f[i - 1][r + k_0  \times v_i] - k_0  \times w_i,   \}	\tag{**}
   $$

4. 结果提取：`f[n][v]` 即为所求。



##### Algorithm 1(TLE-12/16):

Time Complexity = $O(nm)$ .

```c++
#pragma GCC optimize(3)
#include <iostream>
#include <algorithm>
#include <vector>
#include <deque>

using namespace std;

struct Item {
    int weight, value, amount;
};

int maxTotalValue(vector<Item>& items, int m) {
    int n = items.size();
    vector<vector<int>> dp(2, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; i++) {
        int cur = i & 1;
        auto [w, v, s] = items[i - 1];
        for (int mod = 0; mod < w; mod++) {
            deque<int> deq;
            for (int j = mod; j <= m; j += w) {
                // 1. Remove elements from the back of the deque that are no longer optimal
                while (!deq.empty() 
                       && dp[!cur][deq.back()] - (deq.back() - mod) / w * v 
                       <= dp[!cur][j] - (j - mod) / w * v) {
                    deq.pop_back();
                }
                // Add the current index to the deque
                deq.push_back(j);
                // 2. Remove elements from the front of the deque that exceed the range
                if (deq.front() < j - w * s) {
                    deq.pop_front();
                }
                // 3. Update the DP value using the optimal choice from the deque
                dp[cur][j] = dp[!cur][deq.front()] + (j - deq.front()) / w * v;
            }
        }
    }

    // Return the maximum value achievable with the given capacity
    return dp[n & 1][m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    int n, m;
    cin >> n >> m;

    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value >> item.amount;
    }

    cout << maxTotalValue(items, m) << '\n';

    return 0;
}
```



#### 算法1-单调队列(1466 ms)：

时间复杂度：O(nv)。n, v 分别为物品种数，背包的最大容积。

```c++
#include <iostream>

using namespace std;

const int V = 20000;

int n, v;
int f[2][V + 1];

int que[V + 1], head, tail;

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> v;
	for (int i = 1; i <= n; i++) {
		int ci = i & 1, pi = ci ^ 1;
		
		int vi, wi, si;
		cin >> vi >> wi >> si;
		
		for (int r = 0; r < vi; r++) {
			head = tail = 0;
			for (int j = r; j <= v; j += vi) {
				if (head < tail && que[head] < j - vi * si) {
					head++;
				}
                
				while (head < tail &&
						f[pi][que[tail - 1]] - (que[tail - 1] - r) / vi * wi <=
						f[pi][j] - (j - r) / vi * wi) {
					tail--;
				}
				que[tail++] = j;
				
				f[ci][j] = f[pi][que[head]] + (j - que[head]) / vi * wi;
			}
		}
	}
	
	cout << f[n & 1][v] << '\n';
	
	return 0;
}
```



#### 算法2-二进制拆分(2823 ms)：

时间复杂度：O($nvlog_2 s$) 。n, v, s 分别为物品总数，背包的最大容量，每种物品的个数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000, V = 20000;

int n, v;

// f[j] 表示在前 i 个物品中选, 总体积不超过 j 的所有方案中的最大价值 
int f[V + 1];

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> v;
	
	for (int i = 0; i < n; i++) {
		int vi, wi, si;
		cin >> vi >> wi >> si;
		for (int k = 1; k; si -= k, k = min(k * 2, si)) {
			int kvi = k * vi, kwi = k * wi;
			for (int j = v; j >= kvi; j--) {
			    if (f[j - kvi] + kwi > f[j]) {
			        f[j] = f[j - kvi] + kwi;
			    }
				//f[j] = max(f[j], f[j - kvi] + kwi);	// 使用 max 会 14/16 TLE
			}
		}
	}
	
	cout << f[v];
	
	return 0;
}
```





### 6.AcWing 0007 混合背包问题

有 *N* 种物品和一个容量是 *V* 的背包。

物品一共有三类：

- 第一类物品只能用1次（01背包）；
- 第二类物品可以用无限次（完全背包）；
- 第三类物品最多只能用 *si* 次（多重背包）；

每种体积是 *vi* ，价值是 *wi* 。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

#### 输入格式

第一行两个整数，*N*，*V* ，用空格隔开，分别表示物品种数和背包容积。

接下来有 *N* 行，每行三个整数 *vi* , *wi* , *si* ，用空格隔开，分别表示第 *i* 种物品的体积、价值和数量。

-  *si* = −1 表示第 *i* 种物品只能用1次；
-  *si* = 0 表示第 *i* 种物品可以用无限次；
-  *si* > 0 表示第 *i* 种物品可以使用 *si* 次；

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* , *V* ≤ 1000

0 < *vi* , *wi* ≤ 1000

−1 ≤ *si* ≤ 1000



#### 输入样例

```
4 5
1 2 -1
2 4 1
3 4 0
4 5 2
```

#### 输出样例：

```
8
```



##### Algorithm 1:

Time Complexity = $O(nm \log s)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value, amount;
};

int maxTotalValue(vector<Item>& items, int m) {
    // dp[j] represents the maximum value 
    // with total volume no more than j
    vector<int> dp(m + 1, 0);
    for (auto [w, v, s] : items) {
        // Try to select k items i
        for (int k = 1; s; s -= k, k = min(2 * k, s)) {
            int kw = k * w, kv = k * v;
            // Traverse the backpack capacity in decreasing order
            for (int j = m; j >= kw; j--) {
                dp[j] = max(dp[j], dp[j - kw] + kv);
            }
        }
        
        
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value >> item.amount;
        if (item.amount == -1) {
            item.amount = 1;            // 
        } else if (item.amount == 0) {
            item.amount = m;
        }
    }
    
    cout << maxTotalValue(items, m) << '\n';
    
    return 0;
}
```



#### 算法2(72 ms)：

时间复杂度：O(nv)。n, v 分别为物品种数，背包的容积。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int V = 1000;

int n, v;
int f[V + 1], g[V + 1];

int que[V + 1], head, tail;

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> v;
	for (int i = 0; i < n; i++) {
		int vi, wi, si;
		cin >> vi >> wi >> si;
		
		if (si == -1) {
			for (int j = v; j >= vi; j--) {
				f[j] = max(f[j], f[j - vi] + wi);
			}
		}
		else if (si == 0) {
			for (int j = vi; j <= v; j++) {
				f[j] = max(f[j], f[j - vi] + wi);
			}
		}
		else {
			copy_n(f, v + 1, g);
			for (int r = 0; r < vi; r++) {
			    head = tail = 0;
				for (int j = r; j <= v; j += vi) {
					if (head < tail && que[head] < j - vi * si) {
						head++;
					}
					while (head < tail && 
							g[que[tail - 1]] - (que[tail - 1] - r) / vi * wi <=
							g[j] - (j - r) / vi * wi) {
						tail--;
					}
					que[tail++] = j;
					
					f[j] = g[que[head]] + (j - que[head]) / vi * wi;
				}
			}
		}
	}
	
	cout << f[v] << '\n';
	
	return 0;
}
```





### 7.AcWing 0008 二维费用的背包问题

有 *N* 件物品和一个容量是 *V* 的背包，背包能承受的最大重量是 *M* 。

每件物品只能用一次。体积是 *vi* ，重量是 *mi* ，价值是 *wi* 。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。

输出最大价值。

#### 输入格式

第一行三个整数，*N* , *V* , *M* ，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。

接下来有 *N* 行，每行三个整数 *vi* , *mi* , *wi* ，用空格隔开，分别表示第 *i* 件物品的体积、重量和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* ≤ 1000

0 < *V* , *M* ≤ 100

0 < *vi* , *mi* ≤ 100

0 < *wi* ≤ 1000



#### 输入样例

```
4 5 6
1 2 3
2 4 4
3 4 5
4 5 6
```

#### 输出样例：

```
8
```



#### Algorithm 1:

Time Complexity = $O(n m_1 m_2)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int cost1, cost2, value;
};

int maxTotalValue(vector<Item>& items, int m1, int m2) {
    // dp[j][k] represents the maximum value 
    // when total_cost1 is no more than j and total_cost2 is no more than k
    vector<vector<int>> dp(m1 + 1, vector<int>(m2 + 1, 0));
    for (auto [cost1, cost2, value] : items) {
        for (int j = m1; j >= cost1; j--) {
            for (int k = m2; k >= cost2; k--) {
                dp[j][k] = max(dp[j][k], dp[j - cost1][k - cost2] + value);
            }
        }
    }
    return dp[m1][m2];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m1, m2;
    cin >> n >> m1 >> m2;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.cost1 >> item.cost2 >> item.value;
    }
    
    cout << maxTotalValue(items, m1, m2) << '\n';
    
    return 0;
}
```





### 8.AcWing0009 分组背包问题

有 *N* 组物品和一个容量是 *V* 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 $v_{ij}$ ，价值是 $w_{ij}$ 。其中 *i* 是组号，*j* 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

#### 输入格式

第一行有两个整数 *N*，*V* ，用空格隔开，分别表示物品组数和背包容量。

接下来有 *N* 组数据：

- 每组数据第一行有一个整数 $S_i$ ，表示第 *i* 组物品的物品数量；
- 接下来有 $S_i$ 行，每行有两个整数 $v_{ij}，w_{ij}$ ，用空格隔开，分别表示第 *i* 个组的第 *j* 个物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0 < *N* , *V* ≤ 100

0 < $S_i$ ≤ 100

0 < $v_{ij}, w_{ij}$ ≤ 100



#### 输入样例

```
3 5
2
1 2
2 4
1
3 4
1
4 5
```

#### 输出样例：

```
8
```



#### 注：

多重背包问题可以看做分组背包问题的一种特殊情况。

在多重背包问题中，假设物品 `i` 的个数为 $s_i$ ，我们只能从中选择 0 个或者 k 个，其中 $k=1,2,...,s_i$ 。

相当于分组背包问题中，第 `i` 组物品含有 $s_i$ 个，且这  $s_i$ 个物品的体积与价值分别为物品 `i` 的 k 倍，其中 $k=1,2,...,s_i$ 。



##### Algorithm 1:

Time Complexity = $O(nms)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value;
};

int maxTotalValue(vector<vector<Item>>& groups, int m) {
    // dp[j] represents the maximum value in previous i groups
    // with total volumn no more than j
    vector<int> dp(m + 1, 0);
    for (auto& group : groups) {
        // Traverse the backpack capacity in decreasing order
        int s = group.size();
        for (int j = m; j > 0; j--) {
            // Try to select item k in group i
            for (auto [w, v] : group) {
                if (j - w >= 0) {
                    dp[j] = max(dp[j], dp[j - w] + v);
                }
            }
        }
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<Item>> groups(n);
    
    for (auto& group : groups) {
        int s;
        cin >> s;
        group.resize(s);
        for (auto& item : group) {
            cin >> item.weight >> item.value;
        }
    }
    
    cout << maxTotalValue(groups, m) << '\n';
    
    return 0;
}
```







### 9.AcWing 0010 有依赖的背包问题(树形DP-hard)

有 *N* 个物品和一个容量是 *V* 的背包。

物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。

如下图所示：
 ![QQ图片20181018170337.png](https://cdn.acwing.com/media/article/image/2018/10/18/1_bb51ecbcd2-QQ图片20181018170337.png) 

如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。

每件物品的编号是 *i* ，体积是 *vi*，价值是 *wi*，依赖的父节点编号是 *pi*。物品的下标范围是 1…*N* 。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

#### 输入格式

第一行有两个整数 *N*，*V* ，用空格隔开，分别表示物品个数和背包容量。

接下来有 *N* 行数据，每行数据表示一个物品。第 *i* 行有三个整数 *vi* , *wi* , *pi* ，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。

如果 *pi* = −1，表示根节点。 **数据保证所有物品构成一棵树。**

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

1 ≤ *N* , *V* ≤ 100

1 ≤ *vi* , *wi* ≤ 100

父节点编号范围：

- 内部结点：1 ≤ *pi* ≤ *N* ;
- 根节点 *pi* = −1 ;



#### 输入样例

```
5 7
2 3 -1
2 2 1
3 5 1
4 7 2
3 6 2
```

#### 输出样例：

```
11
```



##### Algorithm 1:

Time Complexity = $O(n m w)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

struct Item {
    int weight, value;
};

class ALTree {
private:
    int n;
    int root;
    vector<list<int>> heads;
    vector<Item> items;
    
public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        items.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            int v, w, p;
            cin >> v >> w >> p;
            items[i] = {v, w};
            if (p == -1) {
                root = i;
            } else {
                heads[p].push_back(i);
            }
        }
    }
    
    // f[u][j] represents the maximum total value of all schemes (u must be chosen) 
    // that consider subtree rooted in u and whose total volume does not exceed j.
    vector<vector<int>> dp;
    int m;
    
    int maxTotalValue(int capacity) {
        m = capacity;
        dp.resize(n + 1, vector<int>(m + 1, 0));
        dfs(root);
        return dp[root][m];
    }
    
    void dfs(int u) {
        auto [weight, value] = items[u];
        for (auto v : heads[u]) {
            dfs(v);
            // Traverse remaining backpack capacity
            for (int j = m - weight; j >= 0; j--) {
                // Try to allocate part of the backpack capacity k to subtree v
                for (int k = 1; k <= j; k++) {
                    // Consider to not select or select item v
                    dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[v][k]);
                }
            }
        }
        
        // Select item u (u must be chosen)
        for (int j = m; j >= weight; j--) {
            dp[u][j] = dp[u][j - weight] + value;
        }
        for (int j = weight - 1; j >= 0; j--) {
            dp[u][j] = 0;
        }
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    ALTree T(cin, n);
    
    cout << T.maxTotalValue(m) << '\n';
    
    return 0;
}
```





### 10.AcWing 0011 背包问题求最优方案数(medium)

有 *N* 件物品和一个容量是 *V* 的背包。每件物品只能使用一次。

第 *i* 件物品的体积是 *vi* ，价值是 *wi* 。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出 **最优选法的方案数**。注意答案可能很大，请输出答案模 10^9 + 7 的结果。

#### 输入格式

第一行两个整数，*N* , *V* ，用空格隔开，分别表示物品数量和背包容积。

接下来有 *N* 行，每行两个整数 *vi* , *wi* ，用空格隔开，分别表示第 *i* 件物品的体积和价值。

#### 输出格式

输出一个整数，表示 **方案数** 模 10^9 + 7 的结果。

#### 数据范围

0 < *N* , *V* ≤ 1000

0 < *vi* , *wi* ≤ 1000



#### 输入样例

```
4 5
1 2
2 4
3 4
4 6
```

#### 输出样例：

```
2
```



#### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int MOD = 1e9 + 7;

struct Item {
    int weight, value;
};

int maxNumOfOptimalSchemes(vector<Item>& items, int m) {
    // f[j], g[j] represent the maximum value and corresponding number of schemes
    // respectively with total volumn exactly j
    vector<int> f(m + 1, 0), g(m + 1, 0);
    g[0] = 1;
    for (auto [w, v] : items) {
        for (int j = m; j >= w; j--) {
            int maxVal = max(f[j], f[j - w] + v);
            int cnt = 0;
            if (f[j] == maxVal) {
                cnt += g[j];
            }
            if (f[j - w] + v == maxVal) {
                cnt += g[j - w];
            }
            g[j] = cnt % MOD;
            f[j] = maxVal;
        }
    }
    
    int maxVal = 0, ans = 0;
    for (int j = 0; j <= m; j++) {
        if (f[j] > maxVal) {
            maxVal = f[j];
            ans = g[j];
        } else if (f[j] == maxVal) {
            ans = (ans + g[j] % MOD);
        }
    }
    
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value;
    }
    
    cout << maxNumOfOptimalSchemes(items, m) << '\n';
    
    return 0;
}
```





### 11.AcWing 0012 背包问题求具体方案(medium)

有 *N* 件物品和一个容量是 *V* 的背包。每件物品只能使用一次。

第 *i* 件物品的体积是 *vi*，价值是 *wi* 。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出 **字典序最小的方案**。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…*N* 。

#### 输入格式

第一行两个整数，*N*，*V* ，用空格隔开，分别表示物品数量和背包容积。

接下来有 *N* 行，每行两个整数 *vi* , *wi* ，用空格隔开，分别表示第 *i* 件物品的体积和价值。

#### 输出格式

输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。

物品编号范围是 1…*N* 。

#### 数据范围

0 < *N* , *V* ≤ 1000

0 < *vi* , *wi* ≤ 1000



#### 输入样例

```
4 5
1 2
2 4
3 4
4 6
```

#### 输出样例：

```
1 4
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

struct Item {
    int weight, value;
};

void schemeWithMaxTotalValue(vector<Item>& items, int m) {
    reverse(items.begin(), items.end());
    
    int n = items.size();
    // dp[i][j] represents the maximum value 
    // with total weight no more than j
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
    for (int i = 1; i <= n; i++) {
        auto [w, v] = items[i - 1];
        for (int j = 0; j <= m; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= w) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - w] + v);
            }
        }
    }
    
    // Backtracking to find which items were included in the optimal solution
    for (int i = n, j = m; i >= 1; i--) {
        auto [w, v] = items[i - 1];
        // If item i was used
        if (j >= w && dp[i - 1][j - w] + v == dp[i][j]) {
            cout << n - i + 1 << ' ';   // Previous order is n-i+1
            j -= w;                     // Reduce the remaining capacity
        }
    }
    cout << '\n';
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value;
    }
    
    schemeWithMaxTotalValue(items, m);
    
    return 0;
}
```





### 12.AcWing 1024 装箱问题(0-1 背包求最小剩余空间)

有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。

要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

#### 输入格式

第一行是一个整数 V，表示箱子容量。

第二行是一个整数 n，表示物品数。

接下来 n 行，每行一个正整数（不超过10000），分别表示这 n 个物品的各自体积。

#### 输出格式

一个整数，表示箱子剩余空间。

#### 数据范围

0 < *V* ≤ 20000 ,

0 < *n* ≤ 30



#### 输入样例：

```
24
6
8
3
12
7
9
7
```

#### 输出样例：

```
0
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int minRemainingSpace(vector<int>& weights, int m) {
    int n = weights.size();
    // dp[j] represents whether it's possible to exactly fill a box 
    // with volume j using the available items
    vector<bool> dp(m + 1, false);
    dp[0] = true;
    for (auto w : weights) {
        for (int j = m; j >= w; j--) {
            dp[j] = dp[j] || dp[j - w];
        }
    }
    
    int j = m;
    while (!dp[j]) {
        j--;
    }
    return m - j;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m, n;
    cin >> m >> n;
    
    vector<int> weights(n);
    for (int i = 0; i < n; i++) {
        cin >> weights[i];
    }
    
    cout << minRemainingSpace(weights, m) << '\n';
    
    return 0;
}
```





### 13.AcWing 0278 数字组合(0-1背包求方案数)

给定 *N* 个正整数 $A_1,A_2, \dots, A_N$ ，从中选出若干个数，使它们的和为 *M*，求有多少种选择方案。

#### 输入格式

第一行包含两个整数 *N* 和 *M* 。

第二行包含 *N* 个整数，表示 $A_1,A_2, \dots, A_N$ 。

#### 输出格式

包含一个整数，表示可选方案数。

#### 数据范围

1 ≤ *N* ≤ 100 ,

1 ≤ *M* ≤ 10000 ,

1 ≤ *Ai* ≤ 1000 ,

答案保证在 int 范围内。



#### 输入样例：

```
4 4
1 1 2 2
```

#### 输出样例：

```
3
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int numOfSchemes(vector<int>& nums, int m) {
    // dp[j] represents the number of ways to achieve a sum of j
    vector<int> dp(m + 1, 0);
    dp[0] = 1;
    for (auto num : nums) {
        for (int j = m; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << numOfSchemes(nums, m) << '\n';
    
    return 0;
}
```





### 14.AcWing 1021 货币系统

给你一个 n 种面值的货币系统，求组成面值为 m 的货币有多少种方案。

#### 输入格式

第一行，包含两个整数 n 和 m 。

接下来 n 行，每行包含一个整数，表示一种货币的面值。

#### 输出格式

共一行，包含一个整数，表示方案数。

#### 数据范围

*n* ≤ 15 ,

*m* ≤ 3000	- 经测试， $1\leq m \leq 3000$ ，-2024/04/09 注



#### 输入样例：

```
3 10
1
2
5
```

#### 输出样例：

```
10
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

long long numOfSchemes(vector<int>& nums, int m) {
    int n = nums.size();
    
    // dp[j] represents the number of ways to achieve a sum of j
    vector<long long> dp(m + 1, 0);
    dp[0] = 1;
    for (auto num : nums) {
        for (int j = num; j <= m; j++) {
            dp[j] += dp[j - num];
        }
    }
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << numOfSchemes(nums, m) << '\n';
    
    return 0;
}
```





### 15.AcWing 0532 货币系统 II(medium)

在网友的国度中共有 *n* 种不同面额的货币，第 *i* 种货币的面额为 *a*[*i*] ，你可以假设每一种货币都有无穷多张。

为了方便，我们把货币种数为 *n* 、面额数组为 *a*[1..*n*] 的货币系统记作 (*n*,*a*) 。 

在一个完善的货币系统中，每一个非负整数的金额 *x* 都应该可以被表示出，即对每一个非负整数 *x*，都存在 *n* 个非负整数 *t*[*i*] 满足 *a*[*i*]×*t*[*i*] 的和为 *x* 。

然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 *x* 不能被该货币系统表示出。

例如在货币系统 *n*=3, *a*=[2,5,9] 中，金额 1,3 就无法被表示出来。 

两个货币系统 (*n*,*a*) 和 (*m*,*b*) 是等价的，当且仅当对于任意非负整数 *x* ，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。

他们希望找到一个货币系统 (*m*,*b*) ，满足 (*m*,*b*) 与原来的货币系统 (*n*,*a*) 等价，且 *m* 尽可能的小。

他们希望你来协助完成这个艰巨的任务：找到最小的 *m* 。

#### 输入格式

输入文件的第一行包含一个整数 *T* ，表示数据的组数。

接下来按照如下格式分别给出 *T* 组数据。 

每组数据的第一行包含一个正整数 *n* 。

接下来一行包含 *n* 个由空格隔开的正整数 *a*[*i*] 。

#### 输出格式

输出文件共有 *T* 行，对于每组数据，输出一行一个正整数，表示所有与 (*n*,*a*) 等价的货币系统 (*m*,*b*) 中，最小的 *m* 。

#### 数据范围

1 ≤ *n* ≤ 100 ,

1 ≤ *a*[*i*] ≤ 25000 ,

1 ≤ *T* ≤ 20



#### 输入样例：

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 
```

#### 输出样例：

```
2
5
```



#### 题意分析：

经分析，易知 $\{b_i\}(1\leq i \leq m)$ 是一个极大独立无关集，满足如下性质

性质1：$a_1, a_2, \dots, a_n$ 一定可以由 $b_1, b_2, \dots, b_m$ 表示出来。

性质2： $\{b_i\}(1\leq i \leq m)$ 中的每一个数一定不能由剩余的 $m-1$ 个数表示出来。

性质3：对于每个 $b_i$ ，一定有 $b_i \in \{a_1, a_2, \dots, a_n\}$ 。



##### Algorithm 1:

Time Complexity = $O(tnm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int maximalIndependentSet(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    int m = nums.back();
    
    // dp[j] indicates if a sum of j can be formed
    vector<bool> dp(m + 1, false);
    dp[0] = true;   // Base case: A sum of 0 is always achievable (by taking no elements)
    int cnt = 0;
    for (auto num : nums) {
        if (dp[num]) {
            continue;
        }
        
        cnt++;
        for (int j = num; j <= m; j++) {
            dp[j] = dp[j] || dp[j - num];
        }
    }
    return cnt;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    
    while (t--) {
        int n;
        cin >> n;
        
        vector<int> nums(n);
        for (int i = 0; i < n; i++) {
            cin >> nums[i];
        }
        
        cout << maximalIndependentSet(nums) << '\n';
    }
    
    return 0;
}
```





### 16.AcWing 1020 潜水员(二维价值的背包问题)

潜水员为了潜水要使用特殊的装备。

他有一个带2种气体的气缸：一个为氧气，一个为氮气。

让潜水员下潜的深度需要各种数量的氧和氮。

潜水员有一定数量的气缸。

每个气缸都有重量和气体容量。

潜水员为了完成他的工作需要特定数量的氧和氮。

他完成工作所需气缸的总重的最低限度的是多少？

例如：潜水员有5个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：

```
3 36 120

10 25 129

5 50 250

1 45 130

4 20 119
```

如果潜水员需要5升的氧和60升的氮则总重最小为249（1，2或者4，5号气缸）。

你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。

#### 输入格式

第一行有2个整数 *m*，*n* 。它们表示氧，氮各自需要的量。

第二行为整数 *k* 表示气缸的个数。

此后的 *k* 行，每行包括 *ai* , *bi* , *ci* ，3个整数。这些各自是：第 *i* 个气缸里的氧和氮的容量及气缸重量。

#### 输出格式

仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。

#### 数据范围

1 ≤ *m* ≤ 21 ,

1 ≤ *n* ≤ 79 ,

1 ≤ *k* ≤ 1000 ,

1 ≤ *ai* ≤ 21 ,

1 ≤ *bi* ≤ 79 ,

1 ≤ *ci* ≤ 800



#### 输入样例：

```
5 60
5
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
```

#### 输出样例：

```
249
```



##### Algorithm :

Time Complexity = $O(n m_1 m_2)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

struct Item {
    int value1, value2, weight;
};

int minTotalWeight(vector<Item>& items, int m1, int m2) {
    // dp[j][k] represents the minimum weight 
    // when total_value1 is no less than j and total_value2 is no less than k
    vector<vector<int>> dp(m1 + 1, vector<int>(m2 + 1, INF));
    dp[0][0] = 0;
    for (auto [v1, v2, w] : items) {
        for (int j = m1; j >= 0; j--) {
            for (int k = m2; k >= 0; k--) {
                dp[j][k] = min(dp[j][k], dp[max(0, j - v1)][max(0, k - v2)] + w);
            }
        }
    }
    
    return dp[m1][m2];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m1, m2, n;
    cin >> m1 >> m2 >> n;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.value1 >> item.value2 >> item.weight;
    }
    
    cout << minTotalWeight(items, m1, m2) << '\n';
    
    return 0;
}
```





### 17.AcWing 1013 机器分配(分组背包求具体方案)

总公司拥有 *M* 台 **相同** 的高效设备，准备分给下属的 *N* 个分公司。

各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。

问：如何分配这M台设备才能使国家得到的盈利最大？

求出最大盈利值。

分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数 *M* 。

#### 输入格式

第一行有两个数，第一个数是分公司数 *N* ，第二个数是设备台数 *M* ；

接下来是一个 *N*×*M* 的矩阵，矩阵中的第 *i* 行第 *j* 列的整数表示第 *i* 个公司分配 *j* 台机器时的盈利。

#### 输出格式

第一行输出最大盈利值；

接下 *N* 行，每行有 2 个数，即分公司编号和该分公司获得设备台数。

答案不唯一，输出任意合法方案即可。

#### 数据范围

1 ≤ *N* ≤ 10 ,

1 ≤ *M* ≤ 15



#### 输入样例：

```
3 3
30 40 50
20 30 50
20 25 30
```

#### 输出样例：

```
70
1 1
2 1
3 1
```



#### Algorithm 1:

Time Complexity = $O(n \times m^2)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int maxTotalProfit(vector<vector<int>>& profits, vector<int>& path) {
    int n = profits.size() - 1, m = profits[0].size() - 1;
    
    // dp[i][j] represents the maximum value in previous i groups
    // with total volumn no more than j
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
    for (int i = 1; i <= n; i++) {      // Backgroup knapsack problem
        // Traverse the backpack capacity
        for (int j = 1; j <= m; j++) {
            // Try to select item_k in group i
            for (int k = 0; k <= j; k++) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - k] + profits[i][k]);
            }
        }
    }
    
    // Backtrack the path
    for (int i = n, j = m; i >= 1; i--) {
        int k = 0;
        while (dp[i - 1][j - k] + profits[i][k] != dp[i][j]) {
			k++;
		}
		path[i] = k;
		j -= k;
    }
    
    return dp[n][m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<int>> profits(n + 1, vector<int>(m + 1, 0));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> profits[i][j];
        }
    }
    
    vector<int> path(n + 1);
    cout << maxTotalProfit(profits, path) << '\n';
    for (int i = 1; i <= n; i++) {
        cout << i << ' ' << path[i] << '\n';
    }
    
    return 0;
}
```









### x14.AcWing 1023 买书(完全背包求方案数)

小明手里有 n 元钱全部用来买书，书的价格为10元，20元，50元，100元。

问小明有多少种买书方案？（每种书可购买多本）

#### 输入格式

一个整数 n，代表总共钱数。

#### 输出格式

一个整数，代表选择方案种数。

#### 数据范围

0 ≤ *n* ≤ 1000



#### 输入样例1：

```
20
```

#### 输出样例1：

```
2
```

#### 输入样例2：

```
15
```

#### 输出样例2：

```
0
```

#### 输入样例3：

```
0
```

#### 输出样例3：

```
1
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int numOfSchemes(vector<int>& nums, int m) {
    int n = nums.size();
    
    // dp[j] represents the number of ways to achieve a sum of j
    vector<int> dp(m + 1, 0);
    dp[0] = 1;
    for (auto num : nums) {
        for (int j = num; j <= m; j++) {
            dp[j] += dp[j - num];
        }
    }
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> m;
    
    vector<int> nums{10, 20, 50, 100};
    
    cout << numOfSchemes(nums, m) << '\n';
    
    return 0;
}
```







### x12.LeetCode 0494 Target Sum

You are given an integer array `nums` and an integer `target`.

You want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.

- For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `"+2-1"`.

Return the number of different **expressions** that you can build, which evaluates to `target`.

 

**Example 1:**

```
Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**Example 2:**

```
Input: nums = [1], target = 1
Output: 1
```

 

**Constraints:**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`



##### Algorithm 1:

Time complexity = $O(nm)$ .

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0, n = nums.size();
        for (int i = 0; i < n; i++) {
            sum += nums[i];
        }

        // 分析：假设表达式中所有'+'后面的数的和为 m, 则所有'-'后面的数的和为 sum-m
        //      欲使 m - (sum - m) = target，只需 m = (sum + target) / 2
        // 于是，问题转化为背包容量为 m 的 0-1 背包问题
        if ((sum + target) & 1 || abs(target) > sum) {
            return 0;
        }
        int m = (sum + target) / 2;
        vector<int> dp(m + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for (int j = m; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }

        return dp[m];
    }
};
```























### x13.AcWing 0423 采药

经典 0-1 背包问题求最大收益，略









### x15.AcWing 1022 宠物小精灵之收服(二维费用背包)

宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。

一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。

小智也想收服其中的一些小精灵。

然而，野生的小精灵并不那么容易被收服。

对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。

当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服。

当小智的精灵球用完时，狩猎也宣告结束。

我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。

如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。

小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。

现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。

请问，小智该如何选择收服哪些小精灵以达到他的目标呢？

#### 输入格式

输入数据的第一行包含三个整数：N，M，K，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。

之后的K行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。

#### 输出格式

输出为一行，包含两个整数：C，R，分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值最多为R。

#### 数据范围

0 < *N* ≤ 1000 ,

0 < *M* ≤ 500 ,

0 < *K* ≤ 100



#### 输入样例1：

```
10 100 5
7 10
2 40
2 50
1 20
4 20
```

#### 输出样例1：

```
3 30
```

#### 输入样例2：

```
10 100 5
8 110
12 10
20 10
5 200
1 110
```

#### 输出样例2：

```
0 100
```



##### Algorithm 1:

Time Complexity = $O(n m_1 m_2)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int cost1, cost2;
};

pair<int, int> maxValueAndRemainingStrength(vector<Item>& items, int m1, int m2) {
    // dp[j][k] represents the maximum value 
    // when total_cost1 is no more than j and total_cost2 is no more than k
    vector<vector<int>> dp(m1 + 1, vector<int>(m2 + 1, 0));
    for (auto [cost1, cost2] : items) {
        for (int j = m1; j >= cost1; j--) {
            for (int k = m2; k >= cost2; k--) {
                dp[j][k] = max(dp[j][k], dp[j - cost1][k - cost2] + 1);
            }
        }
    }
    
    int k = m2;
    while (k >= 1 && dp[m1][k - 1] == dp[m1][m2]) {
        k--;
    }
    return {dp[m1][m2], m2 - k};
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m1, m2, n;
    cin >> m1 >> m2 >> n;
    m2--;       // Ensure remaining strength is greater than 0
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.cost1 >> item.cost2;
    }
    
    auto [ans1, ans2] = maxValueAndRemainingStrength(items, m1, m2);
    cout << ans1 << ' ' << ans2 + 1 << '\n';    // Max remaining strength is ans2 + 1
    
    return 0;
}
```



















### x21.AcWing 1019 庆功会(经典混合背包)

为了庆贺班级在校运动会上取得全校第一名成绩，班主任决定开一场庆功会，为此拨款购买奖品犒劳运动员。

期望拨款金额能购买最大价值的奖品，可以补充他们的精力和体力。

#### 输入格式

第一行二个数 n，m，其中 n 代表希望购买的奖品的种数，m 表示拨款金额。

接下来n行，每行3个数，v、w、s，分别表示第 i 种奖品的价格、价值（价格与价值是不同的概念）和能购买的最大数量（买0件到s件均可）。

#### 输出格式

一行：一个数，表示此次购买能获得的最大的价值（注意！不是价格）。

#### 数据范围

*n* ≤ 500 ,

*m* ≤ 6000 ,

*v* ≤ 100 ,

*w* ≤ 1000 ,

*s* ≤ 10



#### 输入样例：

```
5 1000
80 20 4
40 50 9
30 50 7
40 30 6
20 20 1
```

#### 输出样例：

```
1040
```



##### Algorithm 1:

Time Complexity = $O(nm \log s)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value, amount;
};

int maxTotalValue(vector<Item>& items, int m) {
    // dp[j] represents the maximum value 
    // with total volume no more than j
    vector<int> dp(m + 1, 0);
    for (auto [w, v, s] : items) {
        // Try to select k items i
        for (int k = 1; s; s -= k, k = min(2 * k, s)) {
            int kw = k * w, kv = k * v;
            // Traverse the backpack capacity in decreasing order
            for (int j = m; j >= kw; j--) {
                dp[j] = max(dp[j], dp[j - kw] + kv);
            }
        }
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value >> item.amount;
    }
    
    cout << maxTotalValue(items, m) << '\n';
    
    return 0;
}
```















#### 算法2-dfs(194 ms)：

时间复杂度：O($n \times (P_{m-1}^n + P_{m-1}^{n-1}C_n^1 + \dots + P_{m-1}^{1}C_n^{n-1})$) 。n, m 分别为分公司的数量，机器总数量。

```c++
#include <iostream>
#include <algorithm> 

using namespace std;

const int N = 10, M = 15;

int n, m, matrix[N + 1][M + 1];

int maxv, optimal[N + 1];
int curr, path[N + 1];

// 当前枚举第 u 家分公司, 尝试给其分配 cnt 台设备
// 且剩余可分配的机器台数为 rem , 当前盈利为 curr
void dfs(int u, int cnt, int rem) {
	if (!rem) {
		if (curr > maxv) {
			maxv = curr;
			copy_n(path + 1, n, optimal + 1);
		}
		return;
	}
	
	// 尝试再给这家分公司分配一台机器
	curr += matrix[u][cnt + 1];
	path[u]++;
	dfs(u, cnt + 1, rem - 1);
	curr -= matrix[u][cnt + 1];
	path[u]--;
	
	// 尝试不再给这家分公司分配机器 
	if (u < n) {
		dfs(u + 1, 0, rem);
	}
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> matrix[i][j];
		}
		
		for (int j = m; j; j--) {
			matrix[i][j] -= matrix[i][j - 1];
		}
	}
	
	dfs(1, 0, m);
	
	cout << maxv << '\n';
	for (int i = 1; i <= n; i++) {
		cout << i << ' ' << optimal[i] << '\n';
	}
	
	return 0;
}
```





### x26.AcWing 0426 开心的金明(经典0-1 背包)

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。

更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 *N* 元钱就行”。

今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 *N* 元。

于是，他把每件物品规定了一个重要度，分为 5 等：用整数 1∼5 表示，第 5 等最重要。

他还从因特网上查到了每件物品的价格（都是整数元）。

他希望在不超过 *N* 元（可以等于 *N* 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 

设第 *j* 件物品的价格为 *v*[*j*]，重要度为 *w*[*j*]，共选中了 *k* 件物品，编号依次为 *j*1，*j*2，…，*jk*，则所求的总和为： 
$$
v[j_1] \times w[j_1] + v[j_2] \times w[j_2] + \dots + v[j_k] \times w[j_k]
$$
请你帮助金明设计一个满足要求的购物单。

#### 输入格式

输入文件的第 1 行，为两个正整数 *N* 和 *m*，用一个空格隔开。（其中 *N* 表示总钱数，*m* 为希望购买物品的个数） 

从第 2 行到第 *m*+1 行，第 *j* 行给出了编号为 *j*−1 的物品的基本数据，每行有 2 个非负整数 *v* 和 *p*。（其中 *v* 表示该物品的价格，*p* 表示该物品的重要度）

#### 输出格式

输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（数据保证结果不超过 10^8）。

#### 数据范围

1 ≤ *N* < 30000 ,

1 ≤ *m* < 25 ,

0 ≤ *v* ≤ 10000 ,

1 ≤ *p* ≤ 5



#### 输入样例：

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

#### 输出样例：

```
3900
```



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int weight, value;
};

int maxTotalValue(vector<Item>& items, int m) {
    // dp[j] represents the maximum value 
    // with total volume no more than j
    vector<int> dp(m + 1, 0);
    for (auto [w, v] : items) {
        // Traverse the backpack capacity in decreasing order
        for (int j = m; j >= w; j--) {
            dp[j] = max(dp[j], dp[j - w] + v);
        }
    }
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> m >> n;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.weight >> item.value;
        item.value *= item.weight;
    }
    
    cout << maxTotalValue(items, m) << '\n';
    
    return 0;
}
```









### y30.AcWing 0734 能量石(贪心+DP-hard)

岩石怪物杜达生活在魔法森林中，他在午餐时收集了 *N* 块能量石准备开吃。 

由于他的嘴很小，所以一次只能吃一块能量石。 

能量石很硬，吃完需要花不少时间。

吃完第 *i* 块能量石需要花费的时间为 *Si* 秒。

杜达靠吃能量石来获取能量。 

不同的能量石包含的能量可能不同。 

此外，能量石会随着时间流逝逐渐失去能量。 

第 *i* 块能量石最初包含 *Ei* 单位的能量，并且每秒将失去 *Li* 单位的能量。 

当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间）。 

能量石中包含的能量最多降低至 0 。

请问杜达通过吃能量石可以获得的最大能量是多少？

#### 输入格式

第一行包含整数 *T* ，表示共有 *T* 组测试数据。

每组数据第一行包含整数 *N* ，表示能量石的数量。

接下来 *N* 行，每行包含三个整数 *Si* , *Ei* , *Li* 。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 1 开始），*y* 是可以获得的最大能量值。

#### 数据范围

1 ≤ *T* ≤ 10 ,

1 ≤ *N* ≤ 100 ,

1 ≤ *Si* ≤ 100 ,

1 ≤ *Ei* ≤ 10^5 ,

0 ≤ *Li* ≤ 10^5



#### 输入样例：

```
3
4
20 10 1
5 30 5
100 30 1
5 80 60
3
10 4 1000
10 3 1000
10 8 1000
2
12 300 50
5 200 0
```

#### 输出样例：

```
Case #1: 105
Case #2: 8
Case #3: 500
```

#### 样例解释

在样例＃1中，有 *N*=4 个宝石。杜达可以选择的一个吃石头顺序是：

- 吃第四块石头。这需要 5 秒，并给他 80 单位的能量。
- 吃第二块石头。这需要 5 秒，并给他 5 单位的能量（第二块石头开始时具有 30 单位能量，5 秒后失去了 25 单位的能量）。
- 吃第三块石头。这需要 100 秒，并给他 20 单位的能量（第三块石头开始时具有 30 单位能量，10 秒后失去了 10 单位的能量）。
- 吃第一块石头。这需要 20 秒，并给他 0 单位的能量（第一块石头以 10 单位能量开始，110 秒后已经失去了所有的能量）。

他一共获得了 105 单位的能量，这是能获得的最大值，所以答案是 105 。

在样本案例＃2中，有 *N*=3 个宝石。

无论杜达选择吃哪块石头，剩下的两个石头的能量都会耗光。

所以他应该吃第三块石头，给他提供 8 单位的能量。

在样本案例＃3中，有 *N*=2 个宝石。杜达可以：

- 吃第一块石头。这需要 12 秒，并给他 300 单位的能量。
- 吃第二块石头。这需要 5 秒，并给他 200 单位的能量（第二块石头随着时间的推移不会失去任何能量！）。

所以答案是 500 。



##### Algorithm 1:

Time Complexity = $O(n m)$ , where $m = \sum_{i = 1} ^n s_i$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

struct Stone {
    int s, e, l;
    
    bool operator<(const Stone& other) const {
		return s * other.l < other.s * l;
	}
};

int maxTotalEnerge(vector<Stone>& stones, int m) {
    sort(stones.begin(), stones.end());
    
    // dp[j] denotes the maximum payoff of all the schemes that consider the first i stone, 
    // the total time is no more than j, and the last stone is eaten at the end of j seconds.
    vector<int> dp(m + 1, 0);
    
    // 0-1 knapsack problem
    for (auto [s, e, l] : stones) {
        for (int j = m; j >= s; j--) {
            dp[j] = max(dp[j], dp[j - s] + e - (j - s) * l);
        }
    }
    
    int ans = 0;
    for (int j = 1; j <= m; j++) {
        ans = max(ans, dp[j]);
    }
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    
    for (int idx = 1; idx <= t; idx++) {
        int n;
        cin >> n;
        vector<Stone> stones(n);
        int m = 0;
        for (auto& stone : stones) {
            cin >> stone.s >> stone.e >> stone.l;
            m += stone.s;
        }
        cout << "Case #" << idx << ": " << maxTotalEnerge(stones, m) << '\n';
    }
    
    return 0;
}
```



#### 算法2：(bug)

错误原因：本例是排列问题而不是组合问题，即应当按照某种特定的顺序来枚举每一块石头。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100, S = 100, V = N * S;

int n, v;
int seconds[N + 1], energy[N + 1], loss[N + 1];

// f[j] 表示考虑前 i 件物品, 恰好在 j 秒末吃完最后一块石头
// 的所有方案中的最大收益 
int f[V + 1];

int get_ans() {
	fill_n(f, v + 1, 0);
	for (int i = 1; i <= n; i++) {
		for (int j = v; j >= seconds[i]; j--) {
		    // 分别尝试不吃第 i 块石头和在第 j - seconds[i] 秒开始吃第 i 块石头
			f[j] = max(f[j], f[j - seconds[i]] + max(0, energy[i] - (j - seconds[i]) * loss[i]));
		}
	}
	
	int res = 0;
	for (int j = 1; j <= v; j++) {
	    res = max(res, f[j]);
	}
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int t;
	cin >> t;
	
	for (int i = 1; i <= t; i++) {
		cin >> n;
		v = 0;
		for (int j = 1; j <= n; j++) {
			cin >> seconds[j] >> energy[j] >> loss[j];
			v += seconds[j];
		}
		
		cout << "Case #" << i << ": " << get_ans() << '\n';
	}
	
	return 0;
}
```





### x31.AcWing 0487 金明的预算方案(medium)

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。

更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。

今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

![QQ截图20190313024710.png](https://cdn.acwing.com/media/article/image/2019/03/13/19_45c6dcea44-QQ截图20190313024710.png) 

如果要买归类为附件的物品，必须先买该附件所属的主件。

每个主件可以有0个、1个或2个附件。

附件不再有从属于自己的附件。

金明想买的东西很多，肯定会超过妈妈限定的N元。

于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。

他还从因特网上查到了每件物品的价格（都是10元的整数倍）。

他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为*j*1，*j*2，…，*jk* ，则所求的总和为：
$$
v[j_1] \times w[j_1] + v[j_2] \times w[j_2] + \dots + v[j_k] \times w[j_k]
$$
请你帮助金明设计一个满足要求的购物单。

#### 输入格式

输入文件的第1行，为两个正整数，用一个空格隔开：N m，其中N表示总钱数，m为希望购买物品的个数。

从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数v p q，其中v表示该物品的价格，p表示该物品的重要度（1~5），q表示该物品是主件还是附件。

如果q=0，表示该物品为主件，如果q>0，表示该物品为附件，q是所属主件的编号。

#### 输出格式

输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<200000）。

#### 数据范围

*N* < 32000 ,

*m* < 60 ,

*v* < 10000



#### 输入样例：

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

#### 输出样例：

```
2200
```



##### Algorithm 1-Grouped knapsack problem:

Time Complexity = $O(nms\times 2^s)$ , where $s = 0, 1, 2$ and s is the number of accessories for each main component.

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int BASE = 10;

struct Item {
    int weight, value;
};

class ALTree {
private:
    int n;
    vector<vector<int>> heads;
    vector<Item> items;
    
public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        items.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            int v, p, q;
            cin >> v >> p >> q;
            v /= BASE;
            items[i] = {v, v * p};
            // Item 0 is the main part of all main parts
            heads[q].push_back(i);
        }
    }
    
    void init(vector<vector<Item>>& groups) {
        for (int i = 0; i < heads[0].size(); i++) {   // Traverse all main parts
            auto u = heads[0][i];
            int s = heads[u].size(), subsets = 1 << s;  // Number of accessories of u
            groups[i].resize(subsets);
            // Enumerate all the accessory combination schemes
            for (int mask = 0; mask < subsets; mask++) {
                auto [weight, value] = items[u];        // Main part must be chosen in this group
                for (int j = 0; j < s; j++) {
                    if (mask >> j & 1) {
                        int v = heads[u][j];
                        weight += items[v].weight;
                        value += items[v].value;
                    }
                }
                groups[i][mask] = {weight, value};
            }
        }
    }
    
    int maxTotalValue(int m) {
        vector<vector<Item>> groups(heads[0].size());
        init(groups);
        
        // Grouped knapsack problem
        // dp[j] represents the maximum value in previous i groups
        // with total volumn no more than j
        vector<int> dp(m + 1, 0);
        for (auto& group : groups) {
            // Traverse the backpack capacity in decreasing order
            for (int j = m; j > 0; j--) {
                // Try to select item k in group i
                for (auto [w, v] : group) {
                    if (j - w >= 0) {
                        dp[j] = max(dp[j], dp[j - w] + v);
                    }
                }
            }
        }
        
        return dp[m];
    }
};


int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> m >> n;
    
    ALTree T(cin, n);
    
    cout << T.maxTotalValue(m / BASE) * BASE << '\n';
    
    return 0;
}
```



##### Algorithm 2-Tree-shaped DP:

Time Complexity = $O(nm^2)$ .

```c++
#pragma GCC optimize(3)
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int BASE = 10;

struct Item {
    int weight, value;
};

class ALTree {
private:
    int n;
    vector<list<int>> heads;
    vector<Item> items;
    
public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        items.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            int v, p, q;
            cin >> v >> p >> q;
            v /= BASE;
            items[i] = {v, v * p};
            // Item 0 is the main part of all main parts
            heads[q].push_back(i);
        }
    }
    
    // f[u][j] represents the maximum total value of all schemes (u must be chosen) 
    // that consider subtree rooted in u and whose total volume does not exceed j.
    vector<vector<int>> dp;
    int m;
    
    int maxTotalValue(int capacity) {
        m = capacity;
        dp.resize(n + 1, vector<int>(m + 1, 0));
        dfs(0);
        return dp[0][m];
    }
    
    void dfs(int u) {
        auto [weight, value] = items[u];
        for (auto v : heads[u]) {
            dfs(v);
            // Traverse remaining backpack capacity
            for (int j = m - weight; j >= 0; j--) {
                // Try to allocate part of the backpack capacity k to subtree v
                for (int k = 1; k <= j; k++) {
                    // Consider to not select or select item v
                    if (dp[u][j - k] + dp[v][k] > dp[u][j]) {
			            dp[u][j] = dp[u][j - k] + dp[v][k];
			        }
                    // dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[v][k]);
                }
            }
        }
        
        // Select item u (u must be chosen)
        for (int j = m; j >= weight; j--) {
            dp[u][j] = dp[u][j - weight] + value;
        }
        for (int j = min(m, weight - 1); j >= 0; j--) {
            dp[u][j] = 0;
        }
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> m >> n;
    
    ALTree T(cin, n);
    
    cout << T.maxTotalValue(m / BASE) * BASE << '\n';
    
    return 0;
}
```







## 6-2 爬楼梯模型

### 1.LeetCode 0509 斐波那契数

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

 

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

**示例 2：**

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

**示例 3：**

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

 

**提示：**

- `0 <= n <= 30`



#### 算法1：

时间复杂度：O(n)。

```c++
class Solution {
public:
    int fib(int n) {
        int dp[2] = {0, 1};
        for (int i = 2; i <= n; i++) {
            int cur = i & 1;
            dp[cur] += dp[!cur];
        }
        return dp[n & 1];
    }
};
```



### 2.LeetCode 0070 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

 

**提示：**

- `1 <= n <= 45`



#### 算法1：

时间复杂度：O(n)。

```c++
class Solution {
public:
    int climbStairs(int n) {
        int dp[2] = {1, 1};
        for (int i = 2; i <= n; i++) {
            int cur = i & 1;
            dp[cur] += dp[!cur];
        }
        return dp[n & 1];
    }
};
```



### 3.LeetCode 0746 使用最小花费爬楼梯

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

 

**提示：**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`



#### 算法1：

时间复杂度：O(n)。

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        reverse(cost.begin(), cost.end());  // 编号反转，即从上往下编号
        int n = cost.size();

        // dp[i & 1] 表示从 i 号台阶到达楼顶的最低花费
        int dp[2] = {0, 0};
        for (int i = 0; i < n; i++) {
            int cur = i & 1;
            dp[cur] = min(dp[cur], dp[!cur]) + cost[i];
        }
        return min(dp[0], dp[1]);
    }
};
```







## 6-3 钢条切割模型

### 1.AcWing0828 石子合并

设有 *N* 堆石子排成一排，其编号为 $1,2,3,…,N$。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 *N* 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 4 堆石子分别为 `1  3  5  2`， 我们可以先合并 1、2 堆，代价为 4，得到 `4 5 2`， 又合并 1、2 堆，代价为 9，得到 `9 2` ，再合并得到 11，总代价为 4+9+11=24；

如果第二步是先合并 2、3 堆，则代价为 7，得到 `4 7`，最后一次合并代价为 11，总代价为 4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

#### 输入格式

第一行一个数 *N* 表示石子的堆数 *N* 。

第二行 *N* 个数，表示每堆石子的质量(均不超过 1000)。

#### 输出格式

输出一个整数，表示最小代价。

#### 数据范围

1 ≤ *N* ≤ 300



#### 输入样例：

```
4
1 3 5 2
```

#### 输出样例：

```
22
```



#### 算法思想：

石子合并问题是一个经典的动态规划问题，给定一行编号为 1 到 n 的石子，每个石子上有一定数量的价值。现在要将这些石子合并成一堆，每次只能合并相邻的两堆石子，合并的代价为两堆石子的价值之和。求最小的合并代价。

动态规划算法思想如下：

1. 状态表示： `int dp[0..n][0..n]` 定义状态`dp[i][j]`表示合并从第 `i` 到第 `j`个石子所需要的最小代价。
2. **初始化边界条件**：对于长度为 1 的石子序列，不需要合并，代价为0，即`dp[i][i] = 0` 。
3. 状态转移：对于长度为len的石子序列，将其拆分成两段进行合并，即拆分点为k，那么有`dp[i][i+len] = min(dp[i][k] + dp[k+1][i+len] + sum[i+len] - sum[i-1])`，其中 k 的范围为 `[i, i+len-1]` 。
4. 最终答案：最终答案为`dp[1][n]`，即合并从第一个到最后一个石子所需要的最小代价。

时间复杂度：O(n ^ 3)。 n 为石子的堆数。



##### Algorithm 1:

Time Complexity = $O(n^3)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

int minCost(vector<int>& psum) {
    int n = psum.size() - 1;
    
    // dp[i][j] represents the minimum cost to merge nums[i..j]
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, INF));
    for (int i = 1; i <= n; i++) {
        dp[i][i] = 0;
    }
    // Traverse chain length
    for (int len = 2; len <= n; len++) {
        // Traverse interval position
        for (int i = 1, j = len; j <= n; i++, j++) {
            int curCost = psum[j] - psum[i - 1];
            // Traverse cutting position
            for (int k = i; k < j; k++) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + curCost);
            }
        }
    }
    
    return dp[1][n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> psum(n + 1);
    psum[0] = 0;
    for (int i = 1; i <= n; i++) {
        cin >> psum[i];
        psum[i] += psum[i - 1];
    }
    
    cout << minCost(psum) << '\n';
    
    return 0;
}
```





### 2.AcWing 1068 环形石子合并

将 *n* 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。

规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。

请编写一个程序，读入堆数 *n* 及每堆的石子数，并进行如下计算：

- 选择一种合并石子的方案，使得做 *n*−1 次合并得分总和最大。
- 选择一种合并石子的方案，使得做 *n*−1 次合并得分总和最小。

#### 输入格式

第一行包含整数 *n* ，表示共有 *n* 堆石子。

第二行包含 *n* 个整数，分别表示每堆石子的数量。

#### 输出格式

输出共两行：

第一行为合并得分总和最小值，

第二行为合并得分总和最大值。

#### 数据范围

1 ≤ *n* ≤ 200



#### 输入样例：

```
4
4 5 9 4
```

#### 输出样例：

```
43
54
```



##### Algorithm 1:

Time Complexity = $O(n^3)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e8;

int minScore(vector<int>& psum) {
    int m = psum.size() - 1, n = m / 2;
    
    // dp[i][j] represents the minimum cost to merge nums[i..j]
    vector<vector<int>> dp(m + 1, vector<int>(m + 1, INF));
    for (int i = 1; i <= m; i++) {
        dp[i][i] = 0;
    }
    // Traverse chain length
    for (int len = 2; len <= n; len++) {
        // Traverse interval position
        for (int i = 1, j = len; j <= m; i++, j++) {
            int curScore = psum[j] - psum[i - 1];
            // Traverse cutting position
            for (int k = i; k < j; k++) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + curScore);
            }
        }
    }
    
    int ans = INF;
    for (int i = 1, j = n; j <= m; i++, j++) {
        ans = min(ans, dp[i][j]);
    }
    
    return ans;
}

int maxScore(vector<int>& psum) {
    int m = psum.size() - 1, n = m / 2;
    
    // dp[i][j] represents the minimum cost to merge nums[i..j]
    vector<vector<int>> dp(m + 1, vector<int>(m + 1, 0));

    // Traverse chain length
    for (int len = 2; len <= n; len++) {
        // Traverse interval position
        for (int i = 1, j = len; j <= m; i++, j++) {
            int curScore = psum[j] - psum[i - 1];
            // Traverse cutting position
            for (int k = i; k < j; k++) {
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + curScore);
            }
        }
    }
    
    int ans = 0;
    for (int i = 1, j = n; j <= m; i++, j++) {
        ans = max(ans, dp[i][j]);
    }
    
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    int m = n * 2;
    
    vector<int> psum(m + 1);
    for (int i = 1; i <= n; i++) {
        cin >> psum[i];
        psum[i + n] = psum[i];
    }
    for (int i = 1; i <= m; i++) {
        psum[i] += psum[i - 1];
    }
    
    cout << minScore(psum) << '\n' << maxScore(psum) << '\n';
    
    return 0;
}
```





### x1.AcWing 0320 能量项链

在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链，在项链上有 *N* 颗能量珠。

能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。

并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。

因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。

如果前一颗能量珠的头标记为 *m* ，尾标记为 *r*，后一颗能量珠的头标记为 *r*，尾标记为 *n*，则聚合后释放的能量为 *m*×*r*×*n*（Mars 单位），新产生的珠子的头标记为 *m*，尾标记为 *n* 。

需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。

显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设 *N* = 4 ，4 颗珠子的头标记与尾标记依次为 (2，3)(3，5)(5，10)(10，2) 。

我们用记号 ⊕ 表示两颗珠子的聚合操作，(*j*⊕*k*) 表示第 *j*，*k* 两颗珠子聚合后所释放的能量。则

第 4、1 两颗珠子聚合后释放的能量为：(4⊕1) = 10×2×3 = 60 。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 ((4⊕1)⊕2)⊕3)=10×2×3+10×3×5+10×5×10=710 。

#### 输入格式

输入的第一行是一个正整数 *N* ，表示项链上珠子的个数。

第二行是 *N* 个用空格隔开的正整数，所有的数均不超过 1000，第 *i* 个数为第 *i* 颗珠子的头标记，当 *i*<*N* 时，第 *i* 颗珠子的尾标记应该等于第 *i*+1 颗珠子的头标记，第 *N* 颗珠子的尾标记应该等于第 1 颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。

#### 输出格式

输出只有一行，是一个正整数 *E* ，为一个最优聚合顺序所释放的总能量。

#### 数据范围

4 ≤ *N* ≤ 100 ,

1 ≤ *E* ≤ 2.1 × 10^9



#### 输入样例：

```
4
2 3 5 10
```

#### 输出样例：

```
710
```



#### 算法1(26 ms)：

时间复杂度：O(n ^ 3)。n 为项链上珠子的个数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100, M = N * 2;

int n, m, arr[M];

// dp[i][j] 表示将子串 [i, j) 合并的所有方案中的最大收益
int dp[M][M];

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n;
    m = n * 2;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
        arr[i + n] = arr[i];
    }
    
    for (int len = 2; len <= n; len++) {
        for (int i = 0, j = i + len; j < m; i++, j++) {
            for (int k = i + 1; k < j; k++) {
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]);
            }
        }
    }
    
    int res = 0;
    for (int i = 0; i < n; i++) {
        res = max(res, dp[i][i + n]);
    }
    
    cout << res << '\n';
    
    return 0;
}
```





### 44.AcWing 0479 加分二叉树

设一个 *n* 个节点的二叉树 tree 的中序遍历为（1,2,3,…,*n*），其中数字 1,2,3,…,*n* 为节点编号。

每个节点都有一个分数（均为正整数），记第 *i* 个节点的分数为 *di* ，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：     

subtree的左子树的加分 × subtree的右子树的加分 ＋ subtree的根的分数 

若某个子树为空，规定其加分为 1 。

叶子的加分就是叶节点本身的分数，不考虑它的空子树。

试求一棵符合中序遍历为（1,2,3,…,*n* ）且加分最高的二叉树 tree。

要求输出： 

（1）tree的最高加分 

（2）tree的前序遍历

#### 输入格式

第 1 行：一个整数 *n* ，为节点个数。 

第 2 行：*n* 个用空格隔开的整数，为每个节点的分数（0<分数<100）。

#### 输出格式

第 1 行：一个整数，为最高加分（结果不会超过`int`范围）。     

第 2 行：*n* 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。

#### 数据范围

*n* < 30



#### 输入样例：

```
5
5 7 1 2 10
```

#### 输出样例：

```
145
3 1 2 4 5
```



#### 算法1(6 ms)：

时间复杂度：O(n ^ 3)。n 为二叉树的节点的个数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30;

int n, arr[N + 2];

// dp[i][j] 表示中序序列为 arr[i..j] 的所有二叉树
// 的所有加分方案中的最大收益, root[i][j] 为对应的最优二叉树的根
int dp[N + 2][N + 2], root[N + 2][N + 2];

void dfs(int i, int j) {
    int k = root[i][j];
    cout << k << ' ';
    
    if (i < k) {
        dfs(i, k - 1);
    }
    if (k < j) {
        dfs(k + 1, j);
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
    }
    
    for (int i = 1; i <= n + 1; i++) {
        dp[i][i - 1] = 1;
        dp[i][i] = arr[i];
        root[i][i] = i;
    }
    
    for (int len = 2; len <= n; len++) {
        for (int i = 1, j = i + len - 1; j <= n; i++, j++) {
            for (int k = i; k <= j; k++) {
                int curr = dp[i][k - 1] * dp[k + 1][j] + arr[k];
                if (curr > dp[i][j]) {
                    dp[i][j] = curr;
                    root[i][j] = k;
                }
            }
        }
    }
    
    cout << dp[1][n] << '\n';
    
    dfs(1, n);
    
    return 0;
}
```















## 6-4 最长子序列模型

### 1.AcWing0895 最长上升子序列 I

给定一个长度为 *N* 的数列，求数值严格单调递增的子序列的长度最长是多少。

##### 输入格式

第一行包含整数 *N* 。

第二行包含 *N* 个整数，表示完整序列。

##### 输出格式

输出一个整数，表示最大长度。

##### 数据范围

1 ≤ *N* ≤ 1000 ，

−10\^9 ≤ 数列中的数 ≤ 10\^9



##### 输入样例：

```
7
3 1 2 1 8 5 6
```

##### 输出样例：

```
4
```



#### 算法1：

Time Complexity = O(n ^ 2).

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    
    // dp[i] represents length of LIS ending with nums[i]
    vector<int> dp(n, 1);
    // Traverse ending elements
    for (int i = 1; i < n; i++) {
        // Traverse previous elements
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, dp[i]);
    }
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << lengthOfLIS(nums) << '\n';
    
    return 0;
}
```





### 2.AcWing0896 最长上升子序列 II

给定一个长度为 *N* 的数列，求数值严格单调递增的子序列的长度最长是多少。

##### 输入格式

第一行包含整数 *N* 。

第二行包含 *N* 个整数，表示完整序列。

##### 输出格式

输出一个整数，表示最大长度。

##### 数据范围

1 ≤ *N* ≤ 100000 ，

−10\^9 ≤ 数列中的数 ≤ 10\^9



##### 输入样例：

```
7
3 1 2 1 8 5 6
```

##### 输出样例：

```
4
```



#### 算法思想：

使用二分法优化的算法思想如下：

1. 定义一个数组d，数组中元素表示长度为i的最长上升子序列的最后一个元素的最小值，其中i为当前考虑的子序列长度。
2. 遍历原始数组nums，对于每个元素nums[i]，在数组d中使用二分法找到第一个大于等于nums[i]的元素d[k]，并将其替换为nums[i]。
3. 如果nums[i]大于数组d中的所有元素，则将nums[i]追加到数组d的末尾。
4. 最终，数组d的长度即为所求的最长上升子序列的长度。

这种算法的时间复杂度为O(nlogn)，因为需要遍历原始数组一次，并在数组d中使用二分法查找插入位置。



#### 算法1：

Time Complexity = O(n log n).

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int lengthOfLIS(vector<int>& nums) {
    vector<int> tails;
    
    for (auto num : nums) {
        // 1. Binary search, find the first position in the tails that is >=num
        auto it = lower_bound(tails.begin(), tails.end(), num);
        // 2. Update value in that position
        if (it == tails.end()) {
            tails.push_back(num);
        } else {
            *it = num;
        }
    }
    
    return tails.size();
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << lengthOfLIS(nums) << '\n';
    
    return 0;
}
```



#### 算法2(137 ms)：

`int inc[0..idx]` 。 `inc[j] == k` 表示考虑原序列的前缀子序列 `arr[0..i]` 中，长度为 `j + 1` 的上升子序列的最后一个元素的最小值为 `k` 。其中 `j` 的范围为 `[0, idx]` ， `idx` 维护 `arr[0..i]` 中最长上升子序列的长度，即 `idx + 1` 。

指针 `i` 遍历原序列 `arr[0..n]` ，共进行 n 轮迭代。对于每轮迭代：

在 `inc[0..idx]` 中查找第一个不小于 `arr[i]` 的元素，并将之替换为 `arr[i]` 。若未找到，则将 `arr[i]` 插到末尾，计数器 `idx` 加 1 ，即执行 `inc[++idx] = arr[i]` 。

当所有元素已遍历，返回 `idx + 1` ，即为最大上升子序列长度。

时间复杂度：O(n * log n)。其中 n 为原序列的长度。共进行 n 轮迭代，每轮使用二分法查找插入位置，时间开销为 O(log n)，因此总时间为 O(n * log n)。

```c++
#include <iostream>

using namespace std;

const int N = 100000;

int arr[N], n;

// 查找第一个 不小于 val 的元素, 返回位序
int findGeq(int inc[], int low, int high, int val) {
    while (low < high) {
        int mid = (low + high) / 2;
        if (inc[mid] >= val) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    
    return low;
}

int lis() {
    int inc[N], idx = 0;
    
    // i 遍历 arr[0..n-1], 共 n 轮迭代
    inc[idx] = arr[0];
    for (int i = 0; i < n; ++i) {
        if (arr[i] > inc[idx]) {
            inc[++idx] = arr[i];
        }
        else {
            // 在 inc[0..idx] 中寻找 arr[i] 的插入位置
            inc[findGeq(inc, 0, idx, arr[i])] = arr[i];
        }
    }
    
    // 所有元素已遍历, 返回 idx+1
    return idx + 1;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n;
    
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    
    cout << lis();    
    
    return 0;
}
```





### 3.AcWing0897 最长公共子序列

给定两个长度分别为 *N* 和 *M* 的字符串 *A* 和 *B*，求既是 *A* 的子序列又是 *B* 的子序列的字符串长度最长是多少。

#### 输入格式

第一行包含两个整数 *N* 和 *M* 。

第二行包含一个长度为 *N* 的字符串，表示字符串 *A* 。

第三行包含一个长度为 *M* 的字符串，表示字符串 *B* 。

字符串均由小写字母构成。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

1 ≤ *N* , *M* ≤ 1000



#### 输入样例：

```
4 5
acbd
abedc
```

#### 输出样例：

```
3
```



#### 算法思想：

最长公共子序列（Longest Common Subsequence，简称LCS）问题是指给定两个序列 X 和 Y，求它们的最长公共子序列的长度。子序列是指在原序列中删除若干个元素后得到的新序列，而这些删除的元素并不一定是相邻的。

求解最长公共子序列的自底向上动态规划算法的算法思想如下：

1. 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示序列 `X[0...i-1]` 和 `Y[0...j-1]` 的最长公共子序列的长度。
2. 初始化边界条件，即 `dp[0][j] = 0` 和 `dp[i][0] = 0`，表示其中一个序列为空时，最长公共子序列的长度为0。
3. 从左上到右下遍历数组 `dp`，根据递推关系计算 `dp[i][j]` 的值：
   - 如果 `X[i-1] == Y[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`，表示当前字符相同时，最长公共子序列的长度增加1。
   - 如果 `X[i-1] != Y[j-1]`，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`，表示当前字符不同时，最长公共子序列的长度为两个子序列的较大值。
4. 最终 `dp[n][m]` 就是序列 `X` 和 `Y` 的最长公共子序列的长度。

这个算法的时间复杂度为 O(n * m)，其中 n 和 m 分别是序列 X 和 Y 的长度。



#### 算法1：

Time Complexity = O(nm).

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

using namespace std;

int longestCommonSubsequence(string& s, string& t) {
    int n = s.size(), m = t.size();

    // dp[i & 1][j] represents the length of the LCS of s[0..i-1] and t[0..j-1]
    vector<vector<int>> dp(2, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; i++) {
        int cur = i & 1;
        for (int j = 1; j <= m; j++) {
            dp[cur][j] = s[i - 1] == t[j - 1]
                             ? dp[!cur][j - 1] + 1
                             : max(dp[!cur][j], dp[cur][j - 1]);
        }
    }

    return dp[n & 1][m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    int n, m;
    string s, t;
    cin >> n >> m >> s >> t;

    cout << longestCommonSubsequence(s, t) << '\n';

    return 0;
}
```





#### 算法2(73 ms)：

`int dp[0..n][0..m]` ，其中 `dp[i][j]` 表示序列 `a[1...i]` 和 `Y[1...j]` 的最长公共子序列的长度。

初始化边界条件，即 `dp[0][j] = 0` 和 `dp[i][0] = 0`，表示其中一个序列为空时，最长公共子序列的长度为0。

遍历 a 的所有前缀子序列, 外层迭代 n 次。每次外层迭代，遍历 b 的所有前缀子序列, 内层迭代 m 次。状态转移方程为：

- 当前字符相同时, 最长公共子序列的长度为 子序列对 `a[1..i], b[1..j]` 增加 1，即 `dp[i][j] = dp[i - 1][j - 1] + 1` 。
- 当前字符不同时, 最长公共子序列的长度为两个子序列对 `a[1..i-1], b[1..j]` 与 `a[1..i], b[1..j-1]` 中最长公共子序列长度的最大值，即 `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])` 。

当 a, b 全部元素已遍历，返回 `dp[n][m]` ，即为序列 a, b 的最长公共子序列长度。

```c++
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

const int N = 1000, M = 1000;

int n, m;
string a, b;

int lcs() {
    // dp[i][j] 表示子序列 a[1..i] 与 b[1..j] 
    // 的最长公共子序列长度
    int dp[N + 1][M + 1];
    
    for (int i = 0; i <= n; ++i) {
        dp[i][0] = 0;
    }
    for (int j = 0; j <= m; ++j) {
        dp[0][j] = 0;
    }
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (a[i] == b[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[n][m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
    
    string temp;
    cin >> temp;
    a = '\0' + temp;
    cin >> temp;
    b = '\0' + temp;
    
    cout << lcs();
    
    return 0;
}
```





### 4.LeetCode 0718 Maximum Length of Repeated Subarray

Given two integer arrays `nums1` and `nums2`, return *the maximum length of a subarray that appears in **both** arrays*.

 

**Example 1:**

```
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
```

**Example 2:**

```
Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5
Explanation: The repeated subarray with maximum length is [0,0,0,0,0].
```

 

**Constraints:**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`



#### Algorithm 1:

Time Complexity = O(nm).

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        
        // dp[i & 1][j] represents the length of the longest repeated subarray 
        // ending with nums0[i] in nums0[0..i-1] and nums1[j] in nums1[0..j-1]
        vector<vector<int>> dp(2, vector<int>(m + 1, 0));
        
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int cur = i & 1;
            for (int j = 1; j <= m; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[cur][j] = dp[!cur][j - 1] + 1;
                    ans = max(ans, dp[cur][j]);
                } else {
                    dp[cur][j] = 0;
                }
            }
        }
        
        return ans;
    }
};
```





### 5.AcWing 0272 最长上升公共子序列(medium)

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。

小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。

小沐沐说，对于两个数列 *A* 和 *B* ，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。

不过，只要告诉奶牛它的长度就可以了。

数列 *A* 和 *B* 的长度均不超过 3000 。

#### 输入格式

第一行包含一个整数 *N* ，表示数列 *A*，*B* 的长度。

第二行包含 *N* 个整数，表示数列 *A* 。

第三行包含 *N* 个整数，表示数列 *B* 。

#### 输出格式

输出一个整数，表示最长公共上升子序列的长度。

#### 数据范围

1 ≤ *N* ≤ 3000 ,

序列中的数字均不超过 $2^{31} -1$ 。



#### 输入样例：

```
4
2 2 1 3
2 1 2 3
```

#### 输出样例：

```
2
```



#### 算法思想：

1. 状态表示：`f[i][j]` 表示所有由前缀子序列 `a[1..i]` 与 `b[1..j]` 构成的，且以 `b[j]` 结尾的，公共上升子序列的最大长度。

2. 初始化基状态：

   - `f[0][j] = f[i][0] = 0` ，表示其中一个序列为空时，最长公共上升子序列长度为 0 。

3. 状态转移：以下假设初值`f[i][j] = 0;`

   - 考虑到公共上升子序列不以 `a[i]` 结尾的情况，则 `f[i][j] = max(f[i][j], f[i - 1][j]);` 。

   - 考虑公共上升子序列以 `a[i]`  结尾的情况，此时 `a[i] == b[j]` 。则原集合可以分解为 以前缀子序列 `a[1..i-1]` 和 `b[1..k] (0 <= k < j)` 构成的，且以 `b[k]` 结尾的，并满足 `b[k] < a[i]` 的公共上升子序列的末尾加 `a[i]` 形成的序列。即

     `if (a[i] == b[j]) for (int k = 0; k < j; k++) if (b[k] < a[i]) f[i][j] = max(f[i][j], f[i][k] + 1)` ，其中需要注意的是，边界条件 `b[0]` 取尽可能小，使得 `b[0] < b[j] (j > 0)` 恒成立。

4. 结果提取：`max{f[n][j]}, (1 <= j <= m)` 。



#### 算法1(343 ms)：

时间复杂度：O(n ^ 2)。n 为给定序列的长度。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int longestCommonIncreasingSubseqence(vector<int>& nums0, vector<int>& nums1) {
    int n = nums0.size() - 1, m = nums1.size() - 1;
    
    // dp[i & 1][j] represents the length of Longest Common Increasing Subseqence
    // of nums0[1..i] and nums1[1..j] ending with nums1[j]
    vector<vector<int>> dp(2, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; i++) {
        int cur = i & 1;
        // maxLength = max{dp[!cur][k]}, where k belongs to [1, j-1] and nums1[k] < nums0[i]
        int maxLength = 0;
        for (int j = 1; j <= m; j++) {
            // 1. Considering the case that LCIS does not end with nums0[i]
            dp[cur][j] = dp[!cur][j];
            // 2. Considering the case that LCIS ends with nums0[i]
            if (nums0[i] == nums1[j]) {
                dp[cur][j] = max(dp[cur][j], maxLength + 1);
            }
            // 3. Update maxLength
            if (nums1[j] < nums0[i]) {
                maxLength = max(maxLength, dp[!cur][j]);
            }
        }
    }
    
    int ans = 0;
    for (int j = 1; j <= m; j++) {
        ans = max(ans, dp[n & 1][j]);
    }
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    int m = n;
    
    vector<int> nums0(n + 1), nums1(m + 1);
    for (int i = 1; i <= n; i++) {
        cin >> nums0[i];
    }
    for (int i = 1; i <= m; i++) {
        cin >> nums1[i];
    }
    
    cout << longestCommonIncreasingSubseqence(nums0, nums1) << '\n';
    
    return 0;
}
```



#### 算法2(420 ms)：

时间复杂度：O(n ^ 2)。n 为给定序列的长度。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 3000;

int n, a[N + 1], b[N + 1];

// f[i][j] 表示所有由 a[1..i] 和 b[1..j] 构成的,
// 且以 b[j] 结尾的, 所有公共上升子序列的最大长度  
int f[N + 1][N + 1];

int get_ans() {
	for (int i = 1; i <= n; i++) {
		// maxv 表示所有由 a[1..i-1] 和 b[1..k] (0 <= k < j) 构成的,
		// 且以 b[k] 结尾的, 并满足 b[k] < a[i] 的, 所有公共上升子序列的最大长度 
		// 即 maxv = max{f[i - 1][k]} , 其中 k in [0, j-1] 且 b[k] < a[i] 
		int maxv = 0;
		for (int j = 1; j <= n; j++) {
			// 考虑公共上升子序列不以 a[i] 结尾的情况 
			f[i][j] = f[i - 1][j];
			
			// 考虑公共上升子序列以 a[i] 结尾的情况 
			if (a[i] == b[j]) {
				f[i][j] = max(f[i][j], maxv + 1);
			}
			
			// 更新 maxv
			if (b[j] < a[i]) {
				maxv = max(maxv, f[i - 1][j]);
			} 
		}
	}
	
	int res = 0;
	for (int j = 1; j <= n; j++) {
		res = max(res, f[n][j]);
	}
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int j = 1; j <= n; j++) {
		cin >> b[j];
	}
	
	cout << get_ans() << '\n';
	
	return 0;
}
```





### 6.AcWing 1010 拦截导弹

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。

但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。

某天，雷达捕捉到敌国的导弹来袭。

由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

#### 输入格式

共一行，输入导弹依次飞来的高度。

#### 输出格式

第一行包含一个整数，表示最多能拦截的导弹数。

第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。

#### 数据范围

雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过 1000 。



#### 输入样例：

```
389 207 155 300 299 170 158 65
```

#### 输出样例：

```
6
2
```



#### Dilworth’s Theorem

一个序列的最长上升子序列的长度等于能够将该序列完全覆盖的非上升子序列的最少个数。

这个定理的证明可以通过贪心算法来完成。我们可以按照从左到右的顺序，尽可能多地选择非上升子序列，以覆盖整个序列。具体做法是，对于当前元素，如果它比之前选择的非上升子序列中的最后一个元素要小，则将它加入到最后一个非上升子序列中；否则，我们需要新建一个长度为 1 的非上升子序列。最终，所得到的非上升子序列的个数就是覆盖该序列所需的最少个数。



##### Algorithm 1:

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int lengthOfLNIS(vector<int>& nums) {
    reverse(nums.begin(), nums.end());
    
    vector<int> tails;
    for (auto num : nums) {
        auto it = upper_bound(tails.begin(), tails.end(), num);
        if (it == tails.end()) {
            tails.push_back(num);
        } else {
            *it = num;
        }
    }
    
    reverse(nums.begin(), nums.end());
    return tails.size();
}

int lengthOfLIS(vector<int>& nums) {
    vector<int> tails;
    
    for (auto num : nums) {
        auto it = lower_bound(tails.begin(), tails.end(), num);
        if (it == tails.end()) {
            tails.push_back(num);
        } else {
            *it = num;
        }
    }
    
    return tails.size();
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    vector<int> nums;
    int x;
    while (cin >> x) {
        nums.push_back(x);
    }
    
    // Longest Non-Incresing Subsequence
    cout << lengthOfLNIS(nums) << '\n';
    
    // Longest Increasing Subsequence
    cout << lengthOfLIS(nums) << '\n';
    
    return 0;
}
```





### x5.AcWing 1017 怪盗基德的滑翔翼

怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。

而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。

有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。

不得已，怪盗基德只能操作受损的滑翔翼逃脱。

假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。

初始时，怪盗基德可以在任何一幢建筑的顶端。

他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。

因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。

他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。

请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？

#### 输入格式

输入数据第一行是一个整数K，代表有K组测试数据。

每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。

#### 输出格式

对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。

#### 数据范围

1 ≤ *K* ≤ 100 ,

1 ≤ *N* ≤ 100 ,

0 < *h* < 10000



#### 输入样例：

```
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
```

#### 输出样例：

```
6
6
9
```



##### Algorithm 1:

Time Complexity = $O(t \times n \times \log n)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int lengthOfLIS(vector<int>& nums) {
    vector<int> tails;
    for (auto num : nums) {
        auto it = lower_bound(tails.begin(), tails.end(), num);
        if (it == tails.end()) {
            tails.push_back(num);
        } else {
            *it = num;
        }
    }
    return tails.size();
}

int maxNumOfBuildings(vector<int>& nums) {
    int ans = lengthOfLIS(nums);
    reverse(nums.begin(), nums.end());
    ans = max(ans, lengthOfLIS(nums));
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    
    while (t--) {
        int n;
        cin >> n;
        
        vector<int> nums(n);
        for (int i = 0; i < n; i++) {
            cin >> nums[i];
        }
        cout << maxNumOfBuildings(nums) << '\n';
    }
    
    return 0;
}
```



#### 算法2(37 ms)：

时间复杂度：O($tn^2$) 。t, n 分别为数据组数，每组数据的数据个数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100, INF = 1e4;

int n, arr[N + 1];
int seq[N + 1];

int get_ans() {
	fill_n(seq + 1, n, INF);
	
	int ans = 0;
	for (int i = 1; i<= n; i++) {
		int j = i - 1;
		while (seq[j] >= arr[i]) {
			j--;
		}
		seq[j + 1] = arr[i];
		ans = max(ans, j + 1);
	}
	
	fill_n(seq + 1, n, INF);
	
	for (int i = 1; i <= n; i++) {
		int j = i - 1;
		while (seq[j] >= arr[n + 1 - i]) {
			j--;
		}
		seq[j + 1] = arr[n + 1 - i];
		ans = max(ans, j + 1);
	}
	
	return ans;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int t;
	cin >> t;
	
	while (t--) {
		cin >> n;
		for (int i = 1; i <= n; i++) {
			cin >> arr[i];
		}
		cout << get_ans() << '\n';
	}
	
	return 0;
}
```





### x6.AcWing 1014 登山

五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。

同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。

队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

#### 输入格式

第一行包含整数N，表示景点数量。

第二行包含N个整数，表示每个景点的海拔。

#### 输出格式

输出一个整数，表示最多能浏览的景点数。

#### 数据范围

2 ≤ *N* ≤ 1000		-经测试，景点最大高度不大于 1e9 --2024/04/08注



#### 输入样例：

```
8
186 186 150 200 160 130 197 220
```

#### 输出样例：

```
4
```



#### Algorithm 1:

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void lengthOfLIS(vector<int>& nums, vector<int>& left) {
    int n = nums.size();
    
    vector<int> tails;
    for (int i = 0; i < n; i++) {
        auto it = lower_bound(tails.begin(), tails.end(), nums[i]);
        left[i] = it - tails.begin();
        if (it == tails.end()) {
            tails.push_back(nums[i]);
        } else {
            *it = nums[i];
        }
    }
}

int maxNumOfAttractions(vector<int>& nums) {
    int n = nums.size();
    
    vector<int> left(n, 0), right(n, 0);
    lengthOfLIS(nums, left);
    
    reverse(nums.begin(), nums.end());
    lengthOfLIS(nums, right);
    reverse(right.begin(), right.end());
    
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans = max(ans, left[i] + right[i] + 1);
    }
    
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << maxNumOfAttractions(nums) << '\n';
    
    return 0;
}
```





### x7.AcWing 0482 合唱队形

*N* 位同学站成一排，音乐老师要请其中的 (*N*−*K*) 位同学出列，使得剩下的 *K* 位同学排成合唱队形。     

合唱队形是指这样的一种队形：设 *K* 位同学从左到右依次编号为 1，2…，*K*，他们的身高分别为 $T_1, T_2, \dots, T_k$ ，  则他们的身高满足 $T_1 < T_2 < \dots <T_i > T_{i+1} > \dots > T_k(1\leq i \leq k)$ 。     

你的任务是，已知所有 *N* 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

#### 输入格式

输入的第一行是一个整数 *N* ，表示同学的总数。

第二行有 *N* 个整数，用空格分隔，第 *i* 个整数 *Ti* 是第 *i* 位同学的身高(厘米)。

#### 输出格式

输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

#### 数据范围

2 ≤ *N* ≤ 100 ,

130 ≤ *Ti* ≤ 230



#### 输入样例：

```
8
186 186 150 200 160 130 197 220
```

#### 输出样例：

```
4
```



#### Algorithm 1:

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void lengthOfLIS(vector<int>& nums, vector<int>& left) {
    int n = nums.size();
    
    vector<int> tails;
    for (int i = 0; i < n; i++) {
        auto it = lower_bound(tails.begin(), tails.end(), nums[i]);
        left[i] = i -  (it - tails.begin());
        if (it == tails.end()) {
            tails.push_back(nums[i]);
        } else {
            *it = nums[i];
        }
    }
}

int minNumOfRemovals(vector<int>& nums) {
    int n = nums.size();
    
    vector<int> left(n), right(n);
    lengthOfLIS(nums, left);
    
    reverse(nums.begin(), nums.end());
    lengthOfLIS(nums, right);
    reverse(right.begin(), right.end());
    
    int ans = n;
    for (int i = 0; i < n; i++) {
        ans = min(ans, left[i] + right[i]);
    }
    
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << minNumOfRemovals(nums) << '\n';
    
    return 0;
}
```









### y11.AcWing 0187 导弹防御系统(medium)(迭代加深)

为了对抗附近恶意国家的威胁，*R* 国更新了他们的导弹防御系统。

一套防御系统的导弹拦截高度要么一直 **严格单调** 上升要么一直 **严格单调** 下降。

例如，一套系统先后拦截了高度为 3 和高度为 4 的两发导弹，那么接下来该系统就只能拦截高度大于 4 的导弹。

给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

#### 输入格式

输入包含多组测试用例。

对于每个测试用例，第一行包含整数 *n* ，表示来袭导弹数量。

第二行包含 *n* 个**不同的**整数，表示每个导弹的高度。

当输入测试用例 *n*=0 时，表示输入终止，且该用例无需处理。

#### 输出格式

对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。

#### 数据范围

1 ≤ *n* ≤ 50		-经测试，所有导弹的高度均在区间 (-1e9, 1e9) 范围内。-2024/04/08



#### 输入样例：

```
5
3 5 2 4 1
0 
```

#### 输出样例：

```
2
```

#### 样例解释

对于给出样例，最少需要两套防御系统。

一套击落高度为 3,4 的导弹，另一套击落高度为 5,2,1 的导弹。



#### 算法1-迭代加深(624 ms)：

时间复杂度：O($t \times n \times 2^d$)。 t, n 分别为测试用例的组数，每组测试用例中的导弹数量，d 为最优解的取值。最坏情况下的时间开销为 O($t \times n \times 2^n$)。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 50, INF = 1e9;

int n, arr[N];
int incSeq[N], decSeq[N];

bool dfs(int depth, int u, int cnt1, int cnt2) {
	// 总个数大于上限, 剪枝
	if (cnt1 + cnt2 > depth) {
		return false;
	}
	
	// 所有数据已遍历, 说明当前方案可行
	if (u == n) {
		return true;
	} 
	
	// 尝试放入某个上升序列的末尾
	int i = 0;
	while (incSeq[i] >= arr[u]) {
		i++;
	}
	int backup = incSeq[i];
	incSeq[i] = arr[u];
	if (dfs(depth, u + 1, max(cnt1, i + 1), cnt2)) {
		return true;
	}
	incSeq[i] = backup;
	
	// 尝试放入某个下降序列的末尾 
	i = 0;
	while (decSeq[i] <= arr[u]) {
		i++;
	} 
	backup = decSeq[i];
	decSeq[i] = arr[u];
	if (dfs(depth, u + 1, cnt1, max(cnt2, i + 1))) {
		return true;
	}
    decSeq[i] = backup;
	return false;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	while (cin >> n, n) {
		for (int i = 0; i < n; i++) {
			cin >> arr[i];
			incSeq[i] = -INF;
			decSeq[i] = INF; 
		}
		
		int depth = 0;
		while (!dfs(depth, 0, 0, 0)) {
			depth++;
		}
		
		cout << depth << '\n';
	}
	
	return 0;
}
```



#### 算法2-dfs+剪枝(604 ms)：

时间复杂度：O($t \times n \times 2^n$)。 t, n 分别为测试用例的组数，每组测试用例中的导弹数量。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 50, INF = 1e9;

int n, arr[N];
int ans, incSeq[N], decSeq[N];

void dfs(int u, int cnt1, int cnt2) {
    // 当前解一定大于等于最优解, 剪枝 
	if (cnt1 + cnt2 >= ans) {
		return;
	}
    
	// 所有数据已遍历, 更新最优解 
	if (u == n) {
		ans = cnt1 + cnt2;
		return;
	}
	
	// 尝试放入某个上升序列的末尾
	int i = 0;
	while (incSeq[i] >= arr[u]) {
		i++;
	} 
	int backup = incSeq[i];
	incSeq[i] = arr[u];
	dfs(u + 1, max(cnt1, i + 1), cnt2);
	incSeq[i] = backup;
	
	// 尝试放入某个下降序列的末尾
	i = 0;
	while (decSeq[i] <= arr[u]) {
		i++;
	} 
	backup = decSeq[i];
	decSeq[i] = arr[u];
	dfs(u + 1, cnt1, max(cnt2, i + 1));
	decSeq[i] = backup;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	while (cin >> n, n) {
		for (int i = 0; i < n; i++) {
			cin >> arr[i];
			incSeq[i] = -INF;
			decSeq[i] = INF;
		}
		
		ans = n + 1;
		dfs(0, 0, 0);
		
		cout << ans << '\n';
	}
	
	return 0;
}
```



























### 94.AcWing0338 数位统计DP(medium)

给定两个整数 *a* 和 *b*，求 *a* 和 *b* 之间的所有数字中 0∼9 的出现次数。

例如，*a* = 1024 ，*b* = 1032 ，则 *a* 和 *b* 之间共有 9 个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 10 次，`1` 出现 10 次，`2` 出现 7 次，`3` 出现 3 次等等…

#### 输入格式

输入包含多组测试数据。

每组测试数据占一行，包含两个整数 *a* 和 *b* 。

当读入一行为 `0 0` 时，表示输入终止，且该行不作处理。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示 `0` 出现的次数，第二个数字表示 `1` 出现的次数，以此类推。

#### 数据范围

0 < *a* , *b* < 100000000



#### 输入样例：

```
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
```

#### 输出样例：

```
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
```



#### 算法1(12 ms)：

时间复杂度：O(n D)。 n, D 分别为数据组数，每组数据的十进制位的位数。即 D = O($log_{10}N$) ，N 为每组数据的最大取值。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int D = 8;

int power[D];
int deci[D], idx;

int count(int n, int d) {
	idx = 0;
	for (int num = n; num; num /= 10) {
		deci[idx++] = num % 10;
	}
	
	int res = 0;
	
	// 从高位向低位遍历每个十进制位
	for (int i = idx - 1 - !d; i >= 0; i--) {
		if (i != idx - 1) {
		    // 1. 高位取遍 [!d, n / power[i + 1]], 低位取遍 [0, power[i] - 1]
			res += (n / power[i + 1] - !d) * power[i];
		}
		
		// 2. 高位取 n / power[i + 1], 当前位取 d
		if (d < deci[i]) {
		    // 低位取遍 [0, power[i] - 1]
			res += power[i];
		}
		else if (d == deci[i]) {
		    // 低位取遍 [0, n % power[i]]
			res += n % power[i] + 1;
		}
	}
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	power[0] = 1;
	for (int i = 1; i < D; i++) {
		power[i] = power[i - 1] * 10;
	}
	
	int a, b;
	while (cin >> a >> b, a || b) {
		if (a > b) {
			swap(a, b);
		}
		for (int i = 0; i <= 9; i++) {
			cout << count(b, i) - count(a - 1, i) << ' ';
		}
		cout << '\n';
	}
	
	return 0;
}
```





















## 6-5 编辑距离模型

### 1.AcWing0902 最短编辑距离

给定两个字符串 *A* 和 *B*，现在要将 *A* 经过若干操作变为 *B* ，可进行的操作有：

1. 删除–将字符串 *A* 中的某个字符删除。
2. 插入–在字符串 *A* 的某个位置插入某个字符。
3. 替换–将字符串 *A* 中的某个字符替换为另一个字符。

现在请你求出，将 *A* 变为 *B* 至少需要进行多少次操作。

##### 输入格式

第一行包含整数 *n* ，表示字符串 *A* 的长度。

第二行包含一个长度为 *n* 的字符串 *A* 。

第三行包含整数 *m* ，表示字符串 *B* 的长度。

第四行包含一个长度为 *m* 的字符串 *B* 。

字符串中均只包含大小写字母。

##### 输出格式

输出一个整数，表示最少操作次数。

##### 数据范围

1 ≤ *n* , *m* ≤ 1000



##### 输入样例：

```
10
AGTCTGACGC
11
AGTAAGTAGGC
```

##### 输出样例：

```
4
```



#### 算法思想：

字符串最短编辑距离（Shortest Edit Script）问题是指给定两个字符串，通过一系列编辑操作（插入、删除、替换）将一个字符串转换为另一个字符串所需的最少操作次数。这些编辑操作可以分别对应着改变一个字符、删除一个字符和插入一个字符。

自底向上动态规划算法是求解字符串最短编辑距离问题的一种常见方法。该算法的思想是构建一个二维数组`dp`，其中`dp[i][j]`表示将字符串1的前`i`个字符转换为字符串2的前`j`个字符所需的最少操作次数。然后，通过填充这个二维数组来求解最短编辑距离。

具体算法思想如下：

1. 初始化一个二维数组`dp`，其大小为`(m+1) * (n+1)`，其中`m`和`n`分别是字符串1和字符串2的长度。
2. 初始化边界条件：任意字符串与空字符串间的编辑距离为该字符串的长度。
3. 状态转移：从`dp[0][0]`开始逐行逐列填充数组`dp`。对于`dp[i][j]`，如果字符串1的第`i`个字符等于字符串2的第`j`个字符，则`dp[i][j]`等于`dp[i-1][j-1]`。否则，取`dp[i-1][j-1]` (修改) 、`dp[i][j-1]` (插入) 和`dp[i-1][j]` (删除) 的最小值，然后加1。
4. 最终`dp[m][n]`即为字符串最短编辑距离。

这种算法的时间复杂度为$O(mn)$，其中$m$和$n$分别是两个字符串的长度。



#### 算法1：

Time Complexity = $O(mn)$ .

```c++
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int minEditDistance(string& s, string& t) {
    int n = s.size(), m = t.size();

    // dp[i & 1][j] represents the minimum edit distance 
    // from s[0..i-1] to t[0..j-1]
    vector<vector<int>> dp(2, vector<int>(m + 1));
    for (int j = 1; j <= m; j++) {
        dp[0][j] = j;               // Initialize base state
    }

    for (int i = 1; i <= n; i++) {
        int cur = i & 1;
        dp[cur][0] = i;             // Initialize base state
        for (int j = 1; j <= m; j++) {
            // Insert, delete or replace
            dp[cur][j] = s[i - 1] == t[j - 1] ? dp[!cur][j - 1]
                    : min({dp[!cur][j], dp[cur][j - 1], dp[!cur][j - 1]}) + 1;
        }
    }
    return dp[n & 1][m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    int n, m;
    string s, t;
    cin >> n >> s >> m >> t;

    cout << minEditDistance(s, t) << '\n';

    return 0;
}
```



### 2.LeetCode 0583 Minimum Delete Operations

Given two strings `word1` and `word2`, return *the minimum number of **steps** required to make* `word1` *and* `word2` *the same*.

In one **step**, you can delete exactly one character in either string.

 

**Example 1:**

```
Input: word1 = "sea", word2 = "eat"
Output: 2
Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
```

**Example 2:**

```
Input: word1 = "leetcode", word2 = "etco"
Output: 4
```

 

**Constraints:**

- `1 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of only lowercase English letters.



#### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
class Solution {
public:
    int minDeleteOperations(string s, string t) {
        int n = s.size(), m = t.size();
        
        // Get the length of Longest Common Subseqence of s and t
        vector<vector<int>> dp(2, vector<int>(m + 1, 0));
        for (int i = 1; i <= n; i++) {
            int cur = i & 1;
            for (int j = 1; j <= m; j++) {
                dp[cur][j] = s[i - 1] == t[j - 1] ?
                    dp[!cur][j - 1] + 1 : max(dp[!cur][j], dp[cur][j - 1]);
            }
        }

        return n + m - dp[n & 1][m] * 2;
    }
};
```



### 3.LeetCode 0115 Distinct Subsequences

Given two strings s and t, return *the number of distinct* ***subsequences\*** *of* s *which equals* t.

The test cases are generated so that the answer fits on a 32-bit signed integer.

 

**Example 1:**

```
Input: s = "rabbbit", t = "rabbit"
Output: 3
Explanation:
As shown below, there are 3 ways you can generate "rabbit" from s.
rabbbit
rabbbit
rabbbit
```

**Example 2:**

```
Input: s = "babgbag", t = "bag"
Output: 5
Explanation:
As shown below, there are 5 ways you can generate "bag" from s.
babgbag
babgbag
babgbag
babgbag
babgbag
```

 

**Constraints:**

- `1 <= s.length, t.length <= 1000`
- `s` and `t` consist of English letters.



#### Algorithm 1:

Time Complesity = $O(nm)$ .

```c++
class Solution {
    const unsigned INF = 1 << 31;
public:
    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        // dp[i & 1][j] represents the number of ways 
        // that we can generate t[0..j-1] from s[0..i-1]
        vector<vector<unsigned>> dp(2, vector<unsigned>(m + 1, 0));
        dp[0][0] = dp[1][0] = 1;
        for (int i = 1; i <= n; i++) {
            int cur = i & 1;
            for (int j = 1; j <= m; j++) {
                // 1. Consider cases that do not use s[i-1]
                dp[cur][j] = dp[!cur][j];
                // 2. Consider cases that use s[i-1]
                if (s[i - 1] == t[j - 1]) {
                    dp[cur][j] += dp[!cur][j - 1];
                }
            }
            if (dp[cur][m] >= INF) {
                return 0;
            }
        }
        return dp[n & 1][m];
    }
};
```





### x91.AcWing0899 编辑距离

给定 *n* 个长度不超过 10 的字符串以及 *m* 次询问，每次询问给出一个字符串和一个操作次数上限。

对于每次询问，请你求出给定的 *n* 个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。

每个对字符串进行的单个字符的插入、删除或替换算作一次操作。

##### 输入格式

第一行包含两个整数 *n* 和 *m* 。

接下来 *n* 行，每行包含一个字符串，表示给定的字符串。

再接下来 *m* 行，每行包含一个字符串和一个整数，表示一次询问。

字符串中只包含小写字母，且长度均不超过 10 。

##### 输出格式

输出共 *m* 行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。

##### 数据范围

1 ≤ *n* , *m* ≤ 1000 ,



##### 输入样例：

```
3 2
abc
acd
bcd
ab 1
acbd 2
```

##### 输出样例：

```
1
3
```



#### 算法1(2025 ms)：

时间复杂度：O(n * m * l ^ 2) 。其中，n 为给定查找集合中的字符串个数， m 为询问个数，l 为字符串的最大长度。

```c++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int L = 10, N = 1000;

int n;
char str[N][L + 2];

int f[L + 1][L + 1];

bool ses(char a[], char b[], int limit) {
	int la = strlen(a + 1), lb = strlen(b + 1);
	
	for (int i = 1; i <= la; i++) {
		f[i][0] = i;
	}
	for (int j = 1; j <= lb; j++) {
		f[0][j] = j;
	}
	
	for (int i = 1; i <= la; i++) {
		for (int j = 1; j <= lb; j++) {
			f[i][j] = a[i] == b[j] ? f[i - 1][j - 1] :
				min(min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1;
		}
	}
	
	return f[la][lb] <= limit;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	for (int i = 0; i < n; i++) {
		cin >> str[i] + 1;
	}
	
	while (m--) {
		char t[L + 2];
		int limit;
		cin >> t + 1 >> limit;
		int res = 0;
		for (int i = 0; i < n; i ++) {
			res += ses(str[i], t, limit);
		}
		
		cout << res << '\n';
	}
	
	return 0;
}
```



#### 算法2(2500 ms)：

对于每次询问，分别将字符串 s 与 n 个字符串比较并求解最短编辑距离。

时间复杂度：O(n * m * l ^ 2) 。其中，n 为给定查找集合中的字符串个数， m 为询问个数，l 为字符串的最大长度。

```c++
#include <iostream>
#include <string>

using namespace std;

const int N = 1000, L = 10;

int n;
string str[N];

bool ses(string &a, string &b, int limit) {
    int la = a.size(), lb = b.size();
    
    int dp[L + 1][L + 1];
    
    for (int i = 0; i <= la; ++i) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= lb; ++j) {
        dp[0][j] = j;
    }
    
    for (int i = 1; i <= la; ++i) {
        for (int j = 1; j <= lb; ++j) {
            dp[i][j] = a[i - 1] == b[j - 1] ? dp[i - 1][j - 1] :
                min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
        }
    }
    
    return dp[la][lb] <= limit;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    for (int i = 0; i < n; ++i) {
        cin >> str[i];
    }
    
    while (m--) {
        string s;
        int limit;
        cin >> s >> limit;
        
        int res = 0;
        for (int i = 0; i < n; ++i) {
            res += ses(str[i], s, limit);
        }
        
        cout << res << endl;
    }
    
    return 0;
}
```







## 6-6 状态机模型

### 1.LeetCode 0198 House Robber I

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

 

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**

```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`



#### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();

        // dp[i & 1] represents the maximum value considering the first i items
        vector<int> dp(2, 0);
        for (int i = 1; i <= n; i++) {
            int cur = i & 1;
            // Try to  not select/select  item i respectively
            dp[cur] = max(dp[!cur], dp[cur] + nums[i - 1]);
        }

        return dp[n & 1];
    }
};
```





### 2.LeetCode 0213 House Robber II

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

 

**Example 1:**

```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```

**Example 2:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 3:**

```
Input: nums = [1,2,3]
Output: 3
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`



#### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
private:
    int robChain(vector<int>& nums) {
        int n = nums.size();

        // dp[i & 1] represents the maximum value considering the first i items
        vector<int> dp(2, 0);
        for (int i = 1; i <= n; i++) {
            int cur = i & 1;
            // Try to  not select/select  item i respectively
            dp[cur] = max(dp[!cur], dp[cur] + nums[i - 1]);
        }

        return dp[n & 1];
    }
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        if (nums.size() == 1) {
            return nums[0];
        }

        // At least one end is not selected, thus breaking the ring into a chain.
        auto nums0 = vector<int>(nums.begin() + 1, nums.end());
        auto nums1 = vector<int>(nums.begin(), nums.end() - 1);
        return max(robChain(nums0), robChain(nums1));
    }
};
```





### 3.AcWing 1057 股票买卖IV(medium)

给定一个长度为 *N* 的数组，数组中的第 *i* 个数字表示一个给定股票在第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润，你最多可以完成 *k* 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。

#### 输入格式

第一行包含整数 *N* 和 *k* ，表示数组的长度以及你可以完成的最大交易笔数。

第二行包含 *N* 个不超过 10000 的非负整数，表示完整的数组。

#### 输出格式

输出一个整数，表示最大利润。

#### 数据范围

1 ≤ *N* ≤ 10^5 ,

1 ≤ *k* ≤ 100



#### 输入样例1：

```
3 2
2 4 1
```

#### 输出样例1：

```
2
```

#### 输入样例2：

```
6 2
3 2 6 5 0 3
```

#### 输出样例2：

```
7
```

#### 样例解释

样例1：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

样例2：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 =  3-0 = 3 。共计利润 4+3 = 7.



#### 算法1：

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

int maxTotalProfit(vector<int>& prices, int m) {
    int n = prices.size();

    // Considering the first i days, dp[j][0/1] represent the maximum profit
    // in schemes that the jth stock transaction is underway, 
    // without/with stocks in hand
    vector<vector<int>> dp(m + 1, vector<int>(2, -INF));
    // The maximum Profit of no trading, no stock in the hands is 0
    dp[0][0] = 0;

    for (auto price : prices) {
        // Traverse transaction times in decreasing order
        for (int j = m; j >= 1; j--) {
            dp[j][0] = max(dp[j][0], dp[j][1] + price);
            dp[j][1] = max(dp[j][1], dp[j - 1][0] - price);
        }
    }

    int ans = -INF;
    for (int j = 0; j <= m; j++) {
        ans = max(ans, dp[j][0]);
    }
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, k;
    cin >> n >> k;
    
    vector<int> prices(n);
    for (int i = 0; i < n; i++) {
        cin >> prices[i];
    }
    
    cout << maxTotalProfit(prices, k) << '\n';
    
    return 0;
}
```





### 4.AcWing 1058 股票买卖V(medium)

给定一个长度为 *N* 的数组，数组中的第 *i* 个数字表示一个给定股票在第 *i* 天的价格。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

#### 输入格式

第一行包含整数 *N* ，表示数组长度。

第二行包含 *N* 个不超过 10000 的正整数，表示完整的数组。

#### 输出格式

输出一个整数，表示最大利润。

#### 数据范围

1 ≤ *N* ≤ 10^5



#### 输入样例：

```
5
1 2 3 0 2
```

#### 输出样例：

```
3
```

#### 样例解释

对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]，第一笔交易可得利润 2-1 = 1，第二笔交易可得利润 2-0 = 2，共得利润 1+2 = 3。



#### 算法1：

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

int maxProfit(vector<int>& prices) {
    // Considering the first i days, dp[0/1/2] represents the maximum profit 
    // in the three states of  non-freezing period/buying state/freezing period
    vector<int> dp(3, -INF);
    dp[0] = 0;

    for (auto price : prices) {
        int temp = dp[2];
        // Sell and enter the freezing period
        dp[2] = dp[1] + price;
        // Do not sell and keep/buy and enter the buying state
        dp[1] = max(dp[1], dp[0] - price);
        // Do not buy and keep/thaw and enter a non-freezing state
        dp[0] = max(dp[0], temp);
    }

    return max(dp[0], dp[2]);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> prices(n);
    for (int i = 0; i < n; i++) {
        cin >> prices[i];
    }
    
    cout << maxProfit(prices) << '\n';
    
    return 0;
}
```





### x1.AcWing 1049 大盗阿福            

阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。

这条街上一共有 *N* 家店铺，每家店中都有一些现金。

阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。

作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。

他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？

#### 输入格式

输入的第一行是一个整数 *T* ，表示一共有 *T* 组数据。

接下来的每组数据，第一行是一个整数 *N* ，表示一共有 *N* 家店铺。

第二行是 *N* 个被空格分开的正整数，表示每一家店铺中的现金数量。

每家店铺中的现金数量均不超过1000。

#### 输出格式

对于每组数据，输出一行。

该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。

#### 数据范围

1 ≤ *T* ≤ 50 ,

1 ≤ *N* ≤ 10^5



#### 输入样例：

```
2
3
1 8 2
4
10 7 6 14
```

#### 输出样例：

```
8
24
```

#### 样例解释

对于第一组样例，阿福选择第2家店铺行窃，获得的现金数量为8。

对于第二组样例，阿福选择第1和4家店铺行窃，获得的现金数量为10+14=24。



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int maxTotalValue(vector<int>& nums) {
    int n = nums.size();
    
    // dp[0/1] represents the maximum value considering the first i items
    // in the cases that not select/select item_i
    vector<int> dp(2, 0);
    for (auto num : nums) {
        dp = {max(dp[0], dp[1]), dp[0] + num};
    }
    return max(dp[0], dp[1]);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    
    while (t--) {
        int n;
        cin >> n;
        vector<int> nums(n);
        for (auto& num : nums) {
            cin >> num;
        }
        cout << maxTotalValue(nums) << '\n';
    }
    
    return 0;
}
```



##### Algorithm 2:











## 6-7 数字矩阵模型

### 0.数字矩阵模板

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxPathSum(vector<vector<int>>& nums) {
    int n = nums.size() - 1, m = nums[1].size() - 1;
    
    // dp[j] represents the maximum path sum considering first i rows
    vector<int> dp(m + 1, 0);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dp[j] = max(dp[j - 1], dp[j]) + nums[i][j];
        }
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<int>> nums(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> nums[i][j];
        }
    }
    
    cout << maxPathSum(nums) << '\n';
    
    return 0;
}
```



### 1.AcWing 1015 摘花生

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

![1.gif](https://cdn.acwing.com/media/article/image/2019/09/12/19_a8509f26d5-1.gif) 

##### 输入格式

第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

##### 输出格式

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

##### 数据范围

1 ≤ *T* ≤ 100 ,

1 ≤ *R* , *C* ≤ 100 ,

0 ≤ *M* ≤ 1000



#### 输入样例：

```
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

#### 输出样例：

```
8
16
```



##### Algorithm 1:

Time Complexity = $O(tnm)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxPathSum(vector<vector<int>>& nums) {
    int n = nums.size() - 1, m = nums[1].size() - 1;
    
    // dp[j] represents the maximum path sum considering first i rows
    vector<int> dp(m + 1, 0);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dp[j] = max(dp[j - 1], dp[j]) + nums[i][j];
        }
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    
    while (t--) {
        int n, m;
        cin >> n >> m;
        
        vector<vector<int>> nums(n + 1, vector<int>(m + 1));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                cin >> nums[i][j];
            }
        }
        
        cout << maxPathSum(nums) << '\n';
    }
    
    return 0;
}
```



#### 算法2(285 ms)：

时间复杂度：O(tnm)。 t, n, m 分别为数据组数，每组数据的行数与列数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int M = 100;

int f[M + 1]; 

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int cnt;
	cin >> cnt;
	
	while (cnt--) {
		int n, m;
		cin >> n >> m;
		fill_n(f, m + 1, 0);
		
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				int num;
				cin >> num;
				f[j] = max(f[j - 1], f[j]) + num;
			}
		}
		
		cout << f[m] << '\n';
	}
	
	return 0;
}
```











### 2.AcWing 1018 最低通行费

一个商人穿过一个 *N*×*N* 的正方形的网格，去参加一个非常重要的商务活动。

他要从网格的左上角进，右下角出。

每穿越中间 1 个小方格，都要花费 1 个单位时间。

商人必须在 (2*N*−1) 个单位时间穿越出去。

而在经过中间的每个小方格时，都需要缴纳一定的费用。

这个商人期望在规定时间内用最少费用穿越出去。

请问至少需要多少费用？

注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。

#### 输入格式

第一行是一个整数，表示正方形的宽度 *N* 。

后面 *N* 行，每行 *N* 个不大于 100 的正整数，为网格上每个小方格的费用。

#### 输出格式

输出一个整数，表示至少需要的费用。

#### 数据范围

1 ≤ *N* ≤ 100

每个小方格的费用不大于 100 。



#### 输入样例：

```
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
```

#### 输出样例：

```
109
```

#### 样例解释

样例中，最小值为 109=1+2+5+7+9+12+19+21+33 。



##### 算法1：

Time Complexity = $O(n ^ 2)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9;

int minPathSum(vector<vector<int>>& nums) {
    int n = nums.size() - 1, m = nums[1].size() - 1;
    
    // dp[j] represents the minimum path sum considering first i rows
    vector<int> dp(m + 1, INF);
    dp[1] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dp[j] = min(dp[j - 1], dp[j]) + nums[i][j];
        }
    }
    
    return dp[m];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    int m = n;
    
    vector<vector<int>> nums(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> nums[i][j];
        }
    }
    
    cout << minPathSum(nums) << '\n';
    
    return 0;
}
```



#### 算法1(18 ms)：

时间复杂度：O(n ^ 2)。 n 为正方形的边长。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100, INF = 1e9;

int n, f[N + 1];

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	
	fill_n(f, n + 1, INF);
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			int curr;
			cin >> curr;
			if (i == 1 && j == 1) {
				f[j] = curr;
				continue;
			} 
			f[j] = min(f[j - 1], f[j]) + curr;
		}
	}
	
	cout << f[n];
	
	return 0;
} 
```



### 3.AcWing 0275 传纸条(medium)

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。

一次素质拓展活动中，班上同学安排坐成一个 *m* 行 *n* 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。

幸运的是，他们可以通过传纸条来进行交流。

纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 (1,1)，小轩坐在矩阵的右下角，坐标 (*m*,*n*) 。

从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。

班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 0 表示），可以用一个 0∼100 的自然数来表示，数越大表示越好心。

小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。

现在，请你帮助小渊和小轩找到这样的两条路径。

#### 输入格式

第一行有 2 个用空格隔开的整数 *m* 和 *n*，表示学生矩阵有 *m* 行 *n* 列。

接下来的 *m* 行是一个 *m*×*n* 的矩阵，矩阵中第 *i* 行 *j* 列的整数表示坐在第 *i* 行 *j* 列的学生的好心程度，每行的 *n* 个整数之间用空格隔开。

#### 输出格式

输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

#### 数据范围

1 ≤ *n* , *m* ≤ 50



#### 输入样例：

```
3 3
0 3 9
2 8 5
5 7 0
```

#### 输出样例：

```
34
```



#### 算法1：

Time Complexity = $O((n + m)n^2)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxSumOfMaxPathSum(vector<vector<int>>& nums, int n, int m) {
    int steps = n + m - 2;
    
    // dp[k & 1][i1][i2] represents the maximum sum of maximum path sums
    // from (1, 1) to (i1, j1), (i2, j2)  where k = i1 + j1 - 2 = i2 + j2 - 2
    vector<vector<vector<int>>> dp(2, vector<vector<int>>(n + 1, vector<int>(n + 1, 0)));
    dp[0][1][1] = nums[1][1];
    for (int k = 1; k <= steps; k++) {
        int cur = k & 1;
        for (int i1 = 1, j1 = k - i1 + 2; i1 <= n; i1++, j1--) {
            if (j1 < 1 || j1 > m) {
                continue;
            }
            
            for (int i2 = 1, j2 = k - i2 + 2; i2 <= n; i2++, j2--) {
                if (j2 < 1 || j2 > m) {
                    continue;
                }
                // The first path steps forword to (i1, j1)
                int delta = nums[i1][j1];
                // The second path steps forword to (i2, j2)
                if (i1 != i2) {
                    delta += nums[i2][j2];
                }
                
                // Try to step from <left, left>, <left, up>, 
                // <up, left>, <up, up> respectively
                dp[cur][i1][i2] = max({
                    dp[!cur][i1][i2], 
                    dp[!cur][i1][i2 - 1], 
                    dp[!cur][i1 - 1][i2], 
                    dp[!cur][i1 - 1][i2 - 1]
                }) + delta;
            }
        }
    }
    
    return dp[steps & 1][n][n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<int>> nums(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> nums[i][j];
        }
    }
    
    cout << maxSumOfMaxPathSum(nums, n, m) << '\n';
    
    return 0;
}
```





#### 算法1(18 ms)：

时间复杂度：O($(n+m)n^2$) 。n, m 分别为矩阵的行数，列数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 50, M = 50;

int n, m, matrix[N + 1][M + 1];
int f[2][N + 1][M + 1];

int get_ans() {
	// from (1, 2), (2, 1) to (n - 1, m), (n, m - 1), (l-1)steps
	int l = n + m - 2;
	for (int k = 1; k < l; k++) {
		int ck = k & 1, pk = ck ^ 1;
		for (int i1 = 1, j1 = k + 2 - i1; i1 < n; i1++, j1--) {
			if (j1 < 2 || j1 > m) {
				continue;
			}
			
			for (int i2 = i1 + 1, j2 = k + 2 - i2; i2 <= n; i2++, j2--) {
				if (j2 < 1 || j2 >= m) {
					continue;
				}
				
				int t = matrix[i1][j1] + matrix[i2][j2];
				f[ck][i1][i2] = max(max(f[pk][i1][i2], f[pk][i1][i2 - 1]),
									max(f[pk][i1 - 1][i2], f[pk][i1 - 1][i2 - 1])) + t;
			}
		}
	}
	
	return f[(l - 1) & 1][n - 1][n];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> matrix[i][j];
		}
	}
	
	cout << get_ans();
	
	return 0;
}
```



### 4.AcWing 1027 方格取数(medium)

设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

![2.gif](https://cdn.acwing.com/media/article/image/2019/09/12/19_764ece6ed5-2.gif) 

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

#### 输入格式

第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“0 0 0”表示结束。

#### 输出格式

输出一个整数，表示两条路径上取得的最大的和。

#### 数据范围

*N* ≤ 10



#### 输入样例：

```
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
```

#### 输出样例：

```
67
```



##### Algorithm 1:

Time Complexity = $O(n ^ 3)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int maxSumOfMaxPathSum(vector<vector<int>>& nums, int n, int m) {
    int steps = n + m - 2;
    
    // dp[k & 1][i1][i2] represents the maximum sum of maximum path sums
    // from (1, 1) to (i1, j1), (i2, j2)  where k = i1 + j1 - 2 = i2 + j2 - 2
    vector<vector<vector<int>>> dp(2, vector<vector<int>>(n + 1, vector<int>(n + 1, 0)));
    dp[0][1][1] = nums[1][1];
    for (int k = 1; k <= steps; k++) {
        int cur = k & 1;
        for (int i1 = 1, j1 = k - i1 + 2; i1 <= n; i1++, j1--) {
            if (j1 < 1 || j1 > m) {
                continue;
            }
            
            for (int i2 = 1, j2 = k - i2 + 2; i2 <= n; i2++, j2--) {
                if (j2 < 1 || j2 > m) {
                    continue;
                }
                // The first path steps forword to (i1, j1)
                int delta = nums[i1][j1];
                // The second path steps forword to (i2, j2)
                if (i1 != i2) {
                    delta += nums[i2][j2];
                }
                
                // Try to step from <left, left>, <left, up>, 
                // <up, left>, <up, up> respectively
                dp[cur][i1][i2] = max({
                    dp[!cur][i1][i2], 
                    dp[!cur][i1][i2 - 1], 
                    dp[!cur][i1 - 1][i2], 
                    dp[!cur][i1 - 1][i2 - 1]
                }) + delta;
            }
        }
    }
    
    return dp[steps & 1][n][n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    int m = n;
    
    vector<vector<int>> nums(n + 1, vector<int>(m + 1));
    int x, y;
    do {
        cin >> x >> y >> nums[x][y];
    } while (x || y);
    
    cout << maxSumOfMaxPathSum(nums, n, m) << '\n';
    
    return 0;
}
```



#### 算法2(12 ms)：

时间复杂度：O(n ^ 3)。 n 为方阵的边长。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10, M = (N - 1) * 2;

int n, matrix[N + 1][N + 1];

// f[k][i1][i2] 表示从 (0, 0) 分别走 k 步 
// 到达 (i1, j1), (i2, j2) 的最长路径之和
// k = i1 + j1 - 2 = i2 + j2 - 2 
int f[M + 1][N + 1][N + 1];

int get_ans() {
    // 从 (1, 1) 出发分别走 0 步
    // 到达 (1, 1), (1, 1) 的路径长度为 matrix[1][1]
	f[0][1][1] = matrix[1][1];
	
	int m = (n - 1) * 2;
	for (int k = 1; k <= m; k++) {
		for (int i1 = 1, j1 = k + 2 - i1; i1 <= n; i1++, j1--) {
		    if (j1 < 1 || j1 > n) {
		        continue;
		    }
            
			for (int i2 = 1, j2 = k + 2 - i2; i2 <= n; i2++, j2--) {
				if (j2 < 1 || j2 > n) {
					continue;
				}
				
                // 加上 (i1, j1), (i2, j2) 这两格, 注意不能重复
                int t = matrix[i1][j1];
				if (i1 != i2) {
					t += matrix[i2][j2];
				}
				
				// 尝试来自 <上, 上>, <上, 左>, <左, 上>, <左, 左>
				int& curr = f[k][i1][i2];
				curr = max(curr, f[k - 1][i1][i2] + t);
				curr = max(curr, f[k - 1][i1][i2 - 1] + t);
				curr = max(curr, f[k - 1][i1 - 1][i2] + t);
				curr = max(curr, f[k - 1][i1 - 1][i2 - 1] + t);
			}
		}
	}
	
	return f[m][n][n];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	int x, y, val;
	while (cin >> x >> y >> val, x || y || val) {
		matrix[x][y] = val;
	}
	
	cout << get_ans();
	
	return 0;
}
```



#### 算法3(128 ms)：

时间复杂度：O($C_{2n-2}^{n-1} n^2$)。 n 为方阵的边长。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n, matrix[N + 1][N + 1];
int f[N + 1];
int ans; 

int dp() {
	fill_n(f, n + 1, 0);
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			f[j] = max(f[j - 1], f[j]) + matrix[i][j];
		}
	}
	
	return f[n];
}

void dfs(int x, int y, int sum) {
	// 取走当前位置的数 
	sum += matrix[x][y];
	int backup = matrix[x][y];		// 备份一份, 以便状态回溯 
	matrix[x][y] = 0;
	
	// 到达终点, 开始走第二次(dp) 
	if (x == n && y == n) {
		ans = max(ans, sum + dp());
		matrix[x][y] = backup;      // return 前记得回溯状态
		return;
	}
	
	// 尝试向下和向右走, 直到到达终点 
	if (x < n) {
		dfs(x + 1, y, sum);
	}
	if (y < n) {
		dfs(x, y + 1, sum);
	}
	
	// 将取走的数放回(状态回溯)
	matrix[x][y] = backup;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	int x, y, val;
	while (cin >> x >> y >> val, x || y || val) {
		matrix[x][y] = val;
	}
	
	dfs(1, 1, 0);
	
	cout << ans; 
	
	return 0;
}
```





### 5.AcWing0898 数字三角形

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数 *n* ，表示数字三角形的层数。

接下来 *n* 行，每行包含若干整数，其中第 *i* 行表示数字三角形第 *i* 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

1 ≤ *n* ≤ 500 ,

−10000 ≤ 三角形中的整数 ≤ 10000



#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```



##### Algorithm 1:

Time Complexity = $O(n ^ 2)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<vector<int>> nums(n);
    for (int i = 0; i < n; i++) {
        nums[i].resize(n + 1);
        for (int j = 0; j <= i; j++) {
            cin >> nums[i][j];
        }
    }
    
    // dp[j] represents the maximum path sum considering last i rows
    vector<int> dp(n + 1);
    for (int i = n - 1; i >= 0; i--) {
        for (int j = 0; j <= i; j++) {
            dp[j] = max(dp[j], dp[j + 1]) + nums[i][j];
        }
    }
    
    cout << dp[0] << '\n';
    
    return 0;
}
```



#### 算法2-记忆化搜索(95 ms)：

时间复杂度：O(n ^ 2)。n 为层数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 500, INF = 1e9;

int n, matrix[N][N];

int f[N][N];

int get_ans(int i, int j) {
	if (f[i][j] != INF) {
		return f[i][j];
	}
	
	if (i == n - 1) {
		return f[i][j] = matrix[i][j];
	}
	
	return f[i][j] = max(get_ans(i + 1, j), get_ans(i + 1, j + 1)) + matrix[i][j];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j <= i; j++) {
			cin >> matrix[i][j];
			f[i][j] = INF;
		}
	}
	
	cout << get_ans(0, 0);
	
	return 0;
}
```





### 6.LeetCode 0062 Unique Paths

There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.

Given the two integers `m` and `n`, return *the number of possible unique paths that the robot can take to reach the bottom-right corner*.

The test cases are generated so that the answer will be less than or equal to `2 * 109`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
Input: m = 3, n = 7
Output: 28
```

**Example 2:**

```
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
```

 

**Constraints:**

- `1 <= m, n <= 100`



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        // dp[j] 表示 i 轮迭代后，到达坐标 (i, j) 的方案数
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        return dp[n];
    }
};
```





### 7.LeetCode 0063 Unique Paths

You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.

An obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.

Return *the number of possible unique paths that the robot can take to reach the bottom-right corner*.

The testcases are generated so that the answer will be less than or equal to `2 * 109`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

```
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

```
Input: obstacleGrid = [[0,1],[0,0]]
Output: 1
```

 

**Constraints:**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` is `0` or `1`.



##### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        // dp[j] 表示在第 i 轮迭代后，到达位置 (i, j) 的方案数
        vector<int> dp(m + 1, 0);
        dp[1] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[j] = grid[i - 1][j - 1] ? 0 : dp[j - 1] + dp[j];
            }
        }

        return dp[m];
    }
};
```









### 24.AcWing 1212 地宫取宝(medium)

X 国王有一个地宫宝库，是 *n*×*m* 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 *k* 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 *k* 件宝贝。

#### 输入格式

第一行 3 个整数，*n*,*m*,*k*，含义见题目描述。

接下来 *n* 行，每行有 *m* 个整数 *Ci* 用来描述宝库矩阵每个格子的宝贝价值。

#### 输出格式

输出一个整数，表示正好取 *k* 个宝贝的行动方案数。

该数字可能很大，输出它对 10^9 + 7 取模的结果。

#### 数据范围

1 ≤ *n* , *m* ≤ 50 ,

1 ≤ *k* ≤ 12 ,

0 ≤ *Ci* ≤ 12



#### 输入样例1：

```
2 2 2
1 2
2 1
```

#### 输出样例1：

```
2
```

#### 输入样例2：

```
2 3 2
1 2 3
2 1 5
```

#### 输出样例2：

```
14
```



#### 算法思想：







```c++
#include <iostream>
#include <algorithm>

using namespace std;

// 将宝贝的价值从 [0, 12] 映射到 [1, 13] 
const int N = 50, M = 50, K = 12, V = 13, MOD = 1e9 + 7;

// f[i][j][cnt][val] 表示从起点到达 (i, j), 且
// 共取 cnt 件宝贝, 其中最大宝贝价值不超过 val 的方案数
int n, m, k, v, value[N + 1][M + 1], f[N + 1][M + 1][K + 1][V + 1];

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> m >> k;
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> value[i][j];
			v = max(v, ++value[i][j]);
		}
	}
	
	// 应该是关于 cnt 的状态转移或基状态分析有误-03/30/24

	
	f[1][1][0][0] = 1;
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int cnt = 0; cnt <= k; cnt++) {
				for (int val = 0; val <= v; val++) {
					int& curr = f[i][j][cnt][val];
					if (val) {
					    curr = (curr + f[i][j][cnt][val - 1]) % MOD;
					}
					
					// 不取当前位置宝贝 
					curr = (curr + f[i - 1][j][cnt][val]) % MOD;
					curr = (curr + f[i][j - 1][cnt][val]) % MOD;
					
					// 尝试取当前位置的宝贝
					if (val == value[i][j] && cnt) {
					    curr = (curr + f[i - 1][j][cnt - 1][val - 1]) % MOD;
					    curr = (curr + f[i][j - 1][cnt - 1][val - 1]) % MOD;
					    curr = (curr + f[i][j][cnt - 1][val - 1]) % MOD;
					} 
				}
			}
		}
	}
	
	cout << f[n][m][k][v];
	
	return 0; 
} 
```



#### 算法思想：

将宝物的价值从 [0, 12] 映射到 [1, 13] 。

1. 状态表示：`f[i][j][cnt][val]` 表示到达点 `(i, j)` ，且共拿取 `cnt` 件宝物，其中宝物最大价值为 `val` 的方案总数。
2. 初始化基状态：
   - `f[1][1][0][0] = 0` ，表示到达起点且不拿取任何宝物的方案数为 1 ；`f[1][1][1][value[1][1]] = 1` 表示到达起点且拿取起点处的宝物的方案数为 1 。
   - `f[i][0][cnt][val] = f[0][j][cnt][val] = 0` 表示到达地宫上方，左方的方案数为 0 。
3. 状态转移：记 `int& curr = f[i][j][cnt][val]` 。
   - 不拿取当前位置的宝物：`curr += f[i - 1][j][cnt][val] + f[i][j - 1][cnt][val]` 。
   - 尝试拿取当前位置的宝物：`if (val == value[i][j] && cnt) for (int val2 = 0; val2 <= val; val2++) curr += f[i - 1][j][cnt - 1][val2] + f[i][j - 1][cnt - 1][val2] ` 。
4. 结果提取：`f[n][m][k][v]` 即为所求。



#### 算法2(40 ms)：

时间复杂度：O(nmkv)。其中 n, m 为地宫的行数，列数， k 为允许拿取的宝物的数量， v 为宝物的最大价值。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

// 将宝贝的价值从 [0, 12] 映射到 [1, 13] 
const int N = 50, M = 50, K = 12, V = 13, MOD = 1e9 + 7;

// f[i][j][cnt][val] 表示从起点到达 (i, j), 且
// 共取 cnt 件宝贝, 其中最大宝贝价值为 val 的方案数
int n, m, k, v, value[N + 1][M + 1], f[N + 1][M + 1][K + 1][V + 1];

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> m >> k;
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> value[i][j];
			v = max(v, ++value[i][j]);
		}
	}
	
	f[1][1][0][0] = 1;
	f[1][1][1][value[1][1]] = 1;
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int cnt = 0; cnt <= k; cnt++) {
				for (int val = 0; val <= v; val++) {
					long long curr = f[i][j][cnt][val];
					
					// 不取当前位置宝贝 
					curr += f[i - 1][j][cnt][val] + f[i][j - 1][cnt][val];
					
					// 尝试取当前位置的宝贝
					if (val == value[i][j] && cnt) {
						for (int val2 = 0; val2 < val; val2++) {
							curr += f[i - 1][j][cnt - 1][val2] + f[i][j - 1][cnt - 1][val2];
						}
					} 
					
					f[i][j][cnt][val] = curr % MOD;
				}
			}
		}
	}
	
	long long res = 0;
	for (int val = 0; val <= v; val++) {
	    res += f[n][m][k][val];
	}
	res %= MOD;
	
	cout << res;
	
	return 0; 
} 
```









## 6-8 记忆化搜索

### 1.AcWing0901 滑雪

给定一个 *R* 行 *C* 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 *i* 行第 *j* 列的点表示滑雪场的第 *i* 行第 *j* 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。

在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

#### 输入格式

第一行包含两个整数 *R* 和 *C* 。

接下来 *R* 行，每行包含 *C* 个整数，表示完整的二维矩阵。

#### 输出格式

输出一个整数，表示可完成的最长滑雪长度。

#### 数据范围

1 ≤ *R* , *C* ≤ 300 ,

0 ≤ 矩阵中整数 ≤ 10000



#### 输入样例：

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

#### 输出样例：

```
25
```



#### 算法1(53 ms)：

时间复杂度：O(nm)。 n, m 分别为行数，列数。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, -1, 1};

int n, m;
vector<vector<int>> grid;
// dp[i][j] represents the maximum ski length from (i, j)
vector<vector<int>> dp;

int dfs(int px, int py) {
    if (dp[px][py]) {
        return dp[px][py];
    }
    
    int res = 0;
    for (int i = 0; i < 4; i++) {
        int x = px + dx[i], y = py + dy[i];
        if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] >= grid[px][py]) {
            continue;
        }
        res = max(res, dfs(x, y));
    }
    return dp[px][py] = res + 1;
}


int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    
    cin >> n >> m;
    grid.resize(n, vector<int>(m));
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    
    dp.assign(n, vector<int>(m, 0));
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            ans = max(ans, dfs(i, j));
        }
    }
    cout << ans << '\n';
    
    return 0;
}
```























## 6-10 计数DP

### 1.AcWing0900 整数划分

一个正整数 *n* 可以表示成若干个正整数之和，形如：$n=n_1+n_2+...+n_k$ ，其中 $n_1\geq n_2\geq ...\geq n_k\geq 1 ,k\geq 1$ 。

我们将这样的一种表示称为正整数 *n* 的一种划分。

现在给定一个正整数 *n* ，请你求出 *n* 共有多少种不同的划分方法。

#### 输入格式

共一行，包含一个整数 *n* 。

#### 输出格式

共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 10^9+7 取模。

#### 数据范围

1 ≤ *n* ≤ 1000



#### 输入样例:

```
5
```

#### 输出样例：

```
7
```



#### 算法1：

Time Complexity = $O(n^2)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int MOD = 1e9 + 7;

int numOfSchemes(int n) {
    // dp[i] represents the number of schemes to divide n into
    // several positive intergers with sum i
    vector<int> dp(n + 1, 0);
    dp[0] = 1;              // Base case
    // Traverse all items
    for (int i = 1; i <= n; i++) {
        // Traverse backpack capacity in increasing order
        for (int j = i; j <= n; j++) {
            dp[j] = (dp[j] + dp[j - i]) % MOD;
        }
    }
    
    return dp[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    cout << numOfSchemes(n) << '\n';
    
    return 0;
}
```



#### 算法3(16 ms)：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000, MOD = 1e9 + 7;

int numSchemes(int n) {
    int f[N + 1];
    
    fill_n(f, n + 1, 0);
    f[0] = 1;
    
    for (int i = 1; i <= n; ++i) {
        for (int j = i; j <= n; ++j) {
            f[j] = (f[j] + f[j - i]) % MOD;
        }
    }
    
    return f[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    cout << numSchemes(n);
    
    return 0;
}
```





### 2.LeetCode 0343 Interger Break

Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.

Return *the maximum product you can get*.

 

**Example 1:**

```
Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
```

**Example 2:**

```
Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
```

 

**Constraints:**

- `2 <= n <= 58`



##### Algorithm 1:

Time Complexity = $O(n ^ 2)$ .

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```













## 6-11 状态压缩DP

### 1.AcWing0291 蒙德里安的梦想(medium)

求把 *N*×*M* 的棋盘分割成若干个 1×2 的长方形，有多少种方案。

例如当 *N*=2，*M*=4 时，共有 5 种方案。当 *N*=2，*M*=3 时，共有 3 种方案。

如下图所示：

![2411_1.jpg](https://cdn.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg) 

#### 输入格式

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 *N* 和 *M* 。

当输入用例 *N*=0，*M*=0 时，表示输入终止，且该用例无需处理。

#### 输出格式

每个测试用例输出一个结果，每个结果占一行。

#### 数据范围

1 ≤ *N* , *M* ≤ 11



#### 输入样例：

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

#### 输出样例：

```
1
0
1
2
3
5
144
51205
```



#### 算法1(42 ms)：

Time Complexity = $O(t(4^m+n\times 2^{2m}))$ . The time complexity of the program consists of the following parts:

1. **Initialization of `valid[]`:** `O(2^m * m)` .
2. **Building the adjacency list (`head`):** `O(4^m)` .
3. **Dynamic programming part (`numOfSchemes()`):** `O(n * 2^m * 2^m) ` .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

class ALGragh {
private:
    int n, m;                   // Number of rows, columns
    int numVex;					// Number of vertices
    vector<list<int>> head;		// Adjacent list
public:
    ALGragh(int row, int col) {
        n = row;
        m = col;
        if (n < m) {        // Ensure that m is the smaller one
            swap(n, m);
        }
        numVex = 1 << m;    // Number of possible states (2^m)
        
        // Initialize vertex state
        vector<bool> valid(numVex, false);
        for (int mask = 0; mask < numVex; mask++) {
            // Count the number of continuous 0
            int count = 0;
            for (int j = 0; j < m; j++) {
                // 1 means to place a horizontal bar, 0 means not to place the bar.
                if (mask >> j & 1) {
                    if (count & 1) {
                        break;
                    } else {
                        count = 0;
                    }
                } else {
                    count++;
                }
            }
            if (!(count & 1)) {
                valid[mask] = true;
            }
        }
        
        // Initialize edge state (adjacency list)
        head.resize(numVex);
        for (int i = 0; i < numVex; i++) {
            for (int j = 0; j < numVex; j++) {
                // If no overlap and valid transition
                if (!(i & j) && valid[i | j]) {
                    head[i].push_back(j);
                }
            }
        }
    }
    
    long long numOfSchemes() {
        // dp[i & 1][j] represents the number of schemes 
        // from vertex 0 to vertex j with i steps
        vector<vector<long long>> dp(2, vector<long long>(numVex, 0));
        dp[0][0] = 1;   // Base case: 1 way to be at vertex 0 with 0 steps
        for (int s = 1; s <= n; s++) {
            int cur = s & 1;
            for (int i = 0; i < numVex; i++) {
                // After s-1 steps to reach the vertex j, 
                // and then go one step from j to i.
                dp[cur][i] = 0; // Reset the dp value for vertex i at step s
                for (auto j : head[i]) {
                    dp[cur][i] += dp[!cur][j];
                }
            }
        }
        return dp[n & 1][0];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    while (cin >> n >> m, n || m) {
        ALGragh G(n, m);
        cout << G.numOfSchemes() << '\n';
    };
    
    return 0;
}
```





### 2.AcWing0091 最短Hamilton路径(medium)

给定一张 *n* 个点的带权无向图，点从 0∼*n*−1 标号，求起点 0 到终点 *n*−1 的最短 Hamilton 路径。 

Hamilton 路径的定义是从 0 到 *n*−1 不重不漏地经过每个点恰好一次。

#### 输入格式

第一行输入整数 *n* 。

接下来 *n* 行每行 *n* 个整数，其中第 *i* 行第 *j* 个整数表示点 *i* 到 *j* 的距离（记为 *a*[*i*,*j*] ）。

对于任意的 *x* , *y* , *z* ，数据保证 *a*[*x*,*x*]=0，*a*[*x*,*y*]=*a*[*y*,*x*] 并且 *a*[*x*,*y*]+*a*[*y*,*z*]≥*a*[*x*,*z*] 。

#### 输出格式

输出一个整数，表示最短 Hamilton 路径的长度。

#### 数据范围

1 ≤ *n* ≤ 20
0 ≤ *a*[*i*,*j*] ≤ 10^7



#### 输入样例：

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

#### 输出样例：

```
18
```



#### 算法1：

Time Complexity = $O(n^2 \times 2^n)$ .

```c++
#pragma GCC optimize(2)
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

class AMGragh {
private:
    int n;
    vector<vector<int>> weight;
public:
    AMGragh(int numVex) {
        n = numVex;
        weight.resize(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cin >> weight[i][j];
            }
        }
    }
    
    // Function to calculate the minimum cost of visiting all vertices 
    // exactly once from vertex 0 to vertex n-1
    int hamilton() {
        int m = 1 << n;
        vector<vector<int>> dp(m, vector<int>(n, INF));
        dp[1][0] = 0;       // Base case: starting from vertex 0, cost is 0
        // Loop through all possible subsets of vertices (represented by 'mask')
        for (int mask = 0; mask < m; mask++) {
            vector<int> vex;    // List of vertices included in this subset (mask)
            // Populate the 'vex' vector with vertices included in the current subset (mask)
            for (int i = 0; i < n; i++) {
                if (mask >> i & 1) {
                    vex.push_back(i);
                }
            }
            // For each pair of vertices in 'vex', 
            // update the DP table with the minimum path cost
            for (int i = 0; i < vex.size(); i++) {
                int u = vex[i];
                for (int j = 0; j < vex.size(); j++) {
                    int v = vex[j];
                    dp[mask][u] = min(dp[mask][u], dp[mask ^ (1 << u)][v] + weight[v][u]);
                }
            }
        }
        
        return dp[m - 1][n - 1];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    AMGragh G(n);
    cout << G.hamilton() << '\n';
    
    return 0;
}
```





### 37.AcWing 0164 小国王

在 *n*×*n* 的棋盘上放 *k* 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。

#### 输入格式

共一行，包含两个整数 *n* 和 *k* 。

#### 输出格式

共一行，表示方案总数，若不能够放置则输出 0 。

#### 数据范围

1 ≤ *n* ≤ 10 ,

0 ≤ *k* ≤ *n*^2



#### 输入样例：

```
3 2
```

#### 输出样例：

```
16
```



bug:

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

class ALGragh {
private:
    int n, m;                   // Number of rows, columns
    int numVex;                 // Number of possible vetices(row states)
    vector<int> values;         // Vertex value
    vector<list<int>> heads;	// Adjacent list
    
public:
    int numOfBits1(int x) {
        int cnt = 0;
        while (x) {
            cnt++;
            x -= x & -x;
        }
        return cnt;
    }

    ALGragh(int len) {
        m = n = len;
        numVex = 0;
        numVex = 1 << m;
        values.resize(numVex, -INF);
        heads.resize(numVex);
        
        // Initialize vertex state
        for (int mask = 0; mask < numVex; mask++) {
            for (int j = 0; j < m; j++) {
                if (!(mask & mask >> 1)) {  // Non-adjacent
                    values[mask] = numOfBits1(mask);
                }
            }
        }
        
        // Initialize edge state (adjacency list)
        heads.resize(numVex);
        for (int i = 0; i < numVex; i++) {
            if (values[i] == -INF) {
                continue;
            }
            for (int j = 0; j < numVex; j++) {
                if (values[j] == -INF) {
                    continue;
                }
                if (!(i & j) && !(i & j >> 1) && !(i >> 1 & j)) {   // Non-adjacent
                    heads[i].push_back(j);
                }
            }
        }
    }
    
    long long numOfSchemes(int l) {
        // dp[i & 1][j][u] represents the number of schemes 
        // with i steps and j kings from vertex 0 to vertex u
        vector<vector<vector<long long>>> dp(2, 
                vector<vector<long long>>(l + 1, vector<long long>(numVex, 0)));
        dp[0][0][0] = 1;   // Base case: 1 way to be at vertex 0 with 0 steps and 0 kings
        for (int step = 1; step <= n + 1; step++) { // Traverse all rows
            int cur = step & 1;
            for (int j = 0; j <= l; j++) {          // Traverse all king numbers
                for (int u = 0; u < numVex; u++) {  // Travese row states at current row
                    dp[cur][j][u] = 0;  // Reset the dp value for vertex u at step s and king j
                    if (j < values[u]) {
                        continue;
                    }
                    
                    // After s-1 steps to reach the vertex v, 
                    // and then go one step from v to u.
                    for (auto v : heads[u]) {       // Travese all in-arcs
                        dp[cur][j][u] += dp[!cur][j - values[u]][v];
                    }
                }
            }
        }
        return dp[n & 1][l][0];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, kings;
    cin >> n >> kings;
    
    ALGragh G(n);
    cout << G.numOfSchemes(kings) << '\n';

    return 0;
}
```



#### 算法1(65 ms)：

时间复杂度：O($nm2^{2n}$)。n, m 分别为棋盘的边长，小国王的数量。其中预处理的时间开销为 O($2^{2n}$)。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 10;
const int K = N * N, ST = 1 << N;

int n, m, states;

vector<int> vertex, cnt;
vector<int> edge[ST];

long long f[2][K + 1][ST];

int count(int x) {
    int res = 0;
    while (x) {
        res++;
        x -= x & -x;
    }
    
    return res;
}

void preprocess() {
    // 预处理所有的合法顶点
    for (int st = 0; st < states; st++) {
        if (!(st & st >> 1)) {
            vertex.push_back(st);
            cnt.push_back(count(st));
        }
    }
    
    // 预处理所有的边
    for (int i = 0; i < vertex.size(); i++) {
        int a = vertex[i];
        for (int j = 0; j < vertex.size(); j++) {
            int b = vertex[j];
            if (!(a & b || a >> 1 & b || a & b >> 1)) {
                edge[i].push_back(j);
            }
        }
    }
}

long long get_ans() {
    f[0][0][0] = 1;
    
    // 遍历所有行
    for (int i = 1; i <= n + 1; i++) {
        int ci = i & 1, pi = !ci;
        // 遍历国王数量
        for (int j = 0; j <= m; j++) {
            // 遍历第 i 行所有的合法状态
            for (int u = 0; u < vertex.size(); u++) {
                f[ci][j][u] = 0;
                if (j < cnt[u]) {
                    continue;
                }
                
                // 遍历 u 的所有入边
                for (auto v : edge[u]) {
                    f[ci][j][u] += f[pi][j - cnt[u]][v];
                }
            }
        }
    }
    
    return f[(n + 1) & 1][m][0];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
    states = 1 << n;
    
    preprocess();
    
    cout << get_ans() << '\n';
    
    return 0;
}
```





### 38.AcWing 0327 玉米田

农夫约翰的土地由 *M*×*N* 个小方格组成，现在他要在土地里种植玉米。

非常遗憾，部分土地是不育的，无法种植。

而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。

现在给定土地的大小，请你求出共有多少种种植方法。

土地上什么都不种也算一种方法。

#### 输入格式

第 1 行包含两个整数 *M* 和 *N* 。

第 2..*M*+1 行：每行包含 *N* 个整数 0 或 1，用来描述整个土地的状况，1 表示该块土地肥沃，0 表示该块土地不育。

#### 输出格式

输出总种植方法对 10^8 取模后的值。

#### 数据范围

1 ≤ *M* , *N* ≤ 12



#### 输入样例：

```
2 3
1 1 1
0 1 0
```

#### 输出样例：

```
9
```



#### 算法1(21 ms)：

时间复杂度：O($n2^{2m}$)。n, m 分别为行数，列数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 12, M = 12, MOD = 1e8;
const int ST = 1 << M;

int n, m, states;

// 维护每一行的土地状态
int barren[N + 2];

vector<int> vertex;
vector<int> edge[ST];

// f[i][j] 表示考虑前 i 行, 且最后一行状态为 j 的
// 所有方案中的方案总数
int f[2][ST];

void preprocess() {
    // 预处理所有合法的行状态
    for (int st = 0; st < states; st++) {
        if (!(st & st >> 1)) {
            vertex.push_back(st);
        }
    }
    
    // 预处理所有的边
    for (int i = 0; i < vertex.size(); i++) {
        for (int j = 0; j < vertex.size(); j++) {
            if (!(vertex[i] & vertex[j])) {
                edge[i].push_back(j);
            }
        }
    }
}

int get_ans() {
    f[0][0] = 1;
    
    for (int i = 1; i <= n + 1; i++) {
        int ci = i & 1, pi = !ci;
        for (int j = 0; j < vertex.size(); j++) {
            f[ci][j] = 0;
            if (vertex[j] & barren[i]) {
                continue;		// 不能在贫瘠的土地种植
            }
            for (auto k : edge[j]) {
                f[ci][j] += f[pi][k];
            }
            f[ci][j] %= MOD;
        }
    }
    
    return f[(n + 1) & 1][0];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
    states = 1 << m;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < m; j++) {
            int x;
            cin >> x;
            barren[i] += !x << j;        // 1 表示贫瘠, 0 表示肥沃
        }
    }
    
    preprocess();
    
    cout << get_ans() << '\n';
    
    return 0;
}
```





### 39.AcWing 0292 炮兵阵地(medium)

司令部的将军们打算在 *N*×*M* 的网格地图上部署他们的炮兵部队。

一个 *N*×*M* 的地图由 *N* 行 *M* 列组成，地图的每一格可能是山地（用 `H` 表示），也可能是平原（用 `P` 表示），如下图。

在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示： 

![1185_1.jpg](https://cdn.acwing.com/media/article/image/2019/02/16/19_d512cdba31-1185_1.jpg) 

如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。

图上其它白色网格均攻击不到。

从图上可见炮兵的攻击范围不受地形的影响。 

现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。

#### 输入格式

第一行包含两个由空格分割开的正整数，分别表示 *N* 和 *M* ； 

接下来的 *N* 行，每一行含有连续的 *M* 个字符(`P` 或者 `H`)，中间没有空格。按顺序表示地图中每一行的数据。

#### 输出格式

仅一行，包含一个整数 *K* ，表示最多能摆放的炮兵部队的数量。

#### 数据范围

*N* ≤ 100 ,

*M* ≤ 10



#### 输入样例：

```
5 4
PHPP
PPHH
PPPP
PHPP
PHHP
```

#### 输出样例：

```
6
```



#### 算法1(383 ms)：

时间复杂度：O($n2^{3m}$)。n, m 分别为网格地图的行数，列数。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 100, M = 10;
const int ST = 1 << M;

int n, m, st;
int hilly[N + 3];

vector<int> vertex, cnt;
vector<int> edge[ST];

// dp[i][j][k] 表示考虑前 i 行, 且最后一行与倒数第二行状态
// 分别为 j, k 的所有合法方案中的最大炮兵部队的数量
int dp[2][ST][ST];

int count(int x) {
    int res = 0;
    while (x) {
        res++;
        x -= x & -x;
    }
    return res;
}

void preprocess() {
    // 预处理所有的合法行状态
    for (int i = 0; i < st; i++) {
        if (!(i & i >> 1 || i & i >> 2)) {
            vertex.push_back(i);
            cnt.push_back(count(i));
        }
    }
    
    // 预处理所有的边
    for (int i = 0; i < vertex.size(); i++) {
        for (int j = 0; j < vertex.size(); j++) {
            if (!(vertex[i] & vertex[j])) {
                edge[i].push_back(j);
            }
        }
    }
}

int get_ans() {
    // 遍历所有行
    for (int i = 1; i <= n + 2; i++) {
        int ci = i & 1, pi = !ci;
        // 遍历最后一行状态
        for (int j = 0; j < vertex.size(); j++) {
            // 遍历倒数第二行状态
            for (int k = 0; k < vertex.size(); k++) {
                dp[ci][j][k] = 0;
                if (vertex[j] & hilly[i] || vertex[j] & vertex[k]) {
                    continue;   // 当前行不能部署在山丘上, 且不能被上一行误伤
                }
                for (auto l : edge[k]) {    // 倒数第 3 行为 l
                    if (!(vertex[l] & vertex[j])) {        // 倒数第 3 行不能误伤当前行
                        dp[ci][j][k] = max(dp[ci][j][k], dp[pi][k][l] + cnt[j]);
                    }
                }
            }
        }
    }
    
    return dp[(n + 2) & 1][0][0];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
    st = 1 << m;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < m; j++) {
            char x;
            cin >> x;
            hilly[i] += (x == 'H') << j;
        }
    }
    
    preprocess();
    
    cout << get_ans() << '\n';
    
    return 0;
}
```







## 6-12 等和子集

### 1.LeetCode 0416 Partition Equal Subset Sum

Given an integer array `nums`, return `true` *if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or* `false` *otherwise*.

 

**Example 1:**

```
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

**Example 2:**

```
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
```

 

**Constraints:**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`



##### Algorithm 1:

Time Complexity = $O(nm)$ , where m represents the total sum of nums.

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0, n = nums.size();
        for (auto num : nums) {
            sum += num;
        }

        if (sum & 1) {
            return false;
        }

        int m = sum / 2;
        // dp[j] 表示在前 i 个数字中，子集和不超过 j 的方案中的最大的子集和
        vector<int> dp(m + 1, 0);
        for (auto num : nums) {
            for (int j = m; j >= num; j--) {
                dp[j] = max(dp[j], dp[j - num] + num);
            }
        }
        return dp[m] == m;
    }
};
```





### 2.LeetCode 1049 Last Stone Weight II

You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.

We are playing a game with the stones. On each turn, we choose any  two stones and smash them together. Suppose the stones have weights `x` and `y` with `x <= y`. The result of this smash is:

- If `x == y`, both stones are destroyed, and
- If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.

At the end of the game, there is **at most one** stone left.

Return *the smallest possible weight of the left stone*. If there are no stones left, return `0`.

 

**Example 1:**

```
Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation:
We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.
```

**Example 2:**

```
Input: stones = [31,26,33,21,40]
Output: 5
```

 

**Constraints:**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`



##### Algorithm 1:

Time Complexity = $O(nm)$ , where m represents the total sum of nums.

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& nums) {
        int sum = 0, n = nums.size();
        for (auto num : nums) {
            sum += num;
        }

        int m = sum / 2;
        // dp[j] 表示在前 i 个数字中，子集和不超过 j 的方案中的最大的子集和
        vector<int> dp(m + 1, 0);
        for (auto num : nums) {
            for (int j = m; j >= num; j--) {
                dp[j] = max(dp[j], dp[j - num] + num);
            }
        }
        return sum - dp[m] * 2;
    }
};
```













