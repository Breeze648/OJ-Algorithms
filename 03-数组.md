# 一、数组

## 1-1 排序与快选

### 1.AcWing0785 快速排序

给定你一个长度为 *n* 的整数数列。

请你使用快速排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

#### 输入格式

输入共两行，第一行包含整数 *n* 。

第二行包含 *n* 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。

#### 输出格式

输出共一行，包含 *n* 个整数，表示排好序的数列。

#### 数据范围

1 ≤ *n* ≤ 100000



#### 输入样例：

```
5
3 1 2 4 5
```

#### 输出样例：

```
1 2 3 4 5
```



#### Algorithm 1:

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

void quickSort(vector<int>& nums, int low, int high) {
    if (low >= high) {
        return;
    }
    
    int pivot = nums[(low + high) / 2];
    int i = low - 1, j = high + 1;
    while (i < j) {
        while (nums[++i] < pivot);
        while (nums[--j] > pivot);
        if (i < j) {
            swap(nums[i], nums[j]);
        }
    }
    
    quickSort(nums, low, j);
    quickSort(nums, j + 1, high);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    quickSort(nums, 0, nums.size() - 1);
    // sort(nums.begin(), nums.end());
    
    for (int i = 0; i < n; i++) {
        cout << nums[i] << ' ';
    }
    
    return 0;
}
```





### 2.AcWing0786 快速选择

给定一个长度为 *n* 的整数数列，以及一个整数 *k*，请用快速选择算法求出数列从小到大排序后的第 *k* 个数。

#### 输入格式

第一行包含两个整数 *n* 和 *k* 。

第二行包含 *n* 个整数（所有整数均在 1∼10^9 范围内），表示整数数列。

#### 输出格式

输出一个整数，表示数列的第 *k* 小数。

#### 数据范围

1 ≤ *n* ≤ 100000 ,

1 ≤ *k* ≤ *n*



#### 输入样例：

```
5 3
2 4 1 5 3
```

#### 输出样例：

```
3
```



#### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int quickSelect(vector<int>& nums, int low, int high, int k) {
    while (true) {
        swap(nums[(low + high) / 2], nums[high]);
        int i = low - 1, j = high;
        while (i < j) {
            while (nums[++i] < nums[high]);
            while (nums[--j] > nums[high]);
            if (i < j) {
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i], nums[high]);
        
        if (i == k - 1) {
            return nums[i];
        } else if (i < k - 1) {
            low = i + 1;
        } else {
            high = i - 1;
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, k;
    cin >> n >> k;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << quickSelect(nums, 0, nums.size() - 1, k) << '\n';
    // nth_element(nums.begin(), nums.begin() + k - 1, nums.end());
    // cout << nums[k - 1] << '\n';
    
    return 0;
}
```





### 3.AcWing0787 归并排序

给定你一个长度为 *n* 的整数数列。请你使用归并排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。

#### 输入格式

输入共两行，第一行包含整数 *n* 。

第二行包含 *n* 个整数（所有整数均在 1∼10^9 范围内），表示整个数列。

#### 输出格式

输出共一行，包含 *n* 个整数，表示排好序的数列。

#### 数据范围

1≤*n*≤100000

#### 输入样例：

```
5
3 1 2 4 5
```

#### 输出样例：

```
1 2 3 4 5
```



#### Algorithm 1：

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

void merge(vector<vector<int>>& temp, int cur, int low, int mid, int high) {
    int i = low, j = mid + 1, k = low;
    auto &curNums = temp[cur], &preNums = temp[!cur];
    while (i <= mid && j <= high) {
        curNums[k++] = preNums[i] <= preNums[j] ? preNums[i++] : preNums[j++];
    }
    
    while (i <= mid) {
        curNums[k++] = preNums[i++];
    }
    while (j <= high) {
        curNums[k++] = preNums[j++];
    }
}

void mergeSort(vector<vector<int>>& temp, int cur, int low, int high) {
    if (low >= high) {
        return;
    }
    
    int mid = (low + high) / 2;
    mergeSort(temp, !cur, low, mid);
    mergeSort(temp, !cur, mid + 1, high);
    merge(temp, cur, low, mid, high);
}

void mergeSort(vector<int>& nums) {
    vector<vector<int>> temp(2, nums);
    
    mergeSort(temp, 0, 0, nums.size() - 1);
    
    nums = temp[0];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    mergeSort(nums);
    
    for (int i = 0; i < n; i++) {
        cout << nums[i] << ' ';
    }
    
    return 0;
}
```



#### Algorithm 2：

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>

using namespace std;

const int N = 1e5;

void merge(int arr[], int low, int mid, int high) {
    int temp[N];
    for (int i = low; i <= high; ++i) {
        temp[i] = arr[i];
    }
    
    int i = low, j = mid + 1, k = low;
    while (i <= mid && j <= high) {
        arr[k++] = temp[i] <= temp[j] ? temp[i++] : temp [j++];
    }
    
    while (i <= mid) {
        arr[k++] = temp[i++];
    }
    while (j <= high) {
        arr[k++] = temp[j++];
    }
}

void mergeSort(int arr[], int low, int high) {
    if (low >= high) {
        return;
    }
    
    int mid = (low + high) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, mid, high);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int arr[N], n;
    cin >> n;
    
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    
    mergeSort(arr, 0, n - 1);
    
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << " ";
    }
    
    return 0;
}
```





### 4.AcWing0788 逆序对的数量

给定一个长度为 *n* 的整数数列，请你计算数列中的逆序对的数量。逆序对的定义如下：对于数列的第 *i* 个和第 *j* 个元素，如果满足 *i*<*j* 且 *a*[*i*]>*a*[*j*]，则其为一个逆序对；否则不是。

#### 输入格式

第一行包含整数 *n* ，表示数列的长度。第二行包含 *n* 个整数，表示整个数列。

#### 输出格式

输出一个整数，表示逆序对的个数。

#### 数据范围

1≤*n*≤100000， 数列中的元素的取值范围 [1,10^9]。

#### 输入样例：

```
6
2 3 4 5 6 1
```

#### 输出样例：

```
5
```



#### Algorithm 1(Fenwick Tree)：

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

using PII = pair<int, int>;

class FenwickTree {
private:
    vector<int> nodes; 	// Nodes that store the tree array
public:
    // Constructor: Initializes the segment tree with a given array length
    FenwickTree(int n) {
        nodes.resize(n + 1, 0);
    }
    
    // Single point update : increase the value of position u by val
    void update(int u, int val) {
        while (u < nodes.size()) {
            nodes[u] += val;
            u += u & -u;
        }
    }
    
    // Interval query : Return the prefix sum from position 1 to u.
    int query(int u) {
        int res = 0;
        while (u) {
            res += nodes[u];
            u -= u & -u;
        }
        return res;
    }
    
    long long numOfReverseOrderPairs(vector<PII>& nums) {
        // Arrange nums in descending order
        sort(nums.begin(), nums.end(), greater<PII>());
        // Count the number of larger numbers on the left side of each number
        long long ans = 0;
        for (auto [val, index] : nums) {
            index++;
            ans += query(index);
            update(index, 1);
        }
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    // <value, index>
    vector<PII> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i].first;
        nums[i].second = i;
    }
    
    FenwickTree T(n);
    cout << T.numOfReverseOrderPairs(nums) << '\n';
    
    return 0;
}
```



#### Algorithm 2(Merge Sort)：

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>

using namespace std;

const int N = 1e5;

long long cnt;

void mergeAndCount(int arr[], int low, int mid, int high) {
    int temp[N];
    for (int i = low; i <= high; ++i) {
        temp[i] = arr[i];
    }
    
    int i = low, j = mid + 1, k = low;
    while (i <= mid && j <= high) {
        if (temp[i] <= temp[j]) {
            arr[k++] = temp[i++];
        }
        else {
            arr[k++] = temp[j++];
            cnt += mid - i + 1;
        }
    }
    
    while (i <= mid) {
        arr[k++] = temp[i++];
    }
    while (j <= high) {
        arr[k++] = temp[j++];
    }
}

void mergeSortAndCount(int arr[], int low, int high) {
    if (low >= high) {
        return;
    }
    
    int mid = (low + high) / 2;
    mergeSortAndCount(arr, low, mid);
    mergeSortAndCount(arr, mid + 1, high);
    mergeAndCount(arr, low, mid, high);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int arr[N], n;
    
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    
    mergeSortAndCount(arr, 0, n - 1);
    
    cout << cnt;
    
    return 0;
}
```







## 1-2 二分查找

### 1.AcWing0789 数的范围

给定一个按照升序排列的长度为 *n* 的整数数组，以及 *q* 个查询。对于每个查询，返回一个元素 *k* 的起始位置和终止位置（位置从 0 开始计数）。如果数组中不存在该元素，则返回 `-1 -1`。

#### 输入格式

第一行包含整数 *n* 和 *q* ，表示数组长度和询问个数。第二行包含 *n* 个整数（均在 1∼10000 范围内），表示完整数组。接下来 *q* 行，每行包含一个整数 *k*，表示一个询问元素。

#### 输出格式

共 *q* 行，每行包含两个整数，表示所求元素的起始位置和终止位置。如果数组中不存在该元素，则返回 `-1 -1`。

#### 数据范围

1 ≤ *n* ≤ 100000

1 ≤ *q* ≤ 10000

1 ≤ *k* ≤ 10000



#### 输入样例：

```
6 3
1 2 2 3 3 4
3
4
5
```

#### 输出样例：

```
3 4
5 5
-1 -1
```



#### Algorithm 1:

Time Complexity = $O(m \log n)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int firstGeq(vector<int>& nums, int x) {
    if (nums.back() < x) {
        return nums.size();
    }
    
    int low = 0, high = nums.size() - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        if (nums[mid] >= x) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return low;
}

int firstGreater(vector<int>& nums, int x) {
    if (nums.back() <= x) {
        return nums.size();
    }
    
    int low = 0, high = nums.size() - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        if (nums[mid] > x) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    return low;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    while (m--) {
        int x;
        cin >> x;
        
        int left = firstGeq(nums, x), right = firstGreater(nums, x);
        if (left == n || nums[left] != x) {
            cout << "-1 -1" << '\n';
        } else {
            cout << left << ' ' << right - 1 << '\n';
        }
        
        // auto [left, right] = equal_range(nums.begin(), nums.end(), x);
        // if (left == nums.end() || *left != x) {
        //     cout << "-1 -1" << '\n';
        // } else {
        //     cout << left - nums.begin() << ' ' << right - 1 - nums.begin() << '\n';
        // }
    }
    
    return 0;
}
```





### 2.AcWing0790 数的三次方根

给定一个浮点数 *n* ，求它的三次方根。

#### 输入格式

共一行，包含一个浮点数 *n* 。

#### 输出格式

共一行，包含一个浮点数，表示问题的解。注意，结果保留 6 位小数。

#### 数据范围

−10000 ≤ *n* ≤ 10000

#### 输入样例：

```
1000.00
```

#### 输出样例：

```
10.000000
```



#### Algorithm 1：

Time Complexity = $O(\log n)$ .

```cpp
#include <iostream>

using namespace std;

const double N = 1e4, P = 1e-8;

double cubicRoot(double n) {
	double low = -N, high = N;
	while (high - low > P) {
		double mid = (low + high) / 2;
		if (mid * mid * mid > n) {
			high = mid;
		}
		else {
			low = mid;
		}
	}
	
	return low;
}

int main() {
	double n;
	scanf("%lf", &n);
	
	printf("%.6lf", cubicRoot(n));
	
	return 0;
}
```





### 3.AcWing0802 离散化

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。

现在，我们首先进行 *n* 次操作，每次操作将某一位置 *x* 上的数加 *c*。

接下来，进行 *m* 次询问，每个询问包含两个整数 *l* 和 *r*，你需要求出在区间 [ *l* , *r* ] 之间的所有数的和。

#### 输入格式

第一行包含两个整数 *n* 和 *m*。

接下来 *n* 行，每行包含两个整数 *x* 和 *c*。

再接下来 *m* 行，每行包含两个整数 *l* 和 *r*。

#### 输出格式

共 *m* 行，每行输出一个询问中所求的区间内数字和。

#### 数据范围

−10\^9 ≤ *x* ≤ 10\^9 ,

1 ≤ *n* , *m* ≤ 10^5 ,

−10\^9 ≤ *l* ≤ *r* ≤ 10\^9 ,

−10000 ≤ *c* ≤ 10000



#### 输入样例：

```
3 3
1 2
3 6
7 5
1 3
4 6
7 8
```

#### 输出样例：

```
8
0
5
```



#### Algorithm 1：

Time Complexity = $O((n + m)\log n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9 + 1;

struct Num {
    int pos;
    int value;
    
    bool operator<(const Num& other) const {
        return pos < other.pos;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<Num> nums(n + 1);
    nums[0] = {-INF, 0};    // Sentinel value for easier range sum calculation
    for (int i = 1; i <= n; i++) {
        cin >> nums[i].pos >> nums[i].value;
    }
    
    // Sort the vector of values based on positions
    sort(nums.begin(), nums.end());
    // Compute prefix sums
    for (int i = 1; i <= n; i++) {
        nums[i].value += nums[i - 1].value;
    }
    
    while (m--) {
        int left, right;
        cin >> left >> right;
        // Find the sum from the beginning up to left-1 (exclusive)
        auto leftSum = (lower_bound(nums.begin(), nums.end(), Num{left, 0}) - 1)->value;
        // Find the sum from the beginning up to right (inclusive)
        auto rightSum = (upper_bound(nums.begin(), nums.end(), Num{right, 0}) - 1)->value;
        cout << rightSum - leftSum << '\n';
    }
    
    return 0;
}
```





#### 算法2(587 ms)：

时间复杂度：O(n log n + m log m)。 n, m 分别为给定的操作次数，询问次数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5, INF = 1e9 + 1;

int n;

// <idx, psum>
pair<int, int> psum[N + 2];

int findGeq(int idx) {
    int low = 0, high = n - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        if (psum[mid].first >= idx) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    
    return low;
}

int findGreater(int idx) {
    int low = 0, high = n - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        if (psum[mid].first > idx) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    
    return low;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    psum[0] = {-INF, 0};
    ++n;
    for (int i = 1; i < n; ++i) {
        cin >> psum[i].first >> psum[i].second;
    }
    psum[n++] = {INF, 0};
    
    sort(psum, psum + n);
    
    int j = 0;
    for (int i = 1; i < n; ++i) {
        if (psum[i].first == psum[j].first) {
            psum[j].second += psum[i].second;
        }
        else {
            psum[++j] = psum[i];
            psum[j].second += psum[j - 1].second;
        }
    }
    n = j + 1;
    
    while (m--) {
        int left, right;
        cin >> left >> right;
        cout << psum[findGreater(right) - 1].second - psum[findGeq(left) - 1].second << endl;
    }
    
    return 0;
}
```





### 4.AcWing 1227 分巧克力

儿童节那天有 *K* 位小朋友到小明家做客。

小明拿出了珍藏的巧克力招待小朋友们。

小明一共有 *N* 块巧克力，其中第 *i* 块是 *Hi*×*Wi* 的方格组成的长方形。

为了公平起见，小明需要从这 *N* 块巧克力中切出 *K* 块巧克力分给小朋友们。

切出的巧克力需要满足：

1. 形状是正方形，边长是整数  
2. 大小相同  

例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？

#### 输入格式

第一行包含两个整数 *N* 和 *K* 。  

以下 *N* 行每行包含两个整数 *Hi* 和 *Wi* 。

输入保证每位小朋友至少能获得一块 1×1 的巧克力。

#### 输出格式

输出切出的正方形巧克力最大可能的边长。

#### 数据范围

1 ≤ *N* , *K* ≤ 10^5 ,

1 ≤ *Hi* , *Wi* ≤ 10^5



#### 输入样例：

```
2 10
6 5
5 6
```

#### 输出样例：

```
2
```



#### 算法1-二分法(46 ms)：

时间复杂度：O(n log M)。 n, M 分别为巧克力的块数与最大边长。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int M = 1e5;

struct Item {
    int h, w;
};

bool check(vector<Item>& items, int k, int len) {
    int cnt = 0;
    for (auto [x, y] : items) {
        cnt += (x / len) * (y / len);
    }
    return cnt >= k;
}

int maxLen(vector<Item>& items, int k) {
    int low = 1, high = M;
    while (low < high) {
        int mid = (low + high + 1) / 2;
        if (check(items, k, mid)) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    return low;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, k;
    cin >> n >> k;
    
    vector<Item> items(n);
    for (auto& item : items) {
        cin >> item.h >> item.w;
    }
    
    cout << maxLen(items, k) << '\n';
    
    return 0;
}
```









### y14.AcWing 1221 四平方和

四平方和定理，又称为拉格朗日定理：

每个正整数都可以表示为至多 4 个正整数的平方和。

如果把 0 包括进去，就正好可以表示为 4 个数的平方和。

比如：

$5=0^2+0^2+1^2+2^2$ 

$7=1^2+1^2+1^2+2^2$ 

对于一个给定的正整数，可能存在多种平方和的表示法。

要求你对 4 个数排序：

0 ≤ *a* ≤ *b* ≤ *c* ≤ *d* 

并对所有的可能表示法按 *a*,*b*,*c*,*d* 为联合主键升序排列，最后输出第一个表示法。

#### 输入格式

输入一个正整数 *N* 。

#### 输出格式

输出4个非负整数，按从小到大排序，中间用空格分开。

#### 数据范围

0 < *N* < 5∗10^6



#### 输入样例：

```
5
```

#### 输出样例：

```
0 0 1 2
```



#### 算法1-哈希表(331 ms)：

时间复杂度：O($m^2$)。其中， $m = \sqrt{n}$ ， n 为给定的正整数。

```c++
#include <iostream>
#include <cmath>

using namespace std;

const int N = 5e6;

int n, m;

// <c, d>, cd[c^2 + d^2] = {c, d}
pair<int, int> cd[N];

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	m = sqrt(n);
	
	for (int c = 0; c <= m; c++) {
		for (int d = c; d <= m; d++) {
			int sum = c * c + d * d;
			if (sum >= N) {
			    break;
			}
			if (!cd[sum].second) {
				cd[sum] = {c, d};
			}
		}
	}
	
	for (int a = 0; a <= m; a++) {
		for (int b = a; b <= m; b++) {
			int rem = n - a * a - b * b;
			if (rem < b * b * 2) {
				break;
			}
			if (cd[rem].second) {
				cout << a << ' ' << b << ' ' << cd[rem].first << ' ' << cd[rem].second;
				return 0;
			}
		}
	}
	
	return 0;
}
```





#### 算法2-暴力算法(847 ms)：

时间复杂度：O($m ^3$)。 其中， $m = \sqrt{n}$ ， n 为给定的正整数。

```c++
#include <iostream>
#include <cmath>

using namespace std;

const int N = 5e6;

int n, root[N];

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	
	int m = sqrt(n);
	for (int d = 0; d <= m; d++) {
		root[d * d] = d;
	}
	
	for (int a = 0; a <= m; a++) {
		for (int b = a; b <= m; b++) {
			for (int c = b; c <= m; c++) {
				int rem = n - a * a - b * b - c * c;
				if (rem < c * c) {
					break;
				}
				if (root[rem]) {
					cout << a << ' ' << b << ' ' << c << ' ' << root[rem];
					return 0;
				}
			}
		}
	}
	
	return 0;
}
```



#### 算法3-二分法(1386 ms)：

时间复杂度：O(n log n)。

```c++
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 5e6;

int n, m;

struct SquareSum {
    int sum, x, y;
    
    bool operator<(const SquareSum& other) const {
        if (sum != other.sum) {
            return sum < other.sum;
        }
        else if (x != other.x) {
            return x < other.x;
        }
        else {
            return y <= other.y;
        }
    }
} ssum[N];

int idx;

void get_ssum() {
    for (int x = 0; x <= m; ++x) {
        for (int y = x; y <= m; ++y) {
            int sum = x * x + y * y;
            if (sum < n / 2) {
                continue;
            }
            if (sum > n) {
                break;
            }
            ssum[idx++] = {sum, x, y};
        }
    }
    
    sort(ssum, ssum + idx);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n;
    m = sqrt(n);
    
    get_ssum();
    
    for (int a = 0; a <= m; ++a) {
        for (int b = a; b <= m; ++b) {
            int rem = n - a * a - b * b;
            if (rem < b * b * 2) {
                break;
            }
            SquareSum temp = {rem, 0, 0};
            auto ret = lower_bound(ssum, ssum + idx, temp);
            if (ret->sum == rem) {
                cout << a << " " << b << " " << ret->x << " " << ret->y;
                return 0;
            }
        }
    }
    
    return 0;
}
```



























## 1-3 前缀和与差分

### 1.AcWing0795 前缀子序列和

输入一个长度为 *n* 的整数序列。接下来再输入 *m* 个询问，每个询问输入一对 *l* ，*r* 。对于每个询问，输出原序列中从第 *l* 个数到第 *r* 个数的和。

#### 输入格式

第一行包含两个整数 *n* 和 *m*。第二行包含 *n* 个整数，表示整数数列。接下来 *m* 行，每行包含两个整数 *l* 和 *r*，表示一个询问的区间范围。

#### 输出格式

共 *m* 行，每行输出一个询问的结果。

#### 数据范围

1 ≤ *l* ≤ *r* ≤ *n* ，

1 ≤ *n* , *m* ≤ 100000 ，

−1000 ≤ 数列中元素的值 ≤ 1000



#### 输入样例：

```
5 3
2 1 3 6 4
1 2
1 3
2 4
```

#### 输出样例：

```
3
6
10
```



#### 前缀和：

设序列 A =  $a_{1..n}(n\ge 1)$ ，我们称 B =  $b_{1..n}$ 为 A 的**前缀子序列和**（prefix subsequence sum）序列，若 B 满足：
$$
b_x=\sum_{i=1}^{x} a_i,\forall x=1,2,...,n
$$

**[定理]** （前缀子序列和定理） 设序列 B = b[0..n] 为序列 A = a[1..n] 的最大前缀子序列和序列，则 A 中从第`l`个数到第`j`

个数对应子序列 a[l..r] 的和为：
$$
\sum_{i=l}^{r} a[i]=b[r]-b[l-1]
$$
其中，$1 \leq l \leq r \leq n$。特别地，我们定义 b[0] = 0。

**[引理]** （前缀子序列和递推式）令 $l=r=i$ ，移项得：
$$
b[i] =
\begin{cases}
  0, & \text{if } i = 0 \\
  b[i-1] + a[i],  & \forall i=1,2,...,n \\
\end{cases}
$$



#### Algorithm 1：

Time Complexity = $O(n + m)$ . The time complexity of query operation is $O(1)$ .

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> psum(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        cin >> psum[i];
        psum[i] += psum[i - 1];
    }
    
    while (m--) {
        int left, right;
        cin >> left >> right;
        cout << psum[right] - psum[left - 1] << '\n';
    }
    
    return 0;
}
```





### 2.AcWing0796 前缀子矩阵的和

输入一个 *n* 行 *m* 列的整数矩阵，再输入 *q* 个询问，每个询问包含四个整数 *x*1,*y*1,*x*2,*y*2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。

#### 输入格式

第一行包含三个整数 *n*，*m*，*q*。接下来 *n* 行，每行包含 *m* 个整数，表示整数矩阵。接下来 *q* 行，每行包含四个整数 *x*1,*y*1,*x*2,*y*2，表示一组询问。

#### 输出格式

共 *q* 行，每行输出一个询问的结果。

#### 数据范围

1 ≤ *n* , *m* ≤ 1000 ，

1 ≤ *q* ≤ 200000 ，

1 ≤ *x*1 ≤ *x*2 ≤ *n* ，

1 ≤ *y*1 ≤ *y*2 ≤ *m* ，

−1000 ≤ 矩阵内元素的值 ≤ 1000



#### 输入样例：

```
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```

#### 输出样例：

```
17
27
21
```



#### Algorithm 1：

Time Complexity of Construction = $O(nm)$ , Time Complexity of Query = $O(1)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m, q;
    cin >> n >> m >> q;
    
    vector<vector<int>> psum(n + 1, vector<int>(m + 1, 0));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> psum[i][j];
            psum[i][j] += psum[i - 1][j] + psum[i][j - 1] - psum[i - 1][j - 1];
        }
    }
    
    while (q--) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        cout << psum[x2][y2] - psum[x1 - 1][y2] - psum[x2][y1 - 1] + psum[x1 - 1][y1 - 1] << '\n';
    }
    
    return 0;
}
```



#### Tips：

设矩阵 A = $a_{1..n,1..n}(n\geq 1)$ ，我们称矩阵 B = $b_{1..n,1..n}(n\geq 1)$ 为A的**前缀子矩阵和**（prefix submatrix sum）矩阵，若 B 满足：
$$
b_{x,y}=\sum_{i=1}^{x} \sum_{j=1}^{y} a_{i,j},\forall x=1,2,...,n,\text{ and } y=1,2,...,n
$$

**[定理]** （前缀子矩阵和定理） 设矩阵 B = b[1..n] [1..m] 为矩阵 A = a[1..n] [1..m] 的前缀子矩阵和矩阵，则 A 中以 `(x1, y1)` 为左上角坐标，以 `(x2, y2)` 为右下角坐标的子矩阵 a[x1..x2] [y1..y2] 的和为：
$$
\sum_{i=x1}^{x2} \sum_{j=y1}^{y2}  a[i][j]=b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]
$$
其中，$1 \leq x1 \leq x2 \leq n,1 \leq y1 \leq y2 \leq m$。特别地，我们定义 $b[i][0]=b[0][j]=0, \forall i,j $。

**[引理]** （前缀子矩阵和递推式）令 $x1=x2=i$ ， $y1=y2=j$ 移项得：
$$
b[i][j] =
\begin{cases}
  0, & \text{if } i = 0 \text{ or } j=0 \\
  b[i-1][j] + b[i][j-1] - b[i-1][j-1] + a[i][j], & \forall i=1,2,...,n \\
\end{cases}
$$








### 3.AcWing0797 差分序列

输入一个长度为 *n* 的整数序列。接下来输入 *m* 个操作，每个操作包含三个整数 *l*,*r*,*c*，表示将序列中 [*l*,*r*] 之间的每个数加上 *c*。请你输出进行完所有操作后的序列。

#### 输入格式

第一行包含两个整数 *n* 和 *m*。第二行包含 *n* 个整数，表示整数序列。接下来 *m* 行，每行包含三个整数 *l*，*r*，*c*，表示一个操作。

#### 输出格式

共一行，包含 *n* 个整数，表示最终序列。

#### 数据范围

1 ≤ *n* , *m* ≤ 100000 ,

1 ≤ *l* ≤ *r* ≤ *n* ,

−1000 ≤ *c* ≤ 1000 ,

−1000 ≤ 整数序列中元素的值 ≤ 1000



#### 输入样例：

```
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
```

#### 输出样例：

```
3 4 5 3 4 2
```



#### Algorithm 1:

Time Complexity of Construction = $O(n)$ , Time Complexity of Update = $O(1)$ .

```cpp
#include <iostream>
#include <vector>

using namespace std;

class DifferenceSequence {
private:
    vector<int> dif;
    
public:
    DifferenceSequence(vector<int>& nums) {
        int n = nums.size();
        dif.assign(n + 2, 0);
        for (int i = 1; i <= n; i++) {
            update(i, i, nums[i]);
        }
    }
    
    void update(int left, int right, int val) {
        dif[left] += val;
        dif[right + 1] -= val;
    }
    
    void getNums(vector<int>& nums) {
        int n = nums.size();
        for (int i = 1; i <= n; i++) {
            nums[i] = nums[i - 1] + dif[i];
        }
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> nums(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
    }
    
    DifferenceSequence DS(nums);
    
    while (m--) {
        int left , right, val;
        cin >> left >> right >> val;
        DS.update(left, right, val);
    }
    
    DS.getNums(nums);
    for (int i = 1; i <= n; i++) {
        cout << nums[i] << ' ';
    }
    
    return 0;
}
```



#### Tips：

设序列 A = $a_{1..n}(n\ge 1)$ ，我们称 B = $b_{1..n}$ 为 A 的**差分**（difference）序列，若 B 满足：
$$
b_i =
  a_i - a_{i-1}, \forall i=1,2,...,n
$$
特别地，我们定义 $a[0] = 0 $ 。

**[定理]**  （前缀子序列和与差分定理）   数列 B 为数列 A 的差分数列，当且仅当数列 A 为数列 B 的前缀子序列和数列。

**[引理]**  设序列 B = b[1..n] 为序列 A = a[1..n] 的差分序列，则序列 A 为序列 B 的前缀和序列，并且满足：

1. 如果执行操作`b[i] += c`，等价于对于所有的 $x \in Dom_i$ ，执行操作`a[x] += c`。其中`c`为常数，$Dom_i=\{ x|x=i,i+1,...,n \}$ ，

   即 $Dom_i$ 表示序列 A 的从`i`开始的最大后缀子序列 a[i..n] 。

2. 如果执行操作`b[l] += c; b[r + 1] -= c`，等价于对于所有的 $x \in Dom_{\text{[l , r]}}$ ，执行操作`a[x] += c`。其中`c`为常数，且
   $$
   \begin{align}
   & \quad Dom_{\text{[l , r]}} \\
   & = Dom_l-Dom_{r+1} \\
   & = \{ x|x=l,l+1,...,r \}
   
   \end{align}
   $$
   即 $Dom_{\text{[l , r]}}$ 表示序列 A 的从`l`开始，到`r`结束的子序列 a[l..r] 。











### 4.AcWing0798 差分矩阵

输入一个 *n* 行 *m* 列的整数矩阵，再输入 *q* 个操作，每个操作包含五个整数 *x*1,*y*1,*x*2,*y*2,*c*，其中 (*x*1,*y*1) 和 (*x*2,*y*2) 表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 *c*。请你将进行完所有操作后的矩阵输出。

#### 输入格式

第一行包含整数 *n*,*m*,*q*。接下来 *n* 行，每行包含 *m* 个整数，表示整数矩阵。接下来 *q* 行，每行包含 5 个整数 *x*1,*y*1,*x*2,*y*2,*c*，表示一个操作。

#### 输出格式

共 *n* 行，每行 *m* 个整数，表示所有操作进行完毕后的最终矩阵。

#### 数据范围

1≤*n*,*m*≤1000,
1≤*q*≤100000,
1≤*x*1≤*x*2≤*n*,
1≤*y*1≤*y*2≤*m*,
−1000≤*c*≤1000,
−1000≤矩阵内元素的值≤1000



#### 输入样例：

```
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```

#### 输出样例：

```
2 3 4 1
4 3 4 1
2 2 2 2
```



#### 差分矩阵简介：

**[定义]**  （差分矩阵） 设矩阵 A = $a_{1..n,1..m}(n,m\ge 1)$ ，我们称 B = $b_{1..n,1..m}$ 为 A 的**差分**（difference）矩阵，若 B 满足
$$
b_{i,j} =
  a_{i,j} - a_{i-1,j} - a_{i,j-1} + a_{i-1,j-1} ,  \forall i=1,...,n \text{ and } j=1,2,...,m
$$
特别地，我们定义 $a[i][0]=a[0][j]=0, \forall i,j $ 。

**[定理]**  （前缀子序列和与差分定理）   数列 B 为数列 A 的差分数列，当且仅当数列 A 为数列 B 的最大前缀子序列和数列。

**[引理]**  设矩阵 B = b[1..n] 为矩阵 A = a[1..n] 的差分矩阵，则矩阵 A 为矩阵 B 的前缀子矩阵和矩阵，并且满足：

1. 如果执行操作`b[i][j] += c`，等价于对于所有的 $(x,y) \in Dom_{i,j}$ ，执行操作`a[x][y] += c`。其中`c`为常数，$Dom_{i,j} =\{ (x,y) | x=i,i+1,...,n \text{ and } y=j,j+1,...,m \}$ ，

   即 $Dom_{i,j}$ 为矩阵 A 的以 `(i, j)` 为左上角坐标的后缀子矩阵 a[i..n] [j..m] 。

2. 如果执行操作`b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; `，等价于对于所有的 $(x,y) \in Dom_{\text{[x1 , x2] , [y1 , y2]} }$ ，执行操作`a[x][y] += c`。其中`c`为常数，且
   $$
   \begin{align}
   & \quad Dom_{\text{[x1 , x2] , [y1 , y2]} }  \\
   & = Dom_{x1,y1} - Dom_{x2 +1,y1} - Dom_{x1,y2 + 1} + Dom_{x2 + 1,y2 + 1} \\
   & = \{ (x,y) |x=x1,...,x2,\ y=y1,...,y2 \}
   
   \end{align}
   $$
   即 $Dom_{\text{[x1 , x2] , [y1 , y2]} } $ 为矩阵 A 的以 `(x1, y1)` 为左上角坐标，以 `(x2, y2)` 为右下角坐标的子矩阵 a[x1..x2] [y1..y2] 。





#### Algorithm 1:

Time Complexity of `Construct()` = $O(nm)$ , Time Complexity of `Update()`  = $O(1)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

class DifferenceMaxtrix {
private:
    int n, m;
    vector<vector<int>> dif;
    
public:
    DifferenceMaxtrix(vector<vector<int>>& nums) {
        n = nums.size() - 1;
        m = nums[0].size() - 1;
        dif.assign(n + 2, vector<int>(m + 2, 0));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                update(i, j, i, j, nums[i][j]);
            }
        }
    }
    
    void update(int x1, int y1, int x2, int y2, int val) {
        dif[x1][y1] += val;
        dif[x2 + 1][y1] -= val;
        dif[x1][y2 + 1] -= val;
        dif[x2 + 1][y2 + 1] += val;
    }
    
    void getNums(vector<vector<int>>& nums) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                nums[i][j] = dif[i][j] + nums[i - 1][j] + nums[i][j - 1] - nums[i - 1][j - 1];
            }
        }
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m, q;
    cin >> n >> m >> q;
    
    vector<vector<int>> nums(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> nums[i][j];
        }
    }
    
    DifferenceMaxtrix DM(nums);
    while (q--) {
        int x1, y1, x2, y2, val;
        cin >> x1 >> y1 >> x2 >> y2 >> val;
        DM.update(x1, y1, x2, y2, val);
    }
    
    DM.getNums(nums);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cout << nums[i][j] << ' ';
        }
        cout << '\n';
    }
    
    return 0;
}
```





### x16.AcWing 0099 激光炸弹(前缀矩阵和)

地图上有 *N* 个目标点，用整数 *Xi* , *Yi* 表示目标在地图上的位置，每个目标都有一个价值 *Wi* 。

**注意**：不同目标可能在同一位置。

现在有一种新型的激光炸弹，可以摧毁一个包含 *R*×*R* 个位置的正方形内的所有目标。

激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 *x*，*y* 轴平行。

求一颗炸弹最多能炸掉地图上总价值为多少的目标。

#### 输入格式

第一行输入正整数 *N* 和 *R*，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。

接下来 *N* 行，每行输入一组数据，每组数据包括三个整数 *Xi*,*Yi*,*Wi*，分别代表目标的 *x* 坐标，*y* 坐标和价值，数据用空格隔开。

#### 输出格式

输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。

#### 数据范围

0 ≤ *R* ≤ 10^9

0 < *N* ≤ 10000 ,

0 ≤ *Xi* , *Yi* ≤ 5000 ,

0 ≤ *Wi* ≤ 1000



#### 输入样例：

```
2 1
0 0 1
1 1 1
```

#### 输出样例：

```
1
```



##### Algorithm 1:

Time Complexity : $O(nm)$ .

```c++
#pragma GCC optimize(2)
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int M = 5e3 + 1;
class PrefixSum {
private:
    vector<vector<int>> psum;
    
public:
    PrefixSum(istream& cin, int q) {
        psum.assign(M + 1, vector<int>(M + 1, 0));
        while (q--) {
            int x, y, val;
            cin >> x >> y >> val;
            psum[x + 1][y + 1] += val;
        }
        
        for (int i = 1; i <= M; i++) {
            for (int j = 1; j <= M; j++) {
                psum[i][j] += psum[i - 1][j] + psum[i][j - 1] - psum[i - 1][j - 1];
            }
        }
    }
    
    int query(int x1, int y1, int x2, int y2) {
        return psum[x2][y2] - psum[x1 - 1][y2] - psum[x2][y1 - 1] + psum[x1 - 1][y1 - 1];
    }
    
    int maxTotalValue(int r) {
        int ans = 0;
        r = min(r, M);
        for (int i = r; i <= M; i++) {
            for (int j = r; j <= M; j++) {
                ans = max(ans, query(i - r + 1, j - r + 1, i, j));
            }
        }
        
        return ans;
    }
};



int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int q, r;
    cin >> q >> r;
    
    PrefixSum ps(cin, q);
    
    cout << ps.maxTotalValue(r) << '\n';
    
    return 0;
}
```





### x42.AcWing 1232 三体攻击

三体人将对地球发起攻击。

为了抵御攻击，地球人派出了 *A*×*B*×*C* 艘战舰，在太空中排成一个 *A* 层 *B* 行 *C* 列的立方体。

其中，第 *i* 层第 *j* 行第 *k* 列的战舰（记为战舰 (*i*,*j*,*k*)）的生命值为 *d*(*i*,*j*,*k*) 。

三体人将会对地球发起 *m* 轮“立方体攻击”，每次攻击会对一个小立方体中的所有战舰都造成相同的伤害。

具体地，第 *t* 轮攻击用 7 个参数 $la_t,ra_t,lb_t,rb_t,lc_t,rc_t,h_t$ 描述；

所有满足 $i \in [la_t, rb_t], j\in [lb_t,rb_t], k\in[lc_t,rc_t]$ 的战舰 (*i*,*j*,*k*) 会受到 *ht* 的伤害。

如果一个战舰累计受到的总伤害超过其防御力，那么这个战舰会爆炸。

地球指挥官希望你能告诉他，第一艘爆炸的战舰是在哪一轮攻击后爆炸的。

#### 输入格式

第一行包括 4 个正整数 *A*,*B*,*C*,*m* ；

第二行包含 *A*×*B*×*C* 个整数，其中第 ((*i*−1)×*B*+(*j*−1))×*C*+(*k*−1)+1 个数为 *d*(*i*, *j*, *k*) ；

第 3 到第 *m*+2 行中，第 (*t* − 2) 行包含 7 个正整数 $la_t,ra_t,lb_t,rb_t,lc_t,rc_t,h_t$ 。

#### 输出格式

输出第一个爆炸的战舰是在哪一轮攻击后爆炸的。

保证一定存在这样的战舰。

#### 数据范围

1 ≤ *A* × *B* × *C* ≤ 10^6 ,

1 ≤ *m* ≤ 10^6 ,

0 ≤ *d*(*i*, *j*, *k*), *ht* ≤ 10^9 ,

$1 \leq la_t \leq ra_t \leq A$ ,

$1 \leq lb_t \leq rb_t \leq B$ ,

$1 \leq lc_t \leq rc_t \leq C$ ,

层、行、列的编号都从 1 开始。



#### 输入样例：

```
2 2 2 3
1 1 1 1 1 1 1 1
1 2 1 2 1 1 1
1 1 1 2 1 2 1
1 1 1 1 1 1 2
```

#### 输出样例：

```
2
```

#### 样例解释

在第 2 轮攻击后，战舰 (1,1,1) 总共受到了 2 点伤害，超出其防御力导致爆炸。



#### 输入样例2：

```
10 1 1 10
52 48 47 17 78 98 45 2 11 73
1 3 1 1 1 1 9
4 5 1 1 1 1 30
1 4 1 1 1 1 12
2 5 1 1 1 1 30
2 4 1 1 1 1 28
2 9 1 1 1 1 74
9 9 1 1 1 1 89
5 9 1 1 1 1 51
7 8 1 1 1 1 98
5 7 1 1 1 1 66
```

#### 输出样例2：

```
2
```



##### Algorithm 1:

Time complexity : $O(n \times  \log m)$ , where $n = n_1 \times n_2 \times n_3$ represents the volume of the cube, $m$ is the number of attacks.

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

struct Attack {
    int x1, x2, y1, y2, z1, z2;
    int val;
};

class Difference {
private:
    int n, m, l;
    vector<vector<vector<int>>> dif;

public:
    Difference(istream& cin, int n, int m, int l) : n(n), m(m), l(l) {
        dif.assign(n + 2, vector<vector<int>>(m + 2, vector<int>(l + 2, 0)));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                for (int k = 1; k <= l; k++) {
                    int val;
                    cin >> val;
                    Attack atk{i, i, j, j, k, k, val};
                    update(atk);
                }
            }
        }
    }
    
    void update(Attack& atk) {
        auto [x1, x2, y1, y2, z1, z2, val] = atk;
        dif[x1][y1][z1] += val;
        dif[x2 + 1][y1][z1] -= val;
        dif[x1][y2 + 1][z1] -= val;
        dif[x1][y1][z2 + 1] -= val;
        dif[x1][y2 + 1][z2 + 1] += val;
        dif[x2 + 1][y1][z2 + 1] += val;
        dif[x2 + 1][y2 + 1][z1] += val;
        dif[x2 + 1][y2 + 1][z2 + 1] -= val;
    }
    
    bool restore() {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                for (int k = 1; k <= l; k++) {
                    dif[i][j][k] += dif[i - 1][j][k] + dif[i][j - 1][k] + dif[i][j][k - 1]
                            - dif[i][j - 1][k - 1] - dif[i - 1][j][k - 1] - dif[i - 1][j - 1][k]
                            + dif[i - 1][j - 1][k - 1];
                    if (dif[i][j][k] < 0) {
                        return true;        // Exploded
                    }
                }
            }
        }
        return false;       // Not exploded
    }
};

class Solution {
private:
    vector<Attack> atks;
    
public:
    Solution(istream& cin, int q) {
        atks.resize(q);
        for (auto& atk : atks) {
            cin >> atk.x1 >> atk.x2 >> atk.y1 >> atk.y2 >> atk.z1 >> atk.z2 >> atk.val;
            atk.val = -atk.val; // A negative value indicates receiving an injury
        }
    }
    
    bool check(Difference DF, int idx) {
        for (int i = 0; i < idx; i++) {
            DF.update(atks[i]);
        }
        return DF.restore();
    }
    
    int lowerBound(Difference& DF) {
        int low = 1, high = atks.size();
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(DF, mid)) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        
        return low;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m, l, q;
    cin >> n >> m >> l >> q;
    
    Difference DF(cin, n, m, l);
    Solution S(cin, q);
    
    cout << S.lowerBound(DF) << '\n';
    
    return 0;
}
```







## 1-4 双指针

### 1.AcWing0799 最长连续不重复子序列

给定一个长度为 *n* 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

#### 输入格式

第一行包含整数 *n* 。第二行包含 *n* 个整数（均在 0∼10^5^范围内），表示整数序列。

#### 输出格式

共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

#### 数据范围

1 ≤ *n* ≤ 10^5^



#### 输入样例：

```
5
1 2 2 3 5
```

#### 输出样例：

```
3
```



#### Algorithm 1:

Time Complexity = $O(n + M)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int M = 1e5;

int longestUniqueSubarray(vector<int>& nums) {
    int n = nums.size();
    vector<int> lastIndex(M + 1, -1);
    
    int ans = 0;
    for (int i = 0, j = -1; i < n; i++) {
        j = max(j, lastIndex[nums[i]]);
        ans = max(ans, i - j);
        lastIndex[nums[i]] = i;
    }
    return ans;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << longestUniqueSubarray(nums) << '\n';
    
    return 0;
}
```





### 2.AcWing0800 数组元素的目标和

给定两个升序排序的有序数组 *A* 和 *B*，以及一个目标值 *x* 。数组下标从 0 开始。请你求出满足 *A*[*i*]+*B*[*j*]=*x* 的数对 (*i*,*j*)。数据保证有唯一解。

#### 输入格式

第一行包含三个整数 *n*,*m*,*x*，分别表示 *A* 的长度，*B* 的长度以及目标值 *x*。

第二行包含 *n* 个整数，表示数组 *A*。

第三行包含 *m* 个整数，表示数组 *B*。

#### 输出格式

共一行，包含两个整数 *i* 和 *j*。

#### 数据范围

数组长度不超过 10^5。

同一数组内元素各不相同。

1 ≤ 数组元素 ≤ 10^9



#### 输入样例：

```
4 5 6
1 2 4 7
3 4 6 8 9
```

#### 输出样例：

```
1 1
```



#### Algorithm 1：

Time Complexity = $O(n + m)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

pair<int, int> targetSumPair(vector<int>& a, vector<int>& b, int target) {
    int n = a.size(), m = b.size();
    int i = 0, j = m - 1;
    while (true) {
        while (a[i] + b[j] < target) {
            i++;
        }
        while (a[i] + b[j] > target) {
            j--;
        }
        if (a[i] + b[j] == target) {
            return {i, j};
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m, target;
    cin >> n >> m >> target;
    
    vector<int> a(n), b(m);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < m; i++) {
        cin >> b[i];
    }
    
    auto [i, j] = targetSumPair(a, b, target);
    cout << i << ' ' << j << '\n';
    
    return 0;
}
```





### 3.AcWing2816 判断子序列

给定一个长度为 *n* 的整数序列 *a*1,*a*2,…,*an* 以及一个长度为 *m* 的整数序列 *b*1,*b*2,…,*bm*。

请你判断 *a* 序列是否为 *b* 序列的子序列。

子序列指序列的一部分项按**原有相对次序排列**而得的序列，例如序列 {*a*1,*a*3,*a*5} 是序列 {*a*1,*a*2,*a*3,*a*4,*a*5} 的一个子序列。

#### 输入格式

第一行包含两个整数 *n*,*m*。

第二行包含 *n* 个整数，表示 *a*1,*a*2,…,*an*。

第三行包含 *m* 个整数，表示 *b*1,*b*2,…,*bm* 。

#### 输出格式

如果 *a* 序列是 *b* 序列的子序列，输出一行 `Yes`。

否则，输出 `No`。

#### 数据范围

1 ≤ *n* ≤ *m* ≤ 10^5 ,

−10\^9 ≤ *ai* , *bi* ≤ 10\^9



#### 输入样例：

```
3 5
1 3 5
1 2 3 4 5
```

#### 输出样例：

```
Yes
```



#### Algorithm 1:

Time Complexity = $O(n + m)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

bool isSubsequence(vector<int>& a, vector<int>& b) {
    int n = a.size(), m = b.size();
    int i = 0;
    for (int j = 0; i < n && j < m; j++) {
        if (b[j] == a[i]) {
            i++;
        }
    }
    return i == n;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> a(n), b(m);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int j = 0; j < m; j++) {
        cin >> b[j];
    }
    
    cout << (isSubsequence(a, b) ? "Yes" : "No") << '\n';
    
    return 0;
}
```





### 4.LeetCode 0027 Remove Element

Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return *the number of elements in* `nums` *which are not equal to* `val`.

Consider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:

- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.
- Return `k`.

**Custom Judge:**

The judge will test your solution with the following code:

```
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

If all assertions pass, then your solution will be **accepted**.

 

**Example 1:**

```
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

**Example 2:**

```
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

 

**Constraints:**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int j = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != val) {
                nums[j++] = nums[i];
            }
        }
        return j;
    }
};
```





### 5.LeetCode 1047 Remove All adjacent Duplicates in String

You are given a string `s` consisting of lowercase English letters. A **duplicate removal** consists of choosing two **adjacent** and **equal** letters and removing them.

We repeatedly make **duplicate removals** on `s` until we no longer can.

Return *the final string after all such duplicate removals have been made*. It can be proven that the answer is **unique**.

 

**Example 1:**

```
Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
```

**Example 2:**

```
Input: s = "azxxzy"
Output: "ay"
```

 

**Constraints:**

- `1 <= s.length <= 10^5`
- `s` consists of lowercase English letters.



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        int j = -1;
        for (int i = 0; i < s.size(); i++) {
            if (j == -1 || s[i] != s[j]) {
                s[++j] = s[i];
            } else {
                j--;
            }
        }
        s.erase(s.begin() + j + 1, s.end());
        return s;
    }
};
```













## 1-5 位运算

### 1.AcWing0801 位运算

给定一个长度为 *n* 的数列，请你求出数列中每个数的二进制表示中 1 的个数。

#### 输入格式

第一行包含整数 *n*。

第二行包含 *n* 个整数，表示整个数列。

#### 输出格式

共一行，包含 *n* 个整数，其中的第 *i* 个数表示数列中的第 *i* 个数的二进制表示中 1 的个数。

#### 数据范围

1 ≤ *n* ≤ 100000 ,

0 ≤ 数列中元素的值 ≤ 10^9



#### 输入样例：

```
5
1 2 3 4 5
```

#### 输出样例：

```
1 1 2 1 2
```



#### Algorithm 1：

Time Complexity = $O(n \log m)$ .

```cpp
#include <iostream>
#include <vector>

using namespace std;

int numOfBit1(int num) {
    int res = 0;
    while (num) {
        res++;
        num -= num & -num;
    }
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        int num;
        cin >> num;
        cout << numOfBit1(num) << ' ';
    }
    
    return 0;
}
```





## 1-6 顺序遍历

### 1.AcWing 0717 斐波那契数列

以下数列 `0 1 1 2 3 5 8 13 21 ...` 被称为斐波纳契数列。 

这个数列从第 3项开始，每一项都等于前两项之和。

输入一个整数 *N*，请你输出这个序列的前 *N* 项。

#### 输入格式

一个整数 *N* 。

#### 输出格式

在一行中输出斐波那契数列的前 *N* 项，数字之间用空格隔开。

#### 数据范围

0 < *N* < 46



#### 算法1：

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> fib{0, 1};
    for (int i = 0; i < n; i++) {
        int cur = i & 1;
        cout << fib[cur] << ' ';
        fib[cur] += fib[!cur];
    }
    
    return 0;
}
```





### 2.LeetCode 0376 Wiggle Subsequences

A **wiggle sequence** is a sequence where the  differences between successive numbers strictly alternate between  positive and negative. The first difference (if one exists) may be  either positive or negative. A sequence with one element and a sequence  with two non-equal elements are trivially wiggle sequences.

- For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.
- In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two  differences are positive, and the second is not because its last  difference is zero.

A **subsequence** is obtained by deleting some elements  (possibly zero) from the original sequence, leaving the remaining  elements in their original order.

Given an integer array `nums`, return *the length of the longest **wiggle subsequence** of* `nums`.

 

**Example 1:**

```
Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
```

**Example 2:**

```
Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).
```

**Example 3:**

```
Input: nums = [1,2,3,4,5,6,7,8,9]
Output: 2
```

 

**Constraints:**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) {
            return n;
        }

        int preDelta = nums[1] - nums[0];
        int count = preDelta ? 2 : 1;
        for (int i = 2; i < n; i++) {
            int delta = nums[i] - nums[i - 1];
            // 交替地寻找波峰，波谷
            if (delta > 0 && preDelta <= 0 || delta < 0 && preDelta >= 0) {
                count++;
                preDelta = delta;
            }
        }
        return count;
    }
};
```





### 3.LeetCode 0053 Maximum Subarray

Given an integer array `nums`, find the subarray with the largest sum, and return *its sum*.





**Example 1:**

```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
```

**Example 2:**

```
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
```

**Example 3:**

```
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
```

 

**Constraints:**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

 

##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSum = INT_MIN, curSum = 0;
        for (int i = 0; i < nums.size(); i++) {
            curSum += nums[i];
            maxSum = max(maxSum, curSum);
            // 如果当前和 curSum < 0， 则答案中应尽量避免包含当前连续子序列
            // 由于其任意前缀子序列的连续和均不小于 0，故其任意后缀子序列的和不大于 curSum，
            // 于是答案中也应尽量避免包含当前连续子序列的任意后缀子序列
            // 综上所述，应当将 curSum 清零后并从下一个位置重新计数
            if (curSum < 0) {
                curSum = 0;
            }
        }

        return maxSum;
    }
};
```





### 4.LeetCode 0122 Best Time to Buy and Sell Stock II

You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

On each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.

Find and return *the **maximum** profit you can achieve*.

 

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
```

**Example 2:**

```
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
```

**Example 3:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
```

 

**Constraints:**

- `1 <= prices.length <= 3 * 10^4`
- `0 <= prices[i] <= 10^4`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int maxProfit(vector<int>& nums) {
        int res = 0;
        for (int i = 1; i < nums.size(); i++) {
            int delta = nums[i] - nums[i - 1];
            // 如果今天股价高于前一天，则在前一天买入今天卖出
            if (delta > 0) {
                res += delta;
            }
        }
        return res;
    }
};
```





### 5.LeetCode 0055 Jump Game

You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.

Return `true` *if you can reach the last index, or* `false` *otherwise*.

 

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
```

 

**Constraints:**

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10^5`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int maxPos = 0;
        for (int i = 0; i <= maxPos; i++) {
            maxPos = max(maxPos, i + nums[i]);
            if (maxPos >= n - 1) {
                return true;
            }
        }
        return false;;
    }
};
```





### 6.LeetCode 0045 Jump Game II

You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.

Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:

- `0 <= j <= nums[i]` and
- `i + j < n`

Return *the minimum number of jumps to reach* `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.

 

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [2,3,0,1,4]
Output: 2
```

 

**Constraints:**

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 1000`
- It's guaranteed that you can reach `nums[n - 1]`.



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int count = 0;
        int maxCurIndex = 0, maxNextIndex = 0;  // 当前一步和下一步可以到达的最远位置
        for (int i = 0; i < nums.size() - 1; i++) {
            maxNextIndex = max(maxNextIndex, i + nums[i]);
            // 如果已经走到当前一步可以到达的最远位置
            // 则走一步到某位置，并更新 maxCurIndex
            if (i == maxCurIndex) {
                count++;
                maxCurIndex = maxNextIndex;
            }
        }
        return count;
    }
};
```





### 7.LeetCode 0134 Gas Station

There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.

You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.

Given two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**.

 

**Example 1:**

```
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
```

**Example 2:**

```
Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
```

 

**Constraints:**

- `n == gas.length == cost.length`
- `1 <= n <= 10^5`
- `0 <= gas[i], cost[i] <= 10^4`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int totalGas = 0, curGas = 0;
        int start = 0;
        int n = gas.size();
        for (int i = 0; i < n ; i++) {
            int surplus = gas[i] - cost[i];
            curGas += surplus;
            totalGas += surplus;
            if (curGas < 0) {
                start = i + 1;
                curGas= 0;
            }
        }

        return totalGas < 0 ? -1 : start;
    }
};
```





### 8.LeetCode 0135 Candy

There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.

You are giving candies to these children subjected to the following requirements:

- Each child must have at least one candy.
- Children with a higher rating get more candies than their neighbors.

Return *the minimum number of candies you need to have to distribute the candies to the children*.

 

**Example 1:**

```
Input: ratings = [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.
```

**Example 2:**

```
Input: ratings = [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
The third child gets 1 candy because it satisfies the above two conditions.
```

 

**Constraints:**

- `n == ratings.length`
- `1 <= n <= 2 * 10^4`
- `0 <= ratings[i] <= 2 * 10^4`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> candies(n, 1);
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {
                candies[i] = candies[i + 1] + 1;
            }
        }

        int total = 0;
        for (int i = 0; i < n; i++) {
            total += candies[i];
        }
        return total;
    }
};
```





### 9.LeetCode 0860 Lemonade Change

At a lemonade stand, each lemonade costs `$5`. Customers are standing in a queue to buy from you and order one at a  time (in the order specified by bills). Each customer will only buy one  lemonade and pay with either a `$5`, `$10`, or `$20` bill. You must provide the correct change to each customer so that the net transaction is that the customer pays `$5`.

Note that you do not have any change in hand at first.

Given an integer array `bills` where `bills[i]` is the bill the `ith` customer pays, return `true` *if you can provide every customer with the correct change, or* `false` *otherwise*.

 

**Example 1:**

```
Input: bills = [5,5,5,10,20]
Output: true
Explanation: 
From the first 3 customers, we collect three $5 bills in order.
From the fourth customer, we collect a $10 bill and give back a $5.
From the fifth customer, we give a $10 bill and a $5 bill.
Since all customers got correct change, we output true.
```

**Example 2:**

```
Input: bills = [5,5,10,10,20]
Output: false
Explanation: 
From the first two customers in order, we collect two $5 bills.
For the next two customers in order, we collect a $10 bill and give back a $5 bill.
For the last customer, we can not give the change of $15 back because we only have two $10 bills.
Since not every customer received the correct change, the answer is false.
```

 

**Constraints:**

- `1 <= bills.length <= 10^5`
- `bills[i]` is either `5`, `10`, or `20`.



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int count5 = 0, count10 = 0;
        for (int i = 0; i < bills.size(); i++) {
            if (bills[i] == 5) {
                count5++;
            } else if (bills[i] == 10) {
                if (--count5 < 0) {
                    return false;
                }
                count10++;
            } else {
                if (count10) {
                    count10--;
                    if (--count5 < 0) {
                        return false;
                    }
                } else {
                    if ((count5 -= 3) < 0) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
};
```





### 10.AcWing 1208 翻硬币

小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：`**oo***oooo`如果同时翻转左边的两个硬币，则变为：`oooo***oooo` 。

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币，那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作。

#### 输入格式

两行等长的字符串，分别表示初始状态和要达到的目标状态。

#### 输出格式

一个整数，表示最小操作步数。

#### 数据范围

输入字符串的长度均不超过100。

数据保证答案一定有解。



#### 输入样例1：

```
**********
o****o****
```

#### 输出样例1：

```
5
```

#### 输入样例2：

```
*o**o***o***
*o***o**o***
```

#### 输出样例2：

```
1
```



##### Algorithm 1:

Time complexity : $O(n)$ .

```c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    string a, b;
    cin >> a >> b;
    
    int n = a.size();
    vector<int> s(n, 0);
    for (int i = 0; i < n; i++) {
        s[i] = a[i] == b[i];
    }
    
    int cnt = 0;
    for (int i = 1; i < n; i++) {
        if (s[i - 1] == 0) {
            cnt++;
            s[i - 1] ^= 1;
            s[i] ^= 1;
        }
    }
    
    cout << cnt << '\n';
    
    return 0;
}
```





### x13.AcWing 0730 机器人跳跃问题

机器人正在玩一个古老的基于 DOS 的游戏。

游戏中有 *N*+1 座建筑——从 0 到 *N* 编号，从左到右排列。

编号为 0 的建筑高度为 0 个单位，编号为 *i* 的建筑高度为 *H*(*i*) 个单位。

起初，机器人在编号为 0 的建筑处。

每一步，它跳到下一个（右边）建筑。

假设机器人在第 *k* 个建筑，且它现在的能量值是 *E*，下一步它将跳到第 *k*+1 个建筑。

如果 *H*(*k*+1)>*E*，那么机器人就失去 *H*(*k*+1)−*E* 的能量值，否则它将得到 *E*−*H*(*k*+1) 的能量值。

游戏目标是到达第 *N* 个建筑，在这个过程中能量值不能为负数个单位。

现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？

#### 输入格式

第一行输入整数 *N* 。

第二行是 *N* 个空格分隔的整数，*H*(1),*H*(2),…,*H*(*N*) 代表建筑物的高度。

#### 输出格式

输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。

#### 数据范围

1 ≤ *N* , *H* ( *i* ) ≤ 10^5 ,



#### 输入样例1：

```
5
3 4 3 2 4
```

#### 输出样例1：

```
4
```

#### 输入样例2：

```
3
4 4 4
```

#### 输出样例2：

```
4
```

#### 输入样例3：

```
3
1 6 4
```

#### 输出样例3：

```
3
```



##### Algorithm 1:

剩余能量值 $E_i(0\leq i \leq n)$ 的递推式为：
$$
\begin{cases}
E_i = 0 &,i = 0	\\
E_{i+1} = 2E_{i} - H_{i+1} &, i = 0,1,2,\ldots,n-1
\end{cases}
$$
于是
$$
E_i = (E_{i+1} + H_{i+1}) / 2
$$
易知： $E_{i} \geq 0, \forall i = 1, 2, \dots, n$ , 不妨取 $E_n = 0$ , 则 $E_{n-1} \geq (E_n + H_n) / 2$ ，于是最小值为 $E_{n-1} = \lceil (E_n + H_n) / 2 \rceil$ 。以此类推， 得递推公式：
$$
\begin{cases}
E_n = 0\\
E_{i} = \lceil (E_{i+1} + H_{i+1}) / 2 \rceil &, i = 0,1,2,\ldots,n-1
\end{cases}
$$
Time complexity : $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    int ans = 0;
    for (int i = n - 1; i >= 0; i--) {
        ans = (ans + nums[i] + 1) / 2;
    }
    
    cout << ans << '\n';
    
    return 0;
}
```







#### 算法1(38 ms)：

剩余能量值 $E_i(0\leq i \leq n)$ 的递推式为：
$$
\begin{cases}
E_i = 0 &,i = 0	\\
E_i = 2E_{i-1} - H_i &, i = 1,2,\ldots,n
\end{cases}
$$
由于 $1 \leq H_i \leq 10^5, \forall i = 0,1,\ldots,n$ ，知：

- 当 $E_0 = 0$ 时，易得 $E_i < 0 \forall i = 1, 2,\ldots,n$ ，此时必然不满足题意；
- 当 $E_0 = 10^5$ 时，易得 $E_i \geq 10^5 \forall i = 0,1,\ldots,n$ ，此时一定满足题意。

综上所述， $E_{0,min} \in (0, 10^5)$ 。可以采用二分法计算。

时间复杂度：O(n log M)。 n, M 分别为塔的数量与最大高度。

```c++
#include <iostream>

using namespace std;

const int N = 1e5, M = 1e5;

int n, arr[N];

bool check(int e) {
	for (int i = 0; i < n; i++) {
		e = e * 2 - arr[i];
		if (e < 0) {
			return false;
		}
		else if (e >= M) {
			return true;
		}
	}
	
	return true;
}

int get_ans() {
	int low  = 1, high = M;
	while (low < high) {
		int mid = (low + high) / 2;
		if (check(mid)) {
			high = mid;
		}
		else {
			low = mid + 1;
		}
	}
	
	return low;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	
	cout << get_ans();
	
	return 0;
}
```





### y17.AcWing 1230 K倍区间(哈希表)

给定一个长度为 *N* 的数列，$A_1, A_2, \ldots,A_n$ ，如果其中一段连续的子序列 $A_i, A_{i+1}, \ldots, A_j$ 之和是 *K* 的倍数，我们就称这个区间 [ *i* , *j* ] 是 *K* 倍区间。  

你能求出数列中总共有多少个 *K* 倍区间吗？  

#### 输入格式

第一行包含两个整数 *N* 和 *K* 。

以下 *N* 行每行包含一个整数 *Ai* 。

#### 输出格式

输出一个整数，代表 *K* 倍区间的数目。

#### 数据范围

1 ≤ *N* , *K* ≤ 100000 ,

1 ≤ *Ai* ≤ 100000



#### 输入样例：

```
5 2
1
2
3
4
5
```

#### 输出样例：

```
6
```



##### Algorithm 1:

Time complexity : $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, mod;
    cin >> n >> mod;
    
    vector<int> nums(n);
    for (auto& x : nums) {
        cin >> x;
    }
    
    long long ans = 0;
    int sum = 0;
    vector<int> cnt(mod, 0);      // preifx-sum count
    cnt[0] = 1;
    for (auto num : nums) {
        sum = (sum + num) % mod;
        ans += cnt[sum]++;
    }
    
    cout << ans << '\n';
    
    return 0;
}
```









## 1-7 模式匹配与字符串哈希

### 1.AcWing0831 KMP字符串

给定一个字符串 *S*，以及一个模式串 *P* ，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模式串 *P* 在字符串 *S* 中多次作为子串出现。

求出模式串 *P* 在字符串 *S* 中所有出现的位置的起始下标。

#### 输入格式

第一行输入整数 *N*，表示字符串 *P* 的长度。

第二行输入字符串 *P* 。

第三行输入整数 *M*，表示字符串 *S* 的长度。

第四行输入字符串 *S* 。

#### 输出格式

共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。

#### 数据范围

1 ≤ *N* ≤10^5

1 ≤ *M* ≤ 10^6

#### 输入样例：

```
3
aba
5
ababa
```

#### 输出样例：

```
0 2
```



#### 算法1-KMP模式匹配(105 ms)：

时间复杂度：O(n + m)。 n, m 分别为模式串长度，主串长度。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5, M = 1e6;

int n, m;
char pat[N + 2], str[M + 2];

// ne[j] 表示当前缀子串 pat[1..j] 恰好失配时, 指针 j 应当回退到的位置
int ne[N + 2];  // ne[1..n+1]

void get_ne() {
    ne[1] = 0;
    for (int i = 2, j = ne[i - 1]; i <= n + 1; i++) {
        while (j && pat[j] != pat[i - 1]) {
            j = ne[j];
        }
        ne[i] = ++j;
    }
}

void kmp() {
    for (int i = 1, j = 1; i <= m; i++) {
        while (j && pat[j] != str[i]) {
            j = ne[j];
        }
        if (++j == n + 1) {
            cout << i - n << ' ';
            j = ne[j];
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> pat + 1 >> m >> str + 1;
    
    get_ne();
    
    kmp();
    
    return 0;
}
```



#### 算法2(98 ms)：

```c++
#include <iostream>

using namespace std;

const int N = 1e5, M = 1e6;

char pat[N + 2], str[M + 2];
int n, m;

// nextval[j] 表示模式串 pat[1..j] 失配时, 指针 j 应当回退到的位置
// 即子串 pat[1..j-1] 的最大相等前后缀长度 +1
int nextval[N + 2];

void get_nextval() {
    nextval[1] = 0;
    for (int i = 1, j = 0; i <= n; i++) {
        while (j && pat[j] != pat[i]) {
            j = nextval[j];
        }
        nextval[i + 1] = pat[++j] == pat[i + 1] ? nextval[j] : j;
    }
}

void kmp() {
    get_nextval();
    for (int i = 1, j = 1; i <= m; i++) {
        while (j && pat[j] != str[i]) {
            j = nextval[j];
        }
        if (j++ == n) {
            cout << i - n << ' ';
            j = nextval[j];
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> pat + 1 >> m >> str + 1;
    
    kmp();
    
    return 0;
}
```



```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5, M = 1e6;

int n, m;
char pat[N + 2], str[M + 2];

// nextval[j] 表示模式串 pat[1..j] 失配时, 指针 j 应当回退到的位置
// if (pat[j] == pat[next[j]]) nextval[j] = next[next[j]];
int nextval[N + 2];     // nextval[1..n+1]

void get_nextval() {
    nextval[1] = 0;
    for (int i = 2, j = nextval[i - 1]; i <= n + 1; i++) {
        while (j && pat[j] != pat[i - 1]) {
            j = nextval[j];
        }
        // nextval[i] = ++j;
        nextval[i] = pat[++j] == pat[i] ? nextval[j] : j;
    }
}

void kmp() {
    for (int i = 1, j = 1; i <= m; i++) {
        while (j && pat[j] != str[i]) {
            j = nextval[j];
        }
        if (j++ == n) {
            cout << i - n << ' ';
            j = nextval[j];
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> pat + 1 >> m >> str + 1;
    
    get_nextval();
    
    kmp();
    
    return 0;
}
```



#### 算法3(98 ms)：

```c++
#include <iostream>

using namespace std;

const int N = 1e5, M = 1e6;

int n, m;
char pat[N + 1], str[M + 1];

// ne[j] 表示当 pat[j + 1] 与主串失配时, 指针 j 应当回退到的位置
int ne[N];

void get_ne() {
    ne[0] = -1;
    for (int i = 1, j = -1; i < n; i++) {
        while (j != -1 && pat[j + 1] != pat[i]) {
            j = ne[j];
        }
        if (pat[j + 1] == pat[i]) {
            j++;
        }
        ne[i] = j;
    }
}

void kmp() {
    for (int i = 0, j = -1; i < m; i++) {
        while (j != -1 && pat[j + 1] != str[i]) {
            j = ne[j];
        }
        if (pat[j + 1] == str[i]) {
            j++;
        }
        if (j == n - 1) {
            cout << i - j << ' ';
            j = ne[j];
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> pat >> m >> str;
    
    get_ne();
    
    kmp();
    
    return 0;
}
```



#### 算法4-优化(95 ms)：

```c++
#include <iostream>

using namespace std;

const int N = 1e5, M = 1e6;

int n, m;
char p[N], s[M];
int ne[N];

void get_ne() {
    ne[0] = -1;
    for (int i = 1, j = -1; i < n; ++i) {
        while (j != -1 && p[j + 1] != p[i]) {
            j = ne[j];
        }
        if (p[j + 1] == p[i]) {
            ++j;
        }
        ne[i] = j;
    }
    
    // 优化
    for (int i = 0; i < n - 1; ++i) {
        if (ne[i] != -1 && p[ne[i] + 1] == p[i + 1]) {
            ne[i] = ne[ne[i]];
        }
    }
}

void get_ans() {
    for (int i = 0, j = -1; i < m; ++i) {
        while (j != - 1 && p[j + 1] != s[i]) {
            j = ne[j];
        }
        if (p[j + 1] == s[i]) {
            ++j;
        }
        if (j == n - 1) {
            cout << i - j << ' ';
            j = ne[j];
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> p >> m >> s;
    
    get_ne();
    
    get_ans();
    
    return 0;
}
```



#### 算法5-字符串哈希(129 ms)：

时间复杂度：O(n + m)。 n, m 分别为两个串的长度。

```c++
#include <iostream>

using namespace std;

const int N = 1e5, M = 1e6, P = 131;

int n, m;
char str1[N + 1], str2[M + 1];
unsigned long long h[M + 1], power[M + 1], target;

void get_h_and_target() {
    power[0] = 1;
    for (int i = 1; i <= m; ++i) {
        power[i] = power[i - 1] * P;
        h[i] = h[i - 1] * P + str2[i];
    }
    
    for (int i = 1; i <= n; ++i) {
        target = target * P + str1[i];
    }
}

unsigned long long get(int left, int right) {
    return h[right] - h[left - 1] * power[right - left + 1];
}

void get_ans() {
    for (int i = n; i <= m; ++i) {
        int j = i - n + 1;
        if (get(j, i) == target) {
            cout << j - 1 << " ";
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> str1 + 1 >> m >> str2 + 1;
    
    get_h_and_target();
    
    get_ans();
    
    return 0;
}
```





### 2.AcWing0841 字符串哈希

给定一个长度为 *n* 的字符串，再给定 *m* 个询问，每个询问包含四个整数 *l*1,*r*1,*l*2,*r*2，请你判断 [*l*1,*r*1] 和 [*l*2,*r*2] 这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

#### 输入格式

第一行包含整数 *n* 和 *m* ，表示字符串长度和询问次数。

第二行包含一个长度为 *n* 的字符串，字符串中只包含大小写英文字母和数字。

接下来 *m* 行，每行包含四个整数 *l*1,*r*1,*l*2,*r*2 ，表示一次询问所涉及的两个区间。

注意，字符串的位置从 1 开始编号。

#### 输出格式

对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。

每个结果占一行。

#### 数据范围

1 ≤ *n* , *m* ≤ 10^5



#### 输入样例：

```
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
```

#### 输出样例：

```
Yes
No
Yes
```



#### 算法思想：

把前缀子串 `s[0..i-1]` 转化为一个 p ( p 为质数，依经验一般取 131 或 13331) 进制数，其中 `s[0]` 为高位， `s[i-1]` 为低位，然后映射为一个无符号长整数。通过比较对应的整数来进行串的比较。映射函数为：
$$
hash(x) = (s_0 p^{i-1} + s_1 p^{i-2} + \dots + s_{i-1} p^{0}) \bmod q	\tag{*}
$$
其中 q 与 p 互质，且 q 足够大。在本例中，q 为无符号长整形数的最大表示范围，即 $q = 2^{64}$ 。

假设 N 为需要进行映射的串的个数，M 为无符号长整型数最大可表示的数的个数，则发生映射冲突的概率为：
$$
\alpha = 1 - \frac{M(M-1) \dots (M-N+1)}{M^N}	\tag{**}
$$
令 $N = 2^{20}, M = 2^{64}$ ，代入上述公式，易得 $\alpha$ 无限逼近于 0 。



#### 算法1(790 ms)：

时间复杂度：O(n + m)。 n, m分别为字符串的长度，查询次数。其中，预处理的时间开销为 O(n)，每次查询的时间开销为 O(1)。

```c++
#include <iostream>

using namespace std;

const int N = 1e5, P = 131;

int n;
char str[N + 1];
unsigned long long h[N + 1], power[N + 1];

void get_h_and_power() {
	power[0] = 1;
	for (int i = 1; i <= n; ++i) {
		power[i] = power[i - 1] * P;
		h[i] = h[i - 1] * P + str[i];
	}
}

unsigned long long get(int left, int right) {
	return h[right] - h[left - 1] * power[right - left + 1];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m >> str + 1;
	
	get_h_and_power();
	
	while (m--) {
		int l1, r1, l2, r2;
		cin >> l1 >> r1 >> l2 >> r2;
		cout << (get(l1, r1) == get(l2, r2) ? "Yes" : "No") << endl;
	}
	
	return 0;
}
```







## 1-8 高精度算法

### 1.AcWing0791 高精度加法

给定两个正整数（不含前导 0 ），计算它们的和。

#### 输入格式

共两行，每行包含一个整数。

#### 输出格式

共一行，包含所求的和。

#### 数据范围

1≤整数长度≤100000

#### 输入样例：

```
12
23
```

#### 输出样例：

```
35
```



#### Algorithm 1:

Time Complexity = $O(\max (n, m))$ .

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class HighPrecisionNum {
private:
    vector<int> digits;
public:
    HighPrecisionNum(string& s) {
        for (int i = s.size() - 1; i >= 0; i--) {
            digits.push_back(s[i] - '0');
        }
    }
    
    HighPrecisionNum& add(HighPrecisionNum& other) {
        vector<int> &a = digits, &b = other.digits;
        vector<int> res;
        int n = a.size(), m = b.size(), l = max(n, m);
        int carry = 0;
        for (int i = 0; i < l; i++) {
            if (i < n) {
                carry += a[i];
            }
            if (i < m) {
                carry += b[i];
            }
            res.push_back(carry % 10);
            carry /= 10;
        }
        if (carry) {
            res.push_back(carry);
        }
        a = res;
        return *this;
    }
    
    friend ostream& operator<<(ostream& os, HighPrecisionNum& num);
};

ostream& operator<<(ostream& os, HighPrecisionNum& num) {
    auto& a = num.digits;
    for (int i = a.size() - 1; i >= 0; i--) {
        os << a[i];
    }
    
    return os;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    string a, b;
    cin >> a >> b;
    
    HighPrecisionNum x(a), y(b);
    
    cout << x.add(y) << '\n';
    
    return 0;
}
```



#### 算法2：

以9位为一个block，每个block存储在一个int变量中。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int BASE = 1000000000;

void myPush(string& s, vector<int>& v) {
    for (int i = s.size() - 1; i >= 0; i -= 9) {
        int sum = 0;
        for (int j = max(i - 8, 0); j <= i; j++) {
            sum = sum * 10 + s[j] - '0';
        }
        v.push_back(sum);
    }
    
    return;
}

vector<int> add(vector<int>& v1, vector<int>& v2) {
    int m = max(v1.size(), v2.size());
    vector<int> res;
    
    int sum = 0;
    for (int i = 0; i < m; i++) {
        if (i < v1.size()) {
            sum += v1[i];
        }
        if (i < v2.size()) {
            sum += v2[i];
        }
        res.push_back(sum % BASE);
        sum = sum / BASE;
    }
    
    if (sum) {
        res.push_back(sum);
    }
    
    return res;
}

int main()
{
    string s1, s2;
    cin >> s1 >> s2;
    
    vector<int> v1, v2;
    myPush(s1, v1);
    myPush(s2, v2);

    auto res = add(v1, v2);

    cout << res.back();
    for (int i = res.size() - 2; i >= 0; i -- ) {
        // %0nd，表示输出宽度为n，头部以0填充
        printf("%09d", res[i]);
    }

    return 0;
}
```



#### 算法3：有bug，但不知道在哪

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 100008 / 9 + 1;
const int BASE = 1e9;

// 以9个为一组，把str的内容存到num[1..len-1]
void pushBack(int num[], string& str, int len) {
    int k = len;
    
    for (int i = str.size() - 1; i >= 0; i -= 9) {
        
        int end = i - 8;
        if (end < 0) {
            end = 0;
        }
        
        int numK = 0;
        for (int j = i; j >= end; j--) {
            numK = numK * 10 + str[j] - '0';
        }
        
        num[k--] = numK;
    }
    
    return;
}

// 把num1[1..len1-1]与num2[1..len2-1]加到res[0..len3-1]
void add(int res[], int num1[], int num2[], int len1, int len2) {
    int i = len1 - 1, j = len2 - 1;
    int k = max(i, j);
    
    int carry = 0;
    while (k >= 0) {
        int sum = carry;
        if (i > 0) {
            sum += num1[i--];
        }
        if (j > 0) {
            sum += num2[j--];
        }
        
        carry = sum / BASE;
        res[k--] = sum % BASE;
    }
    
    return;
}

int main() {
    string str1, str2;
    cin >> str1 >> str2;
    
    // len 为num数组的长度，其中num[0]不使用，留作高位进位时使用
    int num1[N], num2[N];
    int len1 = (str1.size() + 8) / 9 + 1, len2 = (str2.size() + 8) / 9 + 1;
    int len3 = max(len1, len2);
    
    pushBack(num1, str1, len1);
    pushBack(num2, str2, len2);
    
    int res[N];
    add(res, num1, num2, len1, len2);
    
    if (res[0] != 0) {
        printf("%d", res[0]);
    }
    for (int i = 1; i < len3; i++) {
        printf("%09d", res[i]);
    }
    
    return 0;
}
```













### 2.AcWing0792 高精度减法

给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。

#### 输入格式

共两行，每行包含一个整数。

#### 输出格式

共一行，包含所求的差。

#### 数据范围

1 ≤ 整数长度 ≤ 10^5



#### 输入样例：

```
32
11
```

#### 输出样例：

```
21
```



#### 算法1(56 ms)：

时间复杂度：O(max(n, m))。n, m 分别为两个整数的长度。

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

bool cmp(vector<int>& a, vector<int>& b) {
    if (a.size() != b.size()) {
        return a.size() < b.size();
    }
    
    for (int i = a.size() - 1; i >= 0; --i) {
        if (a[i] != b[i]) {
            return a[i] < b[i];
        }
    }
    
    return false;
}

void sub(vector<int>& a, vector<int>& b, vector<int>& res) {
    if (cmp(a, b)) {
        sub(b, a, res);
        res.push_back(-1);
        return;
    }
    
    int dif = 0;
    for (int i = 0; i < a.size(); ++i) {
        dif += a[i];
        if (i < b.size()) {
            dif -= b[i];
        }
        if (dif >= 0) {
            res.push_back(dif);
            dif = 0;
        }
        else {
            res.push_back(dif + 10);
            dif = -1;
        }
    }
    
    while (res.size() != 1 && res.back() == 0) {
        res.pop_back();
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    vector<int> a, b;
    
    string s;
    cin >> s;
    for (int i = s.size() - 1; i >= 0; --i) {
        a.push_back(s[i] - '0');
    }
    cin >> s;
    for (int i = s.size() - 1; i >= 0; --i) {
        b.push_back(s[i] - '0');
    }
    
    vector<int> res;
    sub(a, b, res);
    
    if (res.back() == -1) {
        cout << '-';
        res.pop_back();
    }
    for (int i = res.size() - 1; i >= 0; --i) {
        cout << res[i];
    }
    
    return 0;
}
```











### 3.AcWing0793 高精度乘法

给定两个非负整数（不含前导 0） *A* 和 *B*，请你计算 *A*×*B* 的值。

#### 输入格式

共两行，第一行包含整数 *A* ，第二行包含整数 *B*。

#### 输出格式

共一行，包含 *A*×*B* 的值。

#### 数据范围

1 ≤ *A*的长度 ≤ 100000 ，

0 ≤ *B* ≤ 10000



#### 输入样例：

```
2
3
```

#### 输出样例：

```
6
```



#### 算法1(45 ms)：

时间复杂度：O(n)。n 为整数 A 的长度。

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

void mul(vector<int>& a, int b, vector<int>& res) {
    if (a.size() == 1 && a[0] == 0 || b == 0) {
        res.push_back(0);
        return;
    }
    
    int prod = 0;
    for (int i = 0; i < a.size(); ++i) {
        prod += a[i] * b;
        res.push_back(prod % 10);
        prod /= 10;
    }
    
    while (prod) {
        res.push_back(prod % 10);
        prod /= 10;
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    vector<int> a;
    int b;
    
    string s;
    cin >> s >> b;
    for (int i = s.size() - 1; i >= 0; --i) {
        a.push_back(s[i] - '0');
    }
    
    vector<int> res;
    mul(a, b, res);
    
    for (int i = res.size() - 1; i >= 0; --i) {
        cout << res[i];
    }
    
    return 0;
}
```







### 4.AcWing0794 高精度除法

给定两个非负整数（不含前导 0） *A*，*B*，请你计算 *A*/*B* 的商和余数。

#### 输入格式

共两行，第一行包含整数 *A* ，第二行包含整数 *B*。

#### 输出格式

共两行，第一行输出所求的商，第二行输出所求余数。

#### 数据范围

1 ≤ *A*的长度 ≤ 100000 ，

1 ≤ *B* ≤ 10000 ，

*B* 一定不为 0



#### 输入样例：

```
7
2
```

#### 输出样例：

```
3
1
```



#### 算法1(41 ms)：

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

void div(vector<int>& a, int b, vector<int>& res, int& rem) {
    res.resize(a.size());
    
    rem = 0;
    for (int i = a.size() - 1; i >= 0; --i) {
        rem = rem * 10 + a[i];
        res[i] = rem / b;
        rem %= b;
    }
    
    while (res.size() != 1 && res.back() == 0) {
        res.pop_back();
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    vector<int> a;
    int b;
    
    string s;
    cin >> s >> b;
    for (int i = s.size() - 1; i >= 0; --i) {
        a.push_back(s[i] - '0');
    }
    
    vector<int> res;
    int rem;
    div(a, b, res, rem);
    
    for (int i = res.size() - 1; i >= 0; --i) {
        cout << res[i];
    }
    cout << endl << rem << endl;
    
    return 0;
}
```

