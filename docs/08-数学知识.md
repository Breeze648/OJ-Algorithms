# 八、数学知识

## 8-1 质数

### 1.AcWing0866 试除法判断质数

给定 *n* 个正整数 $a_i(i=1,2,...,n)$ ，判定每个数是否是质数。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个正整数 $a_i$ 。

#### 输出格式

共 *n* 行，其中第 *i* 行输出第 *i* 个正整数 $a_i$  是否为质数，是则输出 `Yes`，否则输出 `No`。

#### 数据范围

1 ≤ *n* ≤ 100 ,

1 ≤ $a_i$ ≤ 2^31−1



#### 输入样例：

```
2
2
6
```

#### 输出样例：

```
Yes
No
```



#### 算法1：

Time Complexity = $O(n \sqrt {x})$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

// Function to check if a given number x is prime
bool isPrime(int x) {
    // Spacial Case: 1 is not a prime number
    if (x == 1) {
        return false;
    }
    
    // Optimized Loop: Iterate from 2 to sqrt(x)
    for (int i = 2; i <= x / i; i++) {
        // If x is divisible by i, it is not a prime number
        if (!(x % i)) {
            return false;
        }
    }
    
    // If no divisors are found, x is prime
    return true;
}


int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        int x;
        cin >> x;
        cout << (isPrime(x) ? "Yes" : "No") << '\n';
    }
    
    return 0;
}
```





### 2.AcWing0867 分解质因数

给定 *n* 个正整数 $a_i(i=1,2,...,n)$ ，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个正整数 $a_i$ 。

#### 输出格式

对于每个正整数 $a_i$ ，分解其质因数，对于每个质因数，按照质因数从小到大的顺序，输出一行，表示质因数对应的底数和指数。

每个正整数的质因数全部输出完毕后，输出一个空行。

#### 数据范围

1 ≤ *n* ≤ 100 ,

2 ≤ $a_i$ ≤ 2×10^9



#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
2 1
3 1

2 3
```



#### 算法1(26 ms)：

Time Complexity = $O(n \sqrt {x})$ .

```c++
#include <iostream>

using namespace std;

// Function to perform prime factorization of a given number x
void primeFactorization(int x) {
    // 1. Iterate over possible divisors from 2 up to sqrt(x)
    for (int i = 2; i <= x / i; i++) {
        // Check if i is a factor of x
        if (x % i == 0) {
            int cnt = 0; // Counter to track the power of the current prime factor
            // Divide x by i repeatedly while it is divisible
            while (x % i == 0) {
                x /= i;
                cnt++;
            }
            // Output the prime factor and its power
            cout << i << ' ' << cnt << '\n';
        }
    }
    
    // 2. If x is still greater than 1, it is a prime factor itself
    if (x > 1) {
        cout << x << ' ' << 1 << '\n';
    }
    
    cout << '\n'; 
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        int x;
        cin >> x;
        primeFactorization(x);
    }
    
    return 0;
}
```





### 3.AcWing0868 筛质数

给定一个正整数 *n*，请你求出 1∼*n* 中质数的个数。

#### 输入格式

共一行，包含整数 *n* 。

#### 输出格式

共一行，包含一个整数，表示 1∼*n* 中质数的个数。

#### 数据范围

1 ≤ *n* ≤ 10^6



#### 输入样例：

```
8
```

#### 输出样例：

```
4
```



#### 算法思想1：

可以使用**埃拉托色尼筛**（Sieve of Eratosthenes）来求解 1 到 n 中质数的个数。其算法思想如下：

1. 初始化一个大小为 n+1 的布尔数组 `prime`，全部初始化为 `true`，表示所有的数都是质数。
2. 从 2 开始遍历到 sqrt(n)，对于每个数 `i`：
   - 如果 `prime[i]` 为 `true`，表示 `i` 是质数，那么将 `i` 的所有倍数（除了 `i` 本身）标记为非质数，即置 `prime[j] = false` ，其中 $j=k*i(k=2,3,4,...)$ 且 $j<=n$ 。
3. 统计 `prime` 数组中值为 true 的个数，即为 1 到 n 中质数的个数。

这个算法的时间复杂度为 O(nloglogn)，是一种高效的质数筛选算法。



#### 算法1-埃氏筛法：

Time Complexity = $O(n \log(\log n))$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

// Function to count prime numbers up to n using Eratosthenes Sieve algorithm
int eratosthenesSieve(int n) {
    // Create a boolean vector to track primality of numbers from 0 to n
    vector<bool> isPrime(n + 1, true);
    
    int cnt = 0;
    // Iterate through all numbers from 2 to n
    for (int i = 2; i <= n; i++) {
        // If the current number is marked as prime
        if (isPrime[i]) {
            cnt++; // Increment the prime count
            // Mark all multiples of i as non-prime
            for (int j = i + i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    // Return the total count of prime numbers up to n
    return cnt;
}


int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    cout << eratosthenesSieve(n) << '\n';
    
    return 0;
}
```



#### 算法思想2：

存在线性时间复杂度的筛质数算法，例如 Euler 线性筛法。其算法思想如下：

1. 初始化一个大小为 n+1 的整数数组 `prime`，全部初始化为 0。
2. 从 2 开始遍历到 n，对于每个数 `i`：
   - 如果 `prime[i]` 为 0，表示 `i` 是质数，将 `i` 加入质数数组 `primes` 中。
   - 遍历质数数组 `primes`，将 `i` 乘以每个质数 `primes[j]`，并将得到的结果标记为非质数，即 `prime[i*primes[j]] = true` ，同时更新 `i` 的最小质因子 `prime[i]` 为 `primes[j]`。
   - 如果 `i` 能整除 `primes[j]`，说明 `i` 的最小质因子是 `primes[j]`，即不再需要继续乘以 `primes[j]`，退出内层循环。
3. 遍历完成后，`prime[i]` 为 0 的 `i` 就是质数，而 `prime[i]` 不为 0 的 `i` 是 `i` 的最小质因子。

这个算法的时间复杂度为 O(n)，是一种高效的线性筛质数算法。



#### 算法2-欧拉线性筛法：

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

// Function to count prime numbers up to n using Eular Sieve algorithm
int eularSieve(int n) {
    vector<bool> isPrime(n + 1, true);
    vector<int> primes;
    
    // Iterate through all numbers from 2 to n
    for (int i = 2; i <= n; i++) {
        // 1. If i is marked as prime, record i
        if (isPrime[i]) {
            primes.push_back(i);
        }
        // 2. Use the minimum prime factor to screen out non-prime numbers
        for (int j = 0; primes[j] <= n / i; j++) {
            // primes[j] is the minimum prime factor of i * primes[j].
            isPrime[i * primes[j]] = false;
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
    
    return primes.size();
}


int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    cout << eularSieve(n) << '\n';
    
    return 0;
}
```





### 4.AcWing0873 欧拉函数

给定 *n* 个正整数 $a_i$ ，请你求出每个数的欧拉函数。

##### 欧拉函数的定义

> 1∼*N* 中与 *N* 互质的数的个数被称为欧拉函数，记为 *ϕ*(*N*)。
>
> 若在算数基本定理中，$N=p_1^{a_1}\times p_2^{a_2}\times ...\times p_k^{a_k}$，则：

$$
\phi(N)= N\times \frac{p_1-1}{p_1}\times \frac{p_2-1}{p_2}\times ...\times \frac{p_k-1}{p_k}
$$



#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个正整数 $a_i$ 。

#### 输出格式

输出共 *n* 行，每行输出一个正整数 $a_i$ 的欧拉函数。

#### 数据范围

1 ≤ *n* ≤ 100 ,

1 ≤ $a_i$ ≤ 2×10^9



#### 输入样例：

```
3
3
6
8
```

#### 输出样例：

```
2
2
4
```



#### 算法1：

Time Complexity = $O(n \sqrt {x})$ .

```c++
#include <iostream>

using namespace std;

int eularPhi(int num) {
	int res = num;
	for (int i = 2; i <= num / i; i++) {
	    if (num % i == 0) {
	        while (num % i == 0) {
	            num /= i;
	        }
	        res = res / i * (i - 1);
	    }
	}
	if (num > 1) {
	    res = res / num * (num - 1);
	}
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n;
	cin >> n;
	
	while (n--) {
		int num;
		cin >> num;
		cout << eularPhi(num) << '\n';
	}
	
	return 0;
}
```





### 5.AcWing0874 筛法求欧拉函数

给定一个正整数 *n*，求 1∼*n* 中每个数的欧拉函数之和。

#### 输入格式

共一行，包含一个整数 *n* 。

#### 输出格式

共一行，包含一个整数，表示 1∼*n* 中每个数的欧拉函数之和。

#### 数据范围

1 ≤ *n* ≤ 10^6



#### 输入样例：

```
6
```

#### 输出样例：

```
12
```



#### 算法思想：

通过欧拉线性筛访问所有正整数。

1. 对于整数 `x` ，根据算术基本定理：
   $$
   x = p_1^{a_1} \times p_2^{a_2} \times ...\times p_k^{a_k}
   $$
   则 $[1, x]$ 中与 $x$ 互质的整数的个数 $\phi (x)$ 为：
   $$
   \phi(x) = x \times A(x)
   $$
   其中记 $A(x)$ 为：
   $$
   A(x) = \frac{p_1 - 1}{p_1} \times \frac{p_2 - 1}{p_2} \times ...\times \frac{p_k - 1}{p_k}
   $$
   特别地，若 $x$ 是质数，则 $\phi (x)$ 为
   $$
   \phi(x) = x - 1 \tag{*}
   $$

2. 访问整数 `primes[j] * i` 时，显然
   $$
   A (primes[j] \times i) = A(i)
   $$
   若 `primes[j]` 是 `i` 的质因数，则
   $$
   \phi(primes[j] * i)
   = primes[j] \times i \times A(i)
   = \phi(i) \times primes[j] \tag{**}
   $$
   若 `primes[j]` 不是 `i` 的质因数，则
   $$
   \phi(primes[j] * i) 
   = primes[j] \times i \times A(i) \times \frac{primes[j] - 1}{primes[j]}
   = \phi(i) \times (primes[j] - 1) \tag{***}
   $$

3. 由基本公式 `(*)` 和递推公式 `(**), (***)` ，通过欧拉线性筛遍历 2 到 `n` 的所有整数，每次访问一个整数时，计算并记录其欧拉函数值。当所有整数已遍历，返回最终结果。

时间复杂度：O(n)。其中 n 为给定的整数值。





#### 算法1：

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

long long sumPhi(int n) {
    vector<int> primes;
    vector<int> phi(n + 1, -1);
    
    long long res = phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (phi[i] == -1) {
            primes.push_back(i);
            res += phi[i] = i - 1;
        }
        
        for (int j = 0; primes[j] <= n / i; j++) {
            // If primes[j] is the prime factor of i
            if (i % primes[j] == 0) {
                res += phi[i * primes[j]] = phi[i] * primes[j];
                // primes[j] is the minimum prime factor of k, ending the screening
                break;
            }
            // If primes[j] is not the prime factor of i
            else {
                res += phi[i * primes[j]] = phi[i] * (primes[j] - 1);
            }
        }
    }
    
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    cout << sumPhi(n) << '\n';
    
    return 0;
}
```







## 8-2 约数

### 1.AcWing0869 试除法求约数

给定 *n* 个正整数 $a_i$ ，对于每个整数 $a_i$ ，请你按照从小到大的顺序输出它的所有因数。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个整数 $a_i$ 。

#### 输出格式

输出共 *n* 行，其中第 *i* 行输出第 *i* 个整数 $a_i$ 的所有因数。

#### 数据范围

1 ≤ *n* ≤ 100 ,
1 ≤  $a_i$ ≤ 2×10^9



#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
1 2 3 6 
1 2 4 8 
```



#### 算法思想：

试除法求因数的算法思想如下：

1. 1 是 n 的一个因数。如果 n 不为 1，则 n 本身也是一个因数，将其加入结果集合中。
2. 从 2 开始，逐个尝试将待分解的数 n 除以每个可能的因数，直到尝试的因数大于 n 的平方根为止。
3. 如果当前尝试的因数 i 能够整除 n（即 n % i == 0），则 i 是 n 的一个因数，而 n / i 则是另一个因数。
4. 将找到的因数添加到结果集合中，并继续尝试下一个可能的因数。

这样就可以找到所有 n 的因数。



#### 算法1：

Time Complexity = $O(n \sqrt x)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to print all factors of a number in ascending order
void getFactors(int x) {
    // Vectors to store smaller and larger factors separately
    vector<int> nums0{1}; // Start with 1 as a factor
    vector<int> nums1{x}; // Include the number itself as a factor

    // Find factors from 2 to sqrt(x)
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) { 
            nums0.push_back(i);       // Add the smaller factor
            nums1.push_back(x / i);   // Add the corresponding larger factor
        }
    }

    // If the last smaller factor equals the last larger factor, remove the duplicate
    if (nums0.back() == nums1.back()) {
        nums1.pop_back();
    }

    // Print smaller factors in ascending order
    for (int i = 0; i < nums0.size(); i++) {
        cout << nums0[i] << ' ';
    }
    // Print larger factors in descending order
    for (int i = nums1.size() - 1; i >= 0; i--) {
        cout << nums1[i] << ' ';
    }
    // End the output with a newline
    cout << '\n';
}


int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        int x;
        cin >> x;
        getFactors(x);
    }
    
    return 0;
}
```







### 2.AcWing0870 约数个数

给定 *n* 个正整数 $a_i$ ，请你输出这些数的乘积的约数个数，答案对 10^9+7 取模。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个整数 $a_i$ 。

#### 输出格式

输出一个整数，表示所给正整数的乘积的约数个数，答案需对 10^9+7 取模。

#### 数据范围

1 ≤ *n* ≤ 100 ,

1 ≤ $a_i$ ≤ 2 × 10^9



#### 输入样例：

```
3
2
6
8
```

#### 输出样例：

```
12
```



#### 算法思想：

筛法求约数个数是一种利用筛法（例如埃氏筛）求解某个数的所有约数个数的算法。其算法思想如下：

1. 首先使用筛法（例如埃氏筛）生成 1 到 N 范围内每个数的最小质因数。
2. 对于任意一个正整数 n，它的约数可以分解为 n 的质因数的组合。例如，如果 $n = p_1^{a_1} * p_2^{a_2} * ... * p_k^{a_k}$，其中 $p_1,p_2,...,p_k$ 是 n 的质因数，$a_1,a_2,...,a_k$ 是对应的幂次，则 n 的约数个数为 $(a_1 + 1) * (a_2 + 1) * ... * (a_k + 1)$ 。
3. 因此，要求解 n 的约数个数，只需要将 n 分解质因数，然后根据每个质因数的幂次计算其约数个数，然后将所有质因数的约数个数相乘即可得到 n 的约数个数。

这样，通过预处理出每个数的最小质因数以及其对应的幂次，就可以在 O(logN) 的时间复杂度内求解任意一个正整数的约数个数。



**[定理]** 约数个数与约数之和定理

对于任意一个正整数 n，假设将 n 质因式分解的结果为
$$
n = p_1^{a_1} * p_2^{a_2} * ... * p_k^{a_k}
$$
其中 $p_1,p_2,...,p_k$ 是 n 的质因数，$a_1,a_2,...,a_k$ 是对应的幂次。则它的约数 $f$ 可以分解为 n 的质因数的组合：
$$
f=p_1^{d_1} *p_2^{d_2} * ... * p_k^{d_k} \text{, 其中 } d_i=0,1,...,a_i
$$
对于项 $p_i^{a_i}$ ，可取 $d_i=0,1,2,...,a_i$ ,有  $a_i + 1$ 种不同的选择。因此， n 的约数 $f$ 的总个数 $num$ 为
$$
num=(a_1 + 1) * (a_2 + 1) * ... * (a_k + 1)
$$
 n 的全部的约数的和 $sum$ 为
$$
sum=(p_1^{0}+p_1^{1} +...+ p_1^{a_1}) * (p_2^{0}+p_2^{1} +...+ p_2^{a_2}) *...* 
	(p_i^{0}+p_i^{1} +...+ p_i^{a_i})
$$



#### 算法1：

Time Complexity = $O(n\log x)$ .

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

const int MOD = 1e9 + 7;

int numOfFactors(vector<int>& nums) {
    // <prime, power>
    unordered_map<int, int> powers;
    
    for (auto num : nums) {
        for (int i = 2; i <= num / i; i++) {
            while (num % i == 0) {
                powers[i]++;
                num /= i;
            }
        }
        if (num > 1) {
            powers[num]++;
        }
    }
    
    long long res = 1;
    for (auto [prime, power] : powers) {
        res = res * (power + 1) % MOD;
    }
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << numOfFactors(nums) << '\n';
    
    return 0;
}
```





### 3.AcWing0871 约数之和

给定 *n* 个正整数 $a_i$ ，请你输出这些数的乘积的约数之和，答案对 10^9+7 取模。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个整数 $a_i$ 。

#### 输出格式

输出一个整数，表示所给正整数的乘积的约数之和，答案需对 10^9+7 取模。

#### 数据范围

1 ≤ *n* ≤ 100 ,

1 ≤ $a_i$ ≤ 2×10^9



#### 输入样例：

```
3
2
6
8
```

#### 输出样例：

```
252
```



#### 算法1：

Time Complexity = $O(n\log x)$ .

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

const int MOD = 1e9 + 7;

int sumOfFactors(vector<int>& nums) {
    // <prime, power>
    unordered_map<int, int> powers;
    
    for (auto num : nums) {
        for (int i = 2; i <= num / i; i++) {
            while (num % i == 0) {
                powers[i]++;
                num /= i;
            }
        }
        if (num > 1) {
            powers[num]++;
        }
    }
    
    long long res = 1;
    for (auto [prime, power] : powers) {
        // Sum of geometric progression
        long long sum = 1;
        while (power--) {
            sum = (sum * prime + 1) % MOD;
        }
        res = res * sum % MOD;
    }
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << sumOfFactors(nums) << '\n';
    
    return 0;
}
```







### 4.AcWing0872 最大公约数

给定 *n* 对正整数 $a_i,b_i$ ，请你求出每对数的最大公约数。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个整数对 $a_i,b_i$ 。

#### 输出格式

输出共 *n* 行，每行输出一个整数对的最大公约数。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,
1 ≤ $a_i,b_i$ ≤ 2 × 10^9



#### 输入样例：

```
2
3 6
4 6
```

#### 输出样例：

```
3
2
```



#### 算法思想：

欧几里德算法（Euclidean Algorithm），也称辗转相除法，是一种用于计算两个非负整数的最大公约数（Greatest Common Divisor, GCD）的经典算法。其思想基于以下原理：两个整数的最大公约数等于其中较小的数与两数相除余数的最大公约数。

具体算法思想如下：

1. 若两个数中有一个为0，则另一个数即为最大公约数。
2. 否则，用较大的数除以较小的数，得到余数。
3. 若余数为0，则较小的数即为最大公约数。
4. 若余数不为0，则将较小的数和余数作为新的一对数，继续执行步骤2和步骤3，直到余数为0为止。

欧几里德算法的时间复杂度很低，可以在很短的时间内计算出两个整数的最大公约数，因此被广泛应用于实际计算中。



**[定理]** 假设$a,b\ (a<b)$ 为两个正整数, $\text{gcd}(a, b)$ 为它们的最大公约数。则
$$
\text{gcd}(a, b)=\text{gcd}(a\mod b, b)
$$
即，两个整数的最大公约数等于其中较小的数与两数相除余数的最大公约数。

**[证明]** 我们需要证明：对于两个整数 \( a \) 和 \( b \)，它们的最大公约数 \( $\text{gcd}(a, b)$ \) 等于较小的数 \( b \) 和两数相除余数 \( $a\mod b$ \) 的最大公约数。

假设 \( r \) 是 \( a \) 除以 \( b \) 的余数，则有 \( $a = q \times b + r$ \)，其中 \( q \) 是 \( a \) 除以 \( b \) 的商。

首先，我们知道 \( $\text{gcd}(a, b)$ \) 同时是 \( a \) 和 \( b \) 的公约数，因此也是 \( b \) 和 \( r \) 的公约数。所以 \( $\text{gcd}(a, b)$ \) 的所有公约数也是 \( b \) 和 \( r \) 的公约数。

其次，对于任意 \( b \) 和 \( r \) 的公约数 \( d \)，我们可以得出 \( d \) 是 \( a \) 和 \( b \) 的公约数。因为 \( $a = q \times b + r$ \)，所以 \( d \) 也是 \( a \) 和 \( r \) 的公约数。

因此，\( b \) 和 \( r \) 的所有公约数也是 \( a \) 和 \( b \) 的公约数。

综上所述，\( a \) 和 \( b \) 的最大公约数等于 \( b \) 和 \( $a \mod b$ \) 的最大公约数。



#### 算法1-欧几里得算法：

Time complexity = $O(n \log (\min (a,b)))$ . The worst-case time complexity of each set of data is  $O(\log (\min (a,b)))$ , where a and b are continuous Fibonacci numbers.

```c++
#include <iostream>

using namespace std;

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n;
	cin >> n;
	
	while (n--) {
		int a, b;
		cin >> a >> b;
		cout << gcd(a, b) << '\n';
	}
	
	return 0;
}
```







## 8-3 快速幂运算

### 1.AcWing0875 快速幂

给定 *n* 组 *ai* , *bi* , *pi* ，对于每组数据，求出 $a_i^{b_i} \bmod \ p_i$ 的值。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含三个整数 *ai* , *bi* , *pi* 。

#### 输出格式

对于每组数据，输出一个结果，表示 $a_i^{b_i} \mod \ p_i$ 的值。

每个结果占一行。

#### 数据范围

1 ≤ *n* ≤ 100000 ,

1 ≤ *ai* , *bi* , *pi* ≤ 2×10^9



#### 输入样例：

```
2
3 2 5
4 3 9
```

#### 输出样例：

```
4
1
```



#### 算法思想

Fast Modular Exponentiation 快速模幂运算。

每组数据的处理时间为：O(log b~i~)。

分别计算 $\lfloor log_2 b \rfloor $ 项：
$$
a^1, a^2, a^4, ..., a^{2^{\lfloor log_2 b \rfloor } }
$$
然后根据 b 的二进制位，从中选择合适的项相乘即可得到 $a^b$ 。



#### 算法1：

Time Complexity = $O(n \log b)$ .

```c++
#include <iostream>

using namespace std;

int fme(long long a, int b, int p) {
	int res = 1;
	while (b) {
		if (b & 1) {
			res = res * a % p;
		}
		a = a * a % p;
		b >>= 1;
	}
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n;
	cin >> n;
	
	while (n--) {
		int a, b, p;
		cin >> a >> b >> p;
		cout << fme(a, b, p) << '\n';
	}
	
	return 0;
} 
```





### 2.AcWing0876 快速幂求逆元

给定 *n* 组 *ai* , *pi* ，其中 *pi* 是质数，求 *ai* 模 *pi* 的乘法逆元，若逆元不存在则输出 `impossible`。

**注意**：请返回在 0∼*p*−1 之间的逆元。

##### 乘法逆元的定义

> 若整数 *b*，*m* 互质，并且对于任意的整数 *a*，如果满足 *b*|*a*，则存在一个整数 *x*，使得 *a / b* ≡ *a* × *x*  ( mod *m* )，则称 *x* 为 *b* 的模 *m* 乘法逆元，记为 *b*^−1^ ( mod *m* ) 。
>
> *b* 存在乘法逆元的充要条件是 *b* 与模数 *m* 互质。当模数 *m* 为质数时，*b*^m−2^ 即为 *b* 的乘法逆元。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一个数组 *ai* , *pi* ，数据保证 *pi* 是质数。

#### 输出格式

输出共 *n* 行，每组数据输出一个结果，每个结果占一行。

若 *ai* 模 *pi* 的乘法逆元存在，则输出一个整数，表示逆元，否则输出 `impossible`。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

1 ≤ *ai* , *pi* ≤ 2 × 10^9



#### 输入样例：

```
3
4 3
8 5
6 3
```

#### 输出样例：

```
1
2
impossible
```



#### 算法思想：

**[定理]** （费马小定理）

若 p 是一个质数，而整数 a 不是 p 的倍数，则 $a^{p-1} ≡ 1\mod p$ 。

于是，求 a 的模 p 逆元即求 $a^{p-2}$ 。特别地，若 a 是 p 的倍数，输出 `“impossible”` 。

**[注]**

a 存在乘法逆元的充要条件是 a 与 p 互质。当 a 与 p 互质时，其乘法逆元为 $a^{p-2}$ 。



#### 算法1(236 ms)：

时间复杂度：O(n log p)。n, p 分别为问题规模，给定的质数 p 的最大值。

```c++
#include <iostream>

using namespace std;

int fme(long long a, int b, int p) {
    long long res = 1;
    while (b) {
        if (b & 1) {
            res = res * a % p;
        }
        a = a * a % p;
        b >>= 1;
    }
    
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        int a, p;
        cin >> a >> p;
        if (a % p == 0) {
            cout << "impossible" << endl;
        } else {
            cout << fme(a, p - 2, p) << endl;
        }
    }
}
```



## 8-4 拓展欧几里得算法

### 1.AcWing0877 扩展欧几里得算法

给定 *n* 对正整数 $a_i,b_i$ ，对于每对数，求出一组 $x_i,y_i$ ，使其满足 $a_i \times x_i +b_i \times y_i = gcd(a_i,b_i)$ 。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含两个整数 $a_i,b_i$ 。

#### 输出格式

输出共 *n* 行，对于每组$a_i,b_i$ ，求出一组满足条件的 $x_i,y_i$ ，每组结果占一行。

本题答案不唯一，输出任意满足条件的 $x_i,y_i$ 均可。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

1 ≤ $a_i,b_i$ ≤ 2×10^9



#### 输入样例：

```
2
4 6
8 18
```

#### 输出样例：

```
-1 1
-2 1
```



#### 裴蜀定理：

「裴蜀定理」，又称贝祖定理（Bézout's lemma）。是一个关于最大公约数的定理。其内容定义为：对于不全为零的任意整数 a 和 b，记二者的最大公约数为 g 即 gcd(a,b) = g，则对于任意整数 x 和 y 都一定满足 ax+by 是 g 的倍数。特别地，一定存在整数 x 和 y 的解，使得 ax+by=gcd(a,b) 成立。它的一个重要推论为：a,b互质的充分必要条件是存在整数x,y 使 ax+by=1; 或者说对于方程 ax+by=1 只有整数a和b互质时，方程才有整数解x,y。



#### 算法思想：

1. 当 $b=0$ 时，显然有唯一解 $x = 1,y = 0$ 。

2. 当 $b\neq 0$ 时，记 $g = gcd(a, b) = gcd(b, a\ mod\ b)$ 。假设：
   $$
   \begin{cases}
   a \times x + b \times y = g \\
   (a\ mod \ b) \times x' + b \times y' = g
   \end{cases}
   $$
   即
   $$
   \begin{cases}
   x \ \times a + y \times b = g \\
   x' \times a + (y' - \lfloor a / b \rfloor \times x')  \times b = g
   \end{cases}
   $$
   消去 g ， 得
   $$
   (x - x') \times a + (y - y' + \lfloor a / b \rfloor \times x') \times b = 0
   $$
   令
   $$
   \begin{cases}
   x = x' \\
   y = y' - \lfloor a/b \rfloor \times x'	\tag{*}
   \end{cases}
   $$
   则公式 `(*)` 即为递归求解时 $x, y$ 的一组递推公式。

3. 设 $x_0, y_0$ 为原方程 $a \times x + b \times y = g$ 的一组特解，则该易证该方程的通解为：
   $$
   \begin{cases}
     x = x_0 + k \times \frac{b}{g} \\
     y = y_0 - k \times \frac{a}{g} \\
   \end{cases}
   $$
   其中 $k$ 为任意整数。



#### 算法1(280 ms)：

时间复杂度：O(n log(min(a, b)))。

```c++
#include <iostream>

using namespace std;

void exgcd(int a, int b, int& x, int& y) {
    if (!b) {
        x = 1;
        y = 0;
        return;
    }
    
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        int a, b, x, y;
        cin >> a >> b;
        exgcd(a, b, x, y);
        cout << x << " " << y << endl;
    }
    
    return 0;
}
```





### 2.AcWing0878 线性同余方程

给定 *n* 组数据 $a_i,b_i,m_i$ ，对于每组数求出一个 $x_i$ ，使其满足 $a_i \times x_i \equiv b_i \  (mod\ m_i)$ ，如果无解则输出 `impossible`。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一组数据 $a_i,b_i,m_i$ 。

#### 输出格式

输出共 *n* 行，每组数据输出一个整数表示一个满足条件的 $x_i$ ，如果无解则输出 `impossible`。

每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。

输出答案必须在 `int` 范围之内。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

1 ≤ $a_i,b_i,m_i$ ≤ 2×10^9



#### 输入样例：

```
2
2 3 6
4 3 5
```

#### 输出样例：

```
impossible
-3
```



#### 算法思想：

线性同余方程
$$
a \times x \equiv b \  (mod\ m)	\tag{*}
$$
成立的充要条件是
$$
\exists (-y) \in N, a \times x = m \times (-y) + b
$$
即
$$
\exists (-y) \in N, a \times x + m \times y = b \tag{**}
$$
因此，若 $gcd(a,m)|b$ ，则原式有解，可以通过扩展欧几里得算法求解，得
$$
a \times x' + m \times y' = gcd(a, m)
$$
则
$$
x = b / gcd(a, m) \times x'
$$
否则，即 $gcd(a,m)|b$ 不成立时，原式无解。



#### 算法1(287 ms)：

时间复杂度：O(n log (min(a, m)))。n, a, m 分别为问题规模，每组数据给定的变量的系数，模数。

```c++
#include <iostream>

using namespace std;

int exgcd(int a, int b, int& x, int& y) {
	if (!b) {
		x = 1; y = 0;
		return a;
	}
	
	int ret = exgcd(b, a % b, y, x);
	y -= a / b * x;
	return ret;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n;
	cin >> n;
	
	while (n--) {
		int a, b, m, x, y;
		cin >> a >> b >> m;
		int g = exgcd(a, m, x, y);
		if (b % g) {
			cout << "impossible" << '\n';
		}
		else {
			x = (long long)x * b / g % m;
			cout << x << '\n';
		}
	}
	
	return 0;
}
```





### 3.AcWing0204 中国剩余定理

给定 2*n* 个整数 $m_1,m_2,...,m_n$ 和  $a_1,a_2,...,a_n$ ，求一个最小的非负整数 *x*，满足 $\forall i \in [1,n], x \equiv a_i (mod\ m_i)$ 。

#### 输入格式

第 1 行包含整数 *n* 。

第 2..*n*+1 行：每行包含两个整数 $m_i$ 和 $a_i$ ，数之间用空格隔开。

#### 输出格式

输出最小非负整数 *x* ，如果 *x* 不存在，则输出 −1 。

#### 数据范围

$1 \le m_i \le 2^{31} - 1$ ，

$0 \le a_i <m_i$ ，

$1 \le n \le 25$ ，

所有 $a_i$ 的最小公倍数在 64 位有符号整数范围内。



#### 输入样例：

```
2
8 7
11 9
```

#### 输出样例：

```
31
```



#### 中国剩余定理：

**[定理] （中国剩余定理）**

中国剩余定理是数论中的一个重要定理，它提供了一种解决一组模同余方程的方法。该定理的表述如下：

假设有一组整数 m1, m2, ..., mk 两两互质（即它们的最大公约数为1），而 b1, b2, ..., bk 是对应的任意整数。那么对于任意给定的整数 N，存在唯一的整数 x 满足下面的条件：

x ≡ b1 (mod m1)
x ≡ b2 (mod m2)
...
x ≡ bk (mod mk)

其中，≡ 表示模同余关系，即 x 与 bi 在模 mi 下同余。

中国剩余定理的应用非常广泛，特别是在密码学、编码理论和计算机算法中。它可以用于快速计算大数的模运算，例如求解模意义下的线性方程组，从而在很多应用中提高计算效率。

**[求解]**

假设存在一组整数 $m_1, m_2, ..., m_n$ 两两互质，而 $a_1, a_2, ...,a_n$ 是对应的任意整数，其中 $0 \le a_i < m_i$ 。有以下线性同余方程组：
$$
\begin{cases}
  x \equiv a_1 & (\bmod m_1)    \\	\tag{*}
  x \equiv a_2 & (\bmod m_2)    \\
  ... \\
  x \equiv a_n & (\bmod m_n)    \\
\end{cases}
$$
记 $M$ 为
$$
M = m_1 \times m_2 \times ... \times m_n
$$
记 $M_i = M / m_i$ ，易知： $M_i, m_i$ 互质。

记 $M_i ^{-1}$ 表示 $M_i$ 的模 $m_i$ 的乘法逆元。即 $M_i ^{-1}$ 满足：
$$
M_i \times M_i ^{-1} \equiv 1 (\bmod m_i)
$$
则，易证原线性同余方程组 `(*)` 的最小非负解为：
$$
x = a_1 M_1 M_1 ^{-1} + a_2 M_2 M_2 ^{-1} + ... + a_k M_k M_k ^{-1} \tag{**}
$$


#### 算法思想：

对于线性同余方程组：
$$
\begin{cases}
  x \equiv a_1 & (\bmod m_1)   \\  \tag{3*}
  x \equiv a_2 & (\bmod m_2)   \\
\end{cases}
$$
等价于
$$
x = k_1 \times m_1 + a_1 = k_2 \times m_2 + a_2, \exist k_1, k_2 \in N
$$
即
$$
k_1 \times m_1 - k_2 \times m_2 = - a_1 + a_2	\tag{4*}
$$
根据扩展欧几里得算法，假设 $k_1', k_2'$ 满足：
$$
k_1' m_1 + k_2' m_2 = gcd(m_1, m_2)
$$
则方程 `(4*)` 有解的充要条件为 $gcd(m_1, m_2) | (a_2 - a_1)$ 。假设有解，则易知其通解为：
$$
\begin{cases}
  k_1 = k_1'' + k \times m_2 / gcd(m_1, m_2)   \\
  k_2 = k_2'' + k \times m_1 / gcd(m_1, m_2)   \\	\tag{5*}
\end{cases}
$$
其中 $k$ 为任意整数，且
$$
\begin{cases}
   k_1'' = k_1' \times \frac{a_2 - a_1}{gcd(m_1, m_2)}   \\
   k_2'' = -k_2' \times \frac{a_2 - a_1}{gcd(m_1, m_2)}   \\
\end{cases}
$$
则方程 `(3*)` 的通解为：
$$
x = k_1 m_1 + a_1 = k_1'' m_1 + a_1 + k m_1 m_2 /gcd(m_1, m_2)
$$
记 $a_{1..2} = k_1'' m_1 + a_1, \ m_{1..2} = m_1 m_2 / gcd(m_1, m_2)$ ，其中 $m_{1..2} = lcm(m_1, m_2) $ 为 Least Common Multiple 。则方程 `(3*)` 的通解为：
$$
x = k m_{1..2} + a_{1..2}, \forall k \in N
$$
也即是：
$$
x \equiv a_{1..2} (\bmod m_{1..2})	\tag{5*}
$$
将方程 `(5*)` 加入原方程组 `(*)` 中，取代方程组 `(3*)` ，迭代 `n - 1` 轮，即可求得最终解。

对于第 $i(i=1,2,\dots,n-1)$ 轮，方程组为：
$$
\begin{cases}
	x \equiv a_{1..i}(\bmod m_{1..i})	\\
	x \equiv a_{i+1}(\bmod m_{i+1})		\\
\end{cases}
$$
其解为：
$$
x = a_{1..i+1} (\bmod m_{1..i+1})
$$
其中
$$
\begin{cases}
	a_{1..i+1} = k_1 m_{1..i} + a_{1..i}	\\ 
	m_{1..i+1} = m_{1..i}m_{i+1} / gcd(m_{1..i}, m_{i+1})	\\
\end{cases}
$$


因此，最终解为
$$
x \equiv a_{1..n} (\bmod m_{1..n})
$$



#### 算法过程：

1. 一对变量 `<m1, a1>` 维护一个线性同余方程 $x \equiv a_1 (\bmod m_1)$ 。进行 `n - 1` 轮迭代，每轮迭代加入一个线性同余方程 $x \equiv a_2 (\bmod m_2)$ ，联立方程组并求解，将结果保存回 `<m1, a1>` 。若方程组无解，则置标记并退出迭代。

   解方程组的过程如下：

   - 调用扩展欧几里得算法求得方程 $k_1' m_1 + k_2' m_2 = gcd(m_1, m_2)$ 的解 $k_1', k_2'$ ，并求得 $g = gcd(m_1, m_2)$ 。
   - 判断方程组是否有解。若 $g | (a_2 - a_1)$ 则有解，继续执行下一步。否则无解，则置标记并退出迭代。
   - 此时方程组有解。首先，求得方程 $k_1' m_1 - k_2' m_2 = a_2 - a_1$ 的特解 $k_{0,1} = k_1' * (a_2 - a_1) / g$ 。以防内存溢出，我们利用通解公式 $k_1 = k_{0,1} + k \times m_2 / g，\forall k \in N$ ，将 $k_1$ 的解转化为最小非负特解，即 $k_{min-non-neg,1} = k_1 \bmod (m_2 / g)$ 。
   - 最终，把计算结果压回 `<m1, a1>` 中。方程的解为 $m_{1..2} = m_1 m_2 /g，a_{1..2} = k_{min-non-neg,1} a_1 + m_1$  。

2. 当 `n - 1` 轮迭代结束后，求解方程 $x \equiv a_1 (\bmod m_1)$ 得最终的最小非负解，即 $x = a_1 \bmod m_1$ 。



#### 算法1(12 ms)：

时间复杂度：O(n log (min(m1, m2)))。

```c++
#include <iostream>

using namespace std;

using LL = long long;

LL exgcd(LL a, LL b, LL& x, LL& y) {
	if (!b) {
		x = 1; y = 0;
		return a;
	}
	
	LL ret = exgcd(b, a % b, y, x);
	y -= a / b * x;
	return ret;
}

LL m1, a1;

bool evaluate(LL m2, LL a2) {
	LL k1, k2, g = exgcd(m1, m2, k1, k2);
	if ((a2 - a1) % g) {
		return false;
	}
	
	LL t = m2 / g;
	k1 = (k1 % t) * ((a2 - a1) / g % t);
	k1 = (k1 % t + t) % t;
	
	a1 += k1 * m1;	// 能否保证此处 a1 不会溢出？ -03/26/24
	m1 *= t;
	a1 %= m1;
	return true;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n;
	cin >> n >> m1 >> a1;
	a1 %= m1;
	
	while (--n) {
		int m2, a2;
		cin >> m2 >> a2;
		if (!evaluate(m2, a2)) {
			break;
		}
	}
	
	cout << (n ? -1 : a1);
	
	return 0;
}
```





## 8-5 高斯消元

### 1.AcWing0883 高斯消元解线性方程组

输入一个包含 *n* 个方程 *n* 个未知数的线性方程组。

方程组中的系数为实数。

求解这个方程组。

以下为一个包含 *m* 个方程 *n* 个未知数的线性方程组示例：
$$
\begin{cases}
a_{11} x_1 + a_{12} x_2 + ... + a_{1n} x_n = b_1	\\
a_{21} x_1 + a_{22} x_2 + ... + a_{2n} x_n = b_2	\\
...	\\
a_{m1} x_1 + a_{m2} x_2 + ... + a_{mn} x_n = b_m	\\
\end{cases}
$$

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含 *n*+1 个实数，表示一个方程的 *n* 个系数以及等号右侧的常数。

#### 输出格式

如果给定线性方程组存在唯一解，则输出共 *n* 行，其中第 *i* 行输出第 *i* 个未知数的解，结果保留两位小数。

注意：本题有 SPJ，当输出结果为 `0.00` 时，输出 `-0.00` 也会判对。在数学中，一般没有正零或负零的概念，所以严格来说应当输出 `0.00`，但是考虑到本题作为一道模板题，考察点并不在于此，在此处卡住大多同学的代码没有太大意义，故增加 SPJ，对输出 `-0.00` 的代码也予以判对。

如果给定线性方程组存在无数解，则输出 `Infinite group solutions`。

如果给定线性方程组无解，则输出 `No solution`。

#### 数据范围

1 ≤ *n* ≤ 100 ,

所有输入系数以及常数均保留两位小数，绝对值均不超过 100 。



#### 输入样例：

```
3
1.00 2.00 -1.00 -6.00
2.00 1.00 -3.00 -9.00
-1.00 -1.00 2.00 7.00
```

#### 输出样例：

```
1.00
-2.00
3.00
```



#### 算法1-高斯消元(52 ms)：

时间复杂度：O(n ^ 3)。n 为方程组的个数。

```c++
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 100;
const double EPS = 1e-8;

int n;
double matrix[N][N + 1];

int gauss() {
	int rank = 0;
	for (int col = 0; col < n; col++) {
		// 1. 找到主元绝对值最大的行, 换至当前行
		int k = rank;
		for (int i = k + 1; i < n; i++) {
			if (fabs(matrix[i][col]) > fabs(matrix[k][col])) {
				k = i;
			}
		} 
		
		if (fabs(matrix[k][col]) < EPS) {
			continue;
		}
		
		for (int j = col; j <= n; j++) {
			swap(matrix[k][j], matrix[rank][j]);
		}
		
		// 2. 主元归一, 向下消元
		for (int j = n; j >= col; j--) {
			matrix[rank][j] /= matrix[rank][col];
		}
		
		for (int i = rank + 1; i < n; i++) {
			for (int j = n; j >= col; j--) {
				matrix[i][j] -= matrix[rank][j] * matrix[i][col];
			}
		}
		
		rank++;
	}
	
	// 满秩, 有唯一解 
	if (rank == n) {
		// 参数向上回代
		for (int col = n - 1; col >= 0; col--) {
		    if (fabs(matrix[col][n]) < EPS) {
				matrix[col][n] = 0.0;
			}
			for (int i = col - 1; i >= 0; i--) {
				matrix[i][n] -= matrix[col][n] * matrix[i][col];
			}
		} 
		
		return rank;
	}
	
	// 系数阵的秩小于增广阵的秩, 无解 
	for (int i = rank; i < n; i++) {
		if (fabs(matrix[i][n]) > EPS) {
			return -1;
		}
	}
	
	// 系数阵与增广阵等秩, 无穷组解 
	return rank;
}

int main() {
	scanf("%d", &n);
	
	for (int i = 0; i < n; i++) {
		for (int j = 0; j <= n; j++) {
			scanf("%lf", &matrix[i][j]);
		}
	}
	
	int ret = gauss();
	if (ret == n) {
		for (int i = 0; i < n; i++) {
			printf("%.2lf\n", matrix[i][n]);
		}
	}
	else if (ret >= 0) {
		printf("Infinite group solutions\n");
	}
	else {
		printf("No solution\n");
	}
	
	return 0;
}
```



```c++
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 100;
const double EPS = 1e-8;

int n;
double matrix[N][N + 1];

int gauss() {
	int rank = 0;
	for (int col = 0; col < n; col++) {
		// 1. 找到主元绝对值最大的行, 换至当前行
		int k = rank;
		for (int i = k + 1; i < n; i++) {
			if (fabs(matrix[i][col]) > fabs(matrix[k][col])) {
				k = i;
			}
		} 
		
		if (fabs(matrix[k][col]) < EPS) {
			continue;
		}
		
		for (int j = col; j <= n; j++) {
			swap(matrix[k][j], matrix[rank][j]);
		}
		
		// 2. 主元归一, 向下消元
		for (int j = n; j >= col; j--) {
			matrix[rank][j] /= matrix[rank][col];
		}
		
		printf("%d %.2lf\n", rank, matrix[rank][col]);      // matrix[rank][col] == 1.00
		
		for (int i = rank + 1; i < n; i++) {
			for (int j = col; j <= n; j++) {
				matrix[i][j] -= matrix[rank][j] * matrix[i][col];
			}
		}

		// 向下消元
		for (int i = rank + 1; i < n; i++) {
			double rate = matrix[i][col] / matrix[rank][col];
			for (int j = col; j <= n; j++) {
			    matrix[i][j] -= matrix[rank][j] * rate;
			}
		}
		
		rank++;
	}
	
	// 满秩, 有唯一解 
	if (rank == n) {
		// 参数向上回代
		for (int col = n - 1; col >= 0; col--) {
		    if (fabs(matrix[col][n]) < EPS) {
				matrix[col][n] = 0.0;
			}
			for (int i = col - 1; i >= 0; i--) {
				matrix[i][n] -= matrix[col][n] * matrix[i][col];
			}
		} 
		
		return rank;
	}
	
	// 系数阵的秩小于增广阵的秩, 无解 
	for (int i = rank; i < n; i++) {
		if (fabs(matrix[i][n]) > EPS) {
			return -1;
		}
	}
	
	// 系数阵与增广阵等秩, 无穷组解 
	return rank;
}

int main() {
	scanf("%d", &n);
	
	for (int i = 0; i < n; i++) {
		for (int j = 0; j <= n; j++) {
			scanf("%lf", &matrix[i][j]);
		}
	}
	
	int ret = gauss();
	if (ret == n) {
		for (int i = 0; i < n; i++) {
			printf("%.2lf\n", matrix[i][n]);
		}
	}
	else if (ret >= 0) {
		printf("Infinite group solutions\n");
	}
	else {
		printf("No solution\n");
	}
	
	return 0;
}
```



### 2.AcWing0884 高斯消元解异或方程组

输入一个包含 *n* 个方程 *n* 个未知数的异或线性方程组。

方程组中的系数和常数为 0 或 1，每个未知数的取值也为 0 或 1 。

求解这个方程组。

异或线性方程组示例如下：

```
M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]
M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]
…
M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n]
```

其中 `^` 表示异或(XOR)，`M[i][j]` 表示第 *i* 个式子中 *x*[*j*] 的系数，*B*[*i*] 是第 *i* 个方程右端的常数，取值均为 0 或 1 。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含 *n*+1 个整数 0 或 1，表示一个方程的 *n* 个系数以及等号右侧的常数。

#### 输出格式

如果给定线性方程组存在唯一解，则输出共 *n* 行，其中第 *i* 行输出第 *i* 个未知数的解。

如果给定线性方程组存在多组解，则输出 `Multiple sets of solutions`。

如果给定线性方程组无解，则输出 `No solution`。

#### 数据范围

1 ≤ *n* ≤ 100



#### 输入样例：

```
3
1 1 0 1
0 1 1 0
1 0 0 1
```

#### 输出样例：

```
1
0
0
```



#### 算法1(28 ms)：

时间复杂度：O(n ^ 3)。 n 为方程的个数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100;

int n;
bool matrix[N][N + 1];

int gauss() {
	int rank = 0;
	for (int col = 0; col < n; col++) {
		// 1. 找到主元不为 0 的行, 换到当前行 
		int k = rank;
		while (k < n && !matrix[k][col]) {
			k++;
		}
		
		if (!matrix[k][col]) {
			continue;
		}
		
		for (int j = col; j <= n; j++) {
			swap(matrix[k][j], matrix[rank][j]);
		}
		
		// 2. 向下消元
		for (int i = rank + 1; i < n; i++) {
			for (int j = n; j >= col; j--) {
				matrix[i][j] ^= matrix[i][col] * matrix[rank][j];
			}
		}
		
		rank++; 
	}
	
	if (rank == n) {
		// 向上回代参数
		for (int col = n - 1; col; col--) {
			for (int i = col - 1; i >= 0; i--) {
				matrix[i][n] ^= matrix[i][col] * matrix[col][n];
			}
		} 
		
		return rank;
	}
	
	for (int i = rank; i < n; i++) {
		if (matrix[i][n]) {
			return -1;
		}
	}
	
	return rank;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j <= n; j++) {
			cin >> matrix[i][j];
		}
	}
	
	int ret = gauss();
	if (ret == n) {
		for (int i = 0; i < n; i++) {
			cout << matrix[i][n] << '\n';
		}
	}
	else if (ret >= 0) {
		cout << "Multiple sets of solutions" << '\n';
	}
	else {
		cout << "No solution" << '\n';
	}
	
	return 0;
}
```





## 8-6 组合数

### 1.AcWing0885 求组合数 I

给定 *n* 组询问，每组询问给定两个整数 *a*，*b*，请你输出 $C_a ^b \bmod (10^9 + 7)$ 的值。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一组 *a* 和 *b*。

#### 输出格式

共 *n* 行，每行输出一个询问的解。

#### 数据范围

1 ≤ *n* ≤ 10000 ,

1 ≤ *b* ≤ *a* ≤ 2000



#### 输入样例：

```
3
3 1
5 3
2 2
```

#### 输出样例：

```
3
10
1
```



#### 算法思想：

利用递推式：
$$
C_a ^b =
\begin{cases}
1, & b = 0	\\
C_{a-1} ^b + C_{a-1} ^{b-1}, & 1 \le b \le a

\end{cases}
$$
预处理出满足 $0 \le b \le a \le 2000$ 的所有组合数。每次查询，通过查表返回结果。



#### 算法1(161 ms)：

时间复杂度：O(N ^ 2)。其中 N 为 a 的最大取值（本题为 `2000` ）。每次查询的时间复杂度为 O(1)。

```c++
#include <iostream>

using namespace std;

const int N = 2000, MOD = 1e9 + 7;

int n, comb[N + 1][N + 1];

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	for (int a = 0; a <= N; a++) {
		for (int b = 0; b <= a; b++) {
			comb[a][b] = b ? (comb[a - 1][b - 1] + comb[a - 1][b]) % MOD : 1;
		}
	}
	
	cin >> n;
	while (n--) {
		int a, b;
		cin >> a >> b;
		cout << comb[a][b] << '\n';
	}
	
	return 0;
}
```







### 2.AcWing0886 求组合数 II

给定 *n* 组询问，每组询问给定两个整数 *a*，*b*，请你输出 $C_a ^b \bmod (10^9 + 7)$ 的值。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一组 *a* 和 *b*。

#### 输出格式

共 *n* 行，每行输出一个询问的解。

#### 数据范围

1 ≤ *n* ≤ 10000 ,

1 ≤ *b* ≤ *a* ≤ 10^5



#### 输入样例：

```
3
3 1
5 3
2 2
```

#### 输出样例：

```
3
10
1
```



#### 算法思想：

对于公式：
$$
C_a ^b = \frac{a!}{b! (a - b)!} = a! \times \frac{1}{b!} \times \frac{1}{(a-b)!}
$$
我们预处理出所有阶乘的值 $fact(a) = a!$ ，并使用快速模幂运算预处理它们的乘法逆元 $infact(a) = fact(a)^{-1} (\bmod (10^9 + 7))$ 。对于每次查询，通过如下公式进行计算：
$$
C_a ^b = fact(a) \times infact(b) \times infact(a-b) (\bmod (10^9 + 7))
$$
其中，阶乘及其逆元 $fact(a), infact(a)$ 的递推公式分别为：
$$
fact(a) = 
\begin{cases}
1 &, a = 0	\\
fact(a-1) \times a & ,a > 0	\\
\end{cases}\\

infact(a) = 
\begin{cases}
1 &, a = 0	\\
infact(a-1) \times a^{-1} &, a > 0	\\
\end{cases}\\
$$



#### 算法1(299 ms)：

时间复杂度：O(N log M)。其中 n 为 a 的最大取值（本题为 `1e5` ）， M 为模数(本题为 `1e9 + 7`) 。每次查询的时间为 O(1)。

```c++
#include <iostream>

using namespace std;

const int N = 1e5, MOD = 1e9 + 7;

int fact[N + 1], infact[N + 1];

int inv(long long a) {
	int b = MOD - 2, res = 1;
	while (b) {
		if (b & 1) {
			res = res * a % MOD;
		}
		a = a * a % MOD;
		b >>= 1;
	}
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	fact[0] = infact[0] = 1;
	for (int i = 1; i <= N; i++) {
		fact[i] = (long long)fact[i - 1] * i % MOD;
		infact[i] = inv(fact[i]);
	}
	
	int n;
	cin >> n;
	
	while (n--) {
		int a, b;
		cin >> a >> b;
		cout << (long long)fact[a] * infact[b] % MOD * infact[a - b] % MOD << '\n';
	}
	
	return 0;
}
```




#### 算法2(653 ms)：

时间复杂度：O(N log M)。其中 n 为 a 的最大取值（本题为 `1e5` ）， M 为模数(本题为 `1e9 + 7`) 。每次查询的时间为 O(1)。

如果将快速模幂运算中的模数 p 换成变量 MOD ，时间开销为 350 ms。

```c++
#include <iostream>

using namespace std;

const int N = 1e5, MOD = 1e9 + 7;

int fact[N + 1], infact[N + 1];

int fme(long long a, int b, int p) {
    int res = 1;
    while (b) {
        if (b & 1) {
            res = res * a % p;		// p 换成 MOD, 速度快 1 倍
        }
        
        a = a * a % p;				// p 换成 MOD, 速度快 1 倍
        b >>= 1;
    }
    
    return res;
}



int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    fact[0] = infact[0] = 1;
    for (int i = 1; i <= N; ++i) {
        fact[i] = (long long)fact[i - 1] * i % MOD;
        infact[i] = fme(fact[i], MOD - 2, MOD);
    }
    
    int n;
    cin >> n;
    
    while (n--) {
        int a, b;
        cin >> a >> b;
        cout << (long long)fact[a] * infact[b] % MOD * infact[a - b] % MOD << endl;
    }
    
    return 0;
}
```

注：chatGPT - 03/27/24

**取模优化(Modulus Optimization)**：当编译器知道一个变量是常量，并且取模的模数也是常量时，它可以利用这些信息进行取模运算的优化。例如，编译器可能会使用位运算或其他更高效的方法来计算取模结果。

**模数预处理**：如果模数是一个常量，并且算法中需要多次取模运算，可以在编译时或运行时预先计算模数的倒数或逆元，以便将取模运算转换为乘法运算。这样可以减少取模操作的次数，提高执行效率。





### 3.AcWing0887 求组合数 III

给定 *n* 组询问，每组询问给定两个整数 $a, b, p$ ，其中 $p$ 是质数，请你输出 $C_a ^b \bmod p$ 的值。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n* 行，每行包含一组 $a, b, p$ 。

#### 输出格式

共 *n* 行，每行输出一个询问的解。

#### 数据范围

$1 \le n \le 20,$

$1 \le b \le a \le 10^{18},$

$1 \le p \le 10^5$



#### 输入样例：

```
3
5 3 7
3 1 5
6 4 13
```

#### 输出样例：

```
3
3
2
```



#### 卢卡斯定理：

卢卡斯定理（Lucas' Theorem）是组合数学中的一个重要定理，它提供了一种计算组合数取模的方法。卢卡斯定理的内容如下：

给定两个非负整数 n 和 m，以及一个质数 p，我们可以将 n 和 m 写成它们在 p 进制下的展开形式：

$$
n = n_k p^k + n_{k-1} p^{k-1} + \ldots + n_1 p + n_0	\\
m = m_k p^k + m_{k-1} p^{k-1} + \ldots + m_1 p + m_0	\\
$$
其中，$0 \leq n_i, m_i < p, 0 \leq i \leq k$ 。

卢卡斯定理的主要内容是：

$$
C(n, m) \equiv \prod_{i=0}^{k} C(n_i, m_i) \mod p
$$
其中，$C(n, m)$ 表示组合数 $C(n, m) = \binom{n}{m}$ ，即从 n 个不同元素中选取 m 个元素的组合数。 $C(n_i, m_i)$ 表示相应的 p 进制展开形式中的数字 $n_i$ 和 $m_i$ 的组合数。

卢卡斯定理的应用使得在计算大数的组合数时，可以先将大数分解成对应位上的小数，然后分别计算每一位上的组合数，最后根据定理的等价关系，将每一位上的组合数的结果相乘，最终取模得到结果。这样可以极大地简化计算的复杂度，提高计算效率。

卢卡斯定理在密码学、编程竞赛等领域有着广泛的应用，特别是在需要大数取模运算的场景中，能够帮助高效地解决组合数问题。

**[证明]** （卢卡斯定理）

假设 $p$ 为质数，整数 $a, b$ 分别可以写成 $p$ 进制展开形式：
$$
a = a_k p^k + a_{k-1} p^{k-1} + \ldots + a_1 p^1 + a_0 p^0	\\
b = b_k p^k + b_{k-1} p^{k-1} + \ldots + b_1 p^1 + b_0 p^0	\\
$$
其中，$0 \leq a_i, b_i < p, 0 \leq i \leq k$ 。

对多项式 $(1 + x)^p$ 进行二项式展开：
$$
(1+x)^p = C_p^0 x^0 + C_p^1 x^1 + \ldots + C_p^{p-1} x^{p-1} + C_p^p x^{p}
$$
由于 $p$ 为质数，易知
$$
C_p^i \equiv 0 \mod p, \forall i = 1,2,\ldots,p-1
$$
于是
$$
(1+x)^p \equiv 1 + x^p \mod p	\tag{*}
$$
利用定理 `(*)` ，接下来，我们对 $(1+x)^a$ 进行二项式展开，得
$$
\begin{align}
 (1+x)^a &= (1+x)^{a_0} \times (1+x)^{a_1 p^1} \times \ldots (1+x)^{a_{k-1} p^{k-1}} \times (1+x)^{a_k p^k}	 \\
         &\equiv (1+x)^{a_0} \times (1+x^{p})^{a_1} \times \ldots (1+x^{p^{k-1}})^{a_{k-1}} \times (1+x^{p^k})^{a_k} \mod p	 \\
\end{align}
$$
比较等式两侧 $x^b$ 项，得：
$$
C_a^b x^b \equiv C_{a_k}^{b_k} C_{a_{k-1}}^{b_{k-1}} \ldots C_{a_1}^{b_1} C_{a_0}^{b_0} 
x^{b_k p^k + b_{k-1} p^{k-1} + \ldots + b_1 p^1 + b_0 p^0} \mod p
$$
即
$$
C_a ^b \equiv C_{a_k}^{b_k} C_{a_{k-1}}^{b_{k-1}} \ldots C_{a_1}^{b_1} C_{a_0}^{b_0}  \mod p	\tag{**}
$$




#### 算法思想：

从定理 `(**)` 得到如下公式：
$$
C_a ^b \equiv C_{a \bmod p} ^{b \bmod p} \times C_{a / p} ^{b / p}	\mod p
$$
可以写作如下递推形式：
$$
C_a^b \equiv 
\begin{cases}
C_a^b &, 0 \leq b \leq a < p	\\
C_{a/p} ^{b/p} \times C_{a \bmod p} ^{b \bmod p} &, \text{other cases}
\end{cases}
$$
当 $0 \leq b \leq a < p$ 时，可以利用如下递推式求 $C_a^b$ ：
$$
C_a^b = 
\begin{cases}
	1 &, b = 0	\\
	0 &, b > a	\\
	a/b \times C_{a-1} ^{b-1} &, 1 \leq b \leq a < p	\\
\end{cases}
$$


#### 算法1(64 ms)：

时间复杂度： $O(nplog_pN)$ 。其中 n 为询问的组数，p 为给定的模数，N 为 a, b 的最大取值。每次查询，需要递归调用 lucas() 函数 O($log_pN$) 次，每次需要调用一次 comb() 函数，后者时间开销为 O($p+log_2p$) ， 即 $O(p)$ 。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

// 快速幂求 a 的模 p 乘法逆元
int fme(long long a, int b, int p) {
    int res = 1;
    while (b) {
        if (b & 1) {
            res = res * a % p;
        }
        a = a * a % p;
        b >>= 1;
    }
    
    return res;
}

// 求模 p 组合数 C(a, b)
int comb(int a, int b, int p) {
    if (b > a) {
        return 0;
    }
    
    b = min(b, a - b);
    
    long long nume = 1, deno = 1;     // numerator and denominator
    for (int i = 0; i < b; ++i) {
        nume = nume * (a - i) % p;
        deno = deno * (i + 1) % p;
    }
    
    return (long long)nume * fme(deno, p - 2, p) % p;
}

// lucas 递推
int lucas(long long a, long long b, int p) {
    if (a < p && b < p) {
        return comb(a, b, p);
    }
    
    return (long long)comb(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        long long a, b;
        int p;
        cin >> a >> b >> p;
        cout << lucas(a, b, p) << endl;
    }
    
    return 0;
}
```



#### 算法2(54 ms)：

这是一段错误的代码，但是能通过全部的 11 组测试样例，特此留念。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

// 快速幂求 a 的模 p 乘法逆元
int fme(long long a, int b, int p) {
    int res = 1;
    while (b) {
        if (b & 1) {
            res = res * a % p;
        }
        a = a * a % p;
        b >>= 1;
    }
    
    return res;
}

// 求模 p 组合数 C(a, b)
int comb(int a, int b, int p) {		// 这里有 BUG
    b = min(b, a - b);
    
    long long nume = 1, deno = 1;     // numerator and denominator
    for (int i = 0; i < b; ++i) {
        nume = nume * (a - i) % p;
        deno = deno * (i + 1) % p;
    }
    
    return (long long)nume * fme(deno, p - 2, p) % p;
}

// lucas 递推
int lucas(long long a, long long b, int p) {
    if (a <= p && b < p) {			// 这里有点瑕疵
        return comb(a, b, p);
    }
    
    return (long long)comb(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        long long a, b;
        int p;
        cin >> a >> b >> p;
        cout << lucas(a, b, p) << endl;
    }
    
    return 0;
}
```





### 4.AcWing0888 求组合数 IV

输入 *a*,*b*，求 $C_a^b$ 的值。

注意结果可能很大，需要使用高精度计算。

#### 输入格式

共一行，包含两个整数 *a* 和 *b* 。

#### 输出格式

共一行，输出 $C_a^b$ 的值。

#### 数据范围

$1 \leq b \leq a \leq 5000$



#### 输入样例：

```
5 3
```

#### 输出样例：

```
10
```



#### 算法思想：

1. 根据算术基本定理，假设阶乘 $n!$ 的质因子式为
   $$
   n! = p_1 ^{a_1} p_2 ^{a_2} \ldots p_k ^{a_k}
   $$
   则，易知质因子 $p_i(1 \leq i \leq k)$ 的指数 $a_k$ 满足：
   $$
   a_k = \lfloor n/p \rfloor + \lfloor n/p^2 \rfloor + \ldots + \lfloor n/p^{a_k} \rfloor	\tag{*}
   $$
   定义一个函数 `int getAlpha(int n, int p)` ，给定一个整数 n 和一个质因子 p ，返回阶乘 n! 中质因子的指数 a 。

2. 根据组合式
   $$
   C_a ^b = \frac{a!}{b!(a-b)!}
   $$
   利用函数 `get()` 分别求得 $C_a^b$ 中各个质因子 p 的指数 `get(a, p) - get(b, p) - get(a - b, p)` 。

3. 最后使用高精度乘法将这些质因子相乘，即得最终答案。





#### 算法1(27 ms)：

1. 调用 `gePrimes(a)` ，获取 1..a 中的所有质数，也即是 $C_a^b$ 的所有质因子。时间开销为：O(n)。
2. 遍历所有的质数，获取所有质因子的指数 `alpha` ，时间开销为：O($ln p \times log_p n$) ，即 O(log n) 。
3. 遍历所有的质因子，将他们相乘，每个质因子称对应指数次。时间开销为：（不会算>=_=<）。

```c++
#include <iostream>
#include <vector>

using namespace std;

const int N = 5000;

int primes[N + 1], idx;
bool vis[N + 1];

int get_alpha(int n, int p) {
	int res = 0;
	while (n) {
		res += n /= p;
	}
	
	return res;
}

void mul(vector<int>& res, int b) {
	int prod = 0;
	for (int i = 0; i < res.size(); i++) {
		prod += res[i] * b;
		res[i] = prod % 10;
		prod /= 10;
	}
	
	while (prod) {
		res.push_back(prod % 10);
		prod /= 10;
	}
}

void comb(vector<int>& res, int a, int b) {
	for (int i = 2; i <= a; i++) {
		if (!vis[i]) {
			primes[idx++] = i;
			int cnt = get_alpha(a, i) - get_alpha(b, i) - get_alpha(a - b, i);
			while (cnt--) {
				mul(res, i);
			}
		}
		
		for (int j = 0; primes[j] <= a / i; j++) {
			vis[i * primes[j]] = true;
			if (i % primes[j] == 0) {
				break;
			}
		}
	}
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int a, b;
	cin >> a >> b;
	
	vector<int> res{1};
	comb(res, a, b);
	
	for (int i = res.size() - 1; i >= 0; i--) {
		cout << res[i];
	}
	
	return 0;
} 
```



#### 算法2(535 ms)：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void mul(vector<int>& res, int b) {
	int prod = 0;
	for (int i = 0; i < res.size(); i++) {
		prod += res[i] * b;
		res[i] = prod % 10;
		prod /= 10;
	}
	
	while (prod) {
		res.push_back(prod % 10);
		prod /= 10;
	}
}

void div(vector<int>& res, int b) {
	int rem = 0;
	for (int i = res.size() - 1; i >= 0; i--) {
		rem = rem * 10 + res[i];
		res[i] = rem / b;
		rem %= b;
	}
	
	while (!res.back()) {
		res.pop_back();
	}
}

void comb(vector<int>& res, int a, int b) {
	b = min(b, a - b);
	
	for (int i = a; i > a - b; i--) {
		mul(res, i);
	}
	
	for (int i = b; i; i--) {
		div(res, i);
	}
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int a, b;
	cin >> a >> b;
	
	vector<int> res{1};
	comb(res, a, b);
	
	for (int i = res.size() - 1; i >= 0; i--) {
		cout << res[i];
	}
	
	return 0;
}
```





### 5.AcWing0889 卡特兰数

给定 *n* 个 0 和 *n* 个 1，它们将按照某种顺序排成长度为 2*n* 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。

输出的答案对 10^9+7 取模。

#### 输入格式

共一行，包含整数 *n* 。

#### 输出格式

共一行，包含一个整数，表示答案。

#### 数据范围

1 ≤ *n* ≤ 10^5



#### 输入样例：

```
3
```

#### 输出样例：

```
5
```



#### 卡特兰数：

卡特兰数（Catalan numbers）是组合数学中一类非常重要的数列，以法国数学家欧仁·查尔斯·卡特兰（Eugène Charles Catalan）的名字命名。卡特兰数在各种组合计数问题中起着关键作用，包括合法的括号序列、凸多边形的三角剖分、折叠多边形、二叉树的计数等等。

卡特兰数的递推关系式为：

\[$C_0 = 1$\]
\[$C_{n+1} = \sum_{i=0}^{n} C_i \cdot C_{n-i} \quad \text{for } n \geq 0$\]

其中，\($C_n$\) 表示第 \(n\) 个卡特兰数。

卡特兰数的计算也可以通过闭式公式进行。第 \(n\) 个卡特兰数可以表示为：

\[$C_n = \frac{1}{n+1}\binom{2n}{n}$\]

卡特兰数的一些常见应用包括：

1. 括号匹配：卡特兰数给出了合法的括号序列的数量，这在编译器设计、组合数学和计算机科学中都有广泛应用。

2. 二叉树计数：卡特兰数也表示了具有 n 个节点的二叉树的数量。

3. 凸多边形三角剖分：给定 n 个顶点的凸多边形，通过将多边形分割成三角形，卡特兰数给出了不同三角剖分的数量。

4. 折叠多边形：在平面上给定 n 条直线，使得直线与直线之间只有交叉点，而没有交叉线段的情况下，卡特兰数给出了不同折叠多边形的数量。

卡特兰数在组合计数问题中的广泛应用使得它成为组合数学中的重要概念之一，对于解决许多具有实际意义的问题提供了有力的工具。



#### 算法思想：

在平面直角坐标系中，假设 0 表示向 x 轴正方向移动一个单位长度， 1 表示向 y 轴正方向移动一个单位长度。则一个由 n 个 0 和 n 个 1 组成的序列可以与一条从 (0, 0) 到 (n, n) 的沿网格移动的长度为 2n 的路径一一对应。

对于满足任意前缀序列中 0 的个数都不少于 1 的个数的序列，其在网格中对应的路径上的所有点都应当满足 $y \leq x$ 。

- 从 (0, 0) 到 (n, n) 的长度为 2n 的路径数目为 $C_{2n}^n$ 。
- 对于一条从 (0, 0) 到 (n, n) 的长度为 2n 且经过直线 $y = x + 1$ 路径 p ，我们将 p 首次经过直线 $y = x + 1$ 的点的后半部分路径关于直线 $y = x + 1$ 作轴对称，于是，新的路径的终点为 (n - 1, n + 1) 。易知，所有满足条件且经过直线 $y = x + 1$ 的路径 p 都能与一条从 (0, 0) 到 (n - 1, n + 1) 的路径形成一一映射，其总的路径数目为 $C_{2n}^{n-1}$ 。

综上所述，所有满足路径上所有点均满足 $y \leq x$ 的路径的数量为
$$
Catalan_n = C_{2n}^n - C_{2n}^{n-1}	\tag{*}
$$
利用组合数公式，经过推导，得第 n 个 Catalan 数 $C_n$ 为
$$
C_n = \frac{(2n)!}{n!(n+1)!} = \frac{1}{n+1} C_{2n}^n	\tag{**}
$$






#### 算法1(17 ms)：

时间复杂度：O(n)。n 为问题规模。

```c++
#include <iostream>

using namespace std;

const int MOD = 1e9 + 7;

int inv(long long a) {
	int res = 1, b = MOD - 2;
	while (b) {
		if (b & 1) {
			res = res * a % MOD;
		}
		a = a * a % MOD;
		b >>= 1;
	}
	
	return res;
}

int catalan(int n) {
	int a = 2 * n, nume = 1, deno = 1;
	for (int i = 0; i < n; i++) {
		nume = (long long)nume * (a - i) % MOD;
		deno = (long long)deno * (i + 1) % MOD;
	}
	
	deno = (long long)deno * (n + 1) % MOD;
	return (long long)nume * inv(deno) % MOD;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n;
	cin >> n;
	
	cout << catalan(n);
	
	return 0;
}
```







## 8-7 博弈论

### 1.AcWing0891 Nim游戏

给定 *n* 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

#### 输入格式

第一行包含整数 *n* 。

第二行包含 *n* 个数字，其中第 *i* 个数字表示第 *i* 堆石子的数量。

#### 输出格式

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

1 ≤ 每堆石子数 ≤ 10^9



#### 输入样例：

```
2
2 3
```

#### 输出样例：

```
Yes
```



#### 算法思想：

记整型变量 `int nimsum = a[1] ^ a[2] ^ ... ^ a[n]` 。则有如下结论：

- 若 `nimsum == 0` （零局面，必败态），则先手必败；
- 若 `nimsum != 0` （非零局面，必胜态），则先手必胜。

**[证明]** 

1. 以下证明：若先手 `nimsum != 0` ，则我们一定可以通过某种策略，使得我们拿完石子后，堆状态进入必败态，即 `nimsum' == 0` 。
   - 假设 `nimsum != 0` ，设其二进制位中第 k 位为 1 。则 `a[1..n]` 中必然存在奇数个第 k 位二进制位为 1 的数。
   - 不妨假设 `a[i]` 是其中之一，我们先手从第 i 堆石子从拿走 `a[i] - (a[i] ^ nimsum)` 个，则剩余数量为 `a'[i] == a[i] ^ nimsum` 。
   - 因此，后手的 `nimsum' == nimsum ^ nimsum == 0` ，即后手必败。
2. 以下证明：若先手 `nimsum == 0` ，则我们无论采用何种策略，我们拿完石子后，堆状态一定会进入必胜态，即 `nimsum' ！= 0` 。
   - 使用反证法。假设存在一种策略，使得拿完石子后，堆状态保持必败态，即 `nimsum' == 0` 。
   - 假设我们从第`i` 堆中取石子，取前取后的石子数分别为 `a[i], a'[i]` ，满足 `a[others] ^ a[i] == 0` 且 `a[others] ^ a'[i] == 0` 。
   - 易证 `a[i] ^ a'[i] == 0` ，即 `a[i] == a'[i]` ，与假设矛盾。故原命题成立，得证。





#### 算法1(47 ms)：

时间复杂度：O(n)。n 为石子的堆数。

```c++
#include <iostream>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    int nimsum = 0;
    while (n--) {
        int a;
        cin >> a;
        nimsum ^= a;
    }
    
    cout << (nimsum ? "Yes" : "No");
    
    return 0;
}
```





### 2.AcWing0892 台阶-Nim游戏

现在，有一个 *n* 级台阶的楼梯，每级台阶上都有若干个石子，其中第 *i* 级台阶上有 $a_i(i \geq 1)$ 个石子。

两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。

已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

#### 输入格式

第一行包含整数 *n* 。

第二行包含 *n* 个整数，其中第 *i* 个整数表示第 *i* 级台阶上的石子数 $a_i$ 。

#### 输出格式

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

1 ≤ *ai* ≤ 10^9



#### 输入样例：

```
3
2 1 3
```

#### 输出样例：

```
Yes
```



#### 算法思想：

记整型变量 `int nimsum = a[1] ^ a[3] ^ ... ^ a[2k-1]` 。则有如下结论：

- 若 `nimsum == 0` （零局面），则先手必败；
- 若 `nimsum != 0` （非零局面），则先手必胜。

证明从略。



#### 算法1(46 ms)：

时间复杂度：O(n)。n 为台阶的总级数。

```c++
#include <iostream>

using namespace std;

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n;
	cin >> n;
	
	int nimsum = 0;
	for (int i = 1; i <= n; i++) {
		int a;
		cin >> a;
		if (i % 2) {
			nimsum ^= a;
		}
	}
	
	cout << (nimsum ? "Yes" : "No");
	
	return 0;
}
```







### 3.AcWing0893 集合-Nim游戏

给定 *n* 堆石子以及一个由 *k* 个不同正整数构成的数字集合 *S* 。

现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 *S* ，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

#### 输入格式

第一行包含整数 *k* ，表示数字集合 *S* 中数字的个数。

第二行包含 *k* 个整数，其中第 *i* 个整数表示数字集合 *S* 中的第 *i* 个数 *si* 。

第三行包含整数 *n* 。

第四行包含 *n* 个整数，其中第 *i* 个整数表示第 *i* 堆石子的数量 *hi* 。

#### 输出格式

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

#### 数据范围

1 ≤ *n* , *k* ≤ 100 ,

1 ≤ *si* , *hi* ≤ 10000



#### 输入样例：

```
2
2 5
3
2 4 7
```

#### 输出样例：

```
Yes
```



#### SG 函数与 Mex 运算：

在 Nim 游戏中，SG 函数（也称为 Sprague-Grundy 函数）和 Mex 运算是用于计算游戏局面的重要概念。

1. **SG 函数**：SG 函数是一个将游戏局面映射到非负整数的函数。它的定义是：对于一个给定的游戏局面，SG 函数的值等于所有可能的下一步局面的 SG 函数值的 Mex（最小不属于集合）值。换句话说，SG 函数的值表示当前局面的游戏状态的“价值”，通常用来确定该局面对于当前玩家是一个必胜局面还是必败局面。SG 函数常常用递归的方式来计算。

2. **Mex 运算**：Mex 运算（Minimum excludant，最小非包含集合元素值）是对一个集合中的非负整数进行操作，返回不属于该集合的最小非负整数。换句话说，Mex 运算返回的是集合中缺失的最小非负整数。在 SG 函数的计算中，通常会使用 Mex 运算来确定下一步局面的 SG 函数值。

在 Nim 游戏中，通过计算每个局面的 SG 函数值，玩家可以确定当前局面的最优策略，并在游戏中取得优势。通常，一个局面的 SG 函数值为 0 表示该局面是一个必败局面，而 SG 函数值不为 0 则表示该局面是一个必胜局面。



#### 算法1(269 ms)：

时间复杂度：O(n M)。 n, M 分别为石子堆数，石子堆中的最大石子数。

```c++
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

const int N = 100, MAX = 10000;

int s[N], f[MAX + 1], m;

int sg(int x) {
	if (f[x] != -1) {
		return f[x];
	}
	
	unordered_set<int> state;
	for (int i = 0; i < m; i++) {
		if (x >= s[i]) {
			state.insert(sg(x - s[i]));
		}
	}
	
	int i = 0;
	while (state.count(i)) {
		i++;
	}
	
	return f[x] = i;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> m;
	
	for (int i = 0; i < m; i++) {
		cin >> s[i];
	}
	
	int n;
	cin >> n;
	
	fill_n(f, MAX + 1, -1);
	
	int nimsum = 0;
	while (n--) {
		int x;
		cin >> x;
		nimsum ^= sg(x);
	}
	
	cout << (nimsum ? "Yes" : "No");
	
	return 0;
}
```





### 4.AcWing0894 拆分-Nim游戏

给定 *n* 堆石子，两位玩家轮流操作，每次操作可以取走其中的一堆石子，然后放入两堆**规模更小**的新石子堆（新堆规模可以为 0 ，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

#### 输入格式

第一行包含整数 *n* 。

第二行包含 *n* 个整数，其中第 *i* 个整数表示第 *i* 堆石子的数量 *ai* 。

#### 输出格式

如果先手方必胜，则输出 `Yes`。

否则，输出 `No`。

#### 数据范围

1 ≤ *n* , *ai* ≤ 100



#### 输入样例：

```
2
2 3
```

#### 输出样例：

```
Yes
```



#### 算法1(171 ms)：

时间复杂度：O($nm^2$)。n 为石子的堆数，m 为石子堆中石子数的最大值。

```c++
#include <iostream>
#include <algorithm>
#include <unordered_set>

using namespace std;

const int MV = 100;

int n, f[MV + 1];

int sg(int x) {
	if (f[x] != -1) {
		return f[x];
	}
	
	unordered_set<int> state;
	for (int i = 0; i < x; i++) {
		for (int j = 0; j <= i; j++) {
			state.insert(sg(i) ^ sg(j));
		}
	}
	
	int i = 0;
	while (state.count(i)) {
		i++;
	}
	
	return f[x] = i;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	fill_n(f, MV + 1, -1);
	
	cin >> n;
	
	int nimsum = 0;
	while (n--) {
		int x;
		cin >> x;
		nimsum ^= sg(x);
	}
	
	cout << (nimsum ? "Yes" : "No");
	
	return 0;
}
```





## 8-8 容斥原理

### 76.AcWing0890 容斥原理

给定一个整数 *n* 和 *m* 个不同的质数 $p_1,p_2,\ldots ,p_m$ 。

请你求出 1∼*n* 中能被 $p_1,p_2,\ldots ,p_m$  中的至少一个数整除的整数有多少个。

#### 输入格式

第一行包含整数 *n* 和 *m* 。

第二行包含 *m* 个质数。

#### 输出格式

输出一个整数，表示满足条件的整数的个数。

#### 数据范围

$1 \leq m \leq 16$ ，

$1 \leq n, p_i \leq 10^9$ 



#### 输入样例：

```
10 2
2 3
```

#### 输出样例：

```
7
```



#### 容斥原理：

容斥原理（Inclusion-Exclusion Principle）是组合数学中一种重要的计数技术，用于解决集合间的交并问题。它提供了一种方法来计算多个集合的并集或交集中的元素个数，同时避免了重复计数和遗漏的问题。

容斥原理的基本思想是通过对每个集合的贡献进行加减来计算最终的结果。它的表述如下：

设 $A_1, A_2, ..., A_n$ 是 n 个集合，容斥原理给出了它们的并集的元素个数：

$$
\begin{align}
	&   |A_1 \cup A_2 \cup \ldots \cup A_n| \\

	&= \sum_{i=1}^{n} |A_i| - \sum_{1 \leq i < j \leq n} |A_i \cap A_j| + \sum_{1 \leq i < j < k \leq n} |A_i \cap A_j \cap A_k| - \ldots + (-1)^{n-1} |A_1 \cap A_2 \cap \ldots \cap A_n|
\end{align}
$$
其中，$|A|$ 表示集合 A 中元素的个数，$|A ∩ B|$ 表示集合 A 和集合 B 的交集中元素的个数。

容斥原理的应用非常广泛，特别是在解决涉及多个集合的计数问题时非常有用。例如，可以用容斥原理来计算满足一定条件的整数个数、满足多个条件的排列组合个数等。

容斥原理的一个关键优势是它的通用性和灵活性，使得它在解决各种组合计数问题时能够提供简洁而有效的解决方案。



#### 算法思想：







#### 算法1(24 ms)：

时间复杂度： O($2^m m$) 。

```c++
#include <iostream>

using namespace std;

const int N = 16;

int primes[N];

int get_ans(int n, int m) {
    int res = 0, subsets = 1 << m;
    
    // Iterates over all subsets(except empty subset)
    for (int state = 1; state < subsets; state++) {
        // Iterates through each bit of op to 
        // decide whether to include the corresponding element of p 
        // in the current subset
        int prod = 1, cnt = 0;
        for (int i = 0; i < m; i++) {
            // Computes the product and
            // counts the number of elements included in subset op
            if (state >> i & 1) {
                if (prod > n / primes[i]) {
                    prod = 0;
                    break;
                }
                prod *= primes[i];
                cnt++;
            }
        }
        
        if (!prod) {
            continue;
        }
        // Updates the result
        // based on whether elems is odd or even
        if (cnt % 2) {
            res += n / prod;
        }
        else {
            res -= n / prod;
        }
    }
    
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    for (int i = 0; i < m; ++i) {
        cin >> primes[i];
    }
    
    cout << get_ans(n, m);
    
    return 0;
}
```





























