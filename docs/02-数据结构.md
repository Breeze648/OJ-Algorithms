

# 二、数据结构

## 2-1 静态链表、栈、队列与堆

### 1.AcWing 0826 单链表

实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第 *k* 个插入的数后面的数；
3. 在第 *k* 个插入的数后插入一个数。

现在要对该链表进行 *M* 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**: 题目中第 *k* 个插入的数并不是指当前链表的第 *k* 个数。例如操作过程中一共插入了 *n* 个数，则按照插入的时间顺序，这 *n* 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 *n* 个插入的数。

#### 输入格式

第一行包含整数 *M*，表示操作次数。

接下来 *M* 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `H x`，表示向链表头插入一个数 *x*。
2. `D k`，表示删除第 *k* 个插入的数后面的数（当 *k* 为 0 时，表示删除头结点）。
3. `I k x`，表示在第 *k* 个插入的数后面插入一个数 *x*（此操作中 *k* 均大于 0 ）。

#### 输出格式

共一行，将整个链表从头到尾输出。

#### 数据范围

1 ≤ *M* ≤ 100000

所有操作保证合法。



#### 输入样例：

```
10
H 9
I 1 1
D 1
D 0
H 6
I 3 6
I 4 5
I 4 5
I 3 4
D 6
```

#### 输出样例：

```
6 4 6 5
```



#### Algorithm 1:

Time Complexity = $O(m)$ .

```c++
#include <iostream>
#include <vector>

using namespace std;

struct Node {
    int val;
    int next;
};

class myLinkedList {
private:
    vector<Node> nodes;
    
public:
    myLinkedList() {
        nodes.assign(1, Node{0, 0});
    }
    
    void insert(int k, int x) {
        nodes.push_back({x, nodes[k].next});
        nodes[k].next = nodes.size() - 1;
    }
    
    void erase(int k) {
        nodes[k].next = nodes[nodes[k].next].next;
    }
    
    void printList() {
        for (int i = nodes[0].next; i; i = nodes[i].next) {
            cout << nodes[i].val << ' ';
        }
        cout << '\n';
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> m;
    
    myLinkedList L;
    while (m--) {
        char op;
        cin >> op;
        if (op == 'H') {
            int x;
            cin >> x;
            L.insert(0, x);
        } else if (op == 'D') {
            int k;
            cin >> k;
            L.erase(k);
        } else {
            int k, x;
            cin >> k >> x;
            L.insert(k, x);
        }
    }
    
    L.printList();
    
    return 0;
}
```







### 2.AcWing 0827 双链表

实现一个双链表，双链表初始为空，支持 5 种操作：

1. 在最左侧插入一个数；
2. 在最右侧插入一个数；
3. 将第 *k* 个插入的数删除；
4. 在第 *k* 个插入的数左侧插入一个数；
5. 在第 *k* 个插入的数右侧插入一个数

现在要对该链表进行 *M* 次操作，进行完所有操作后，从左到右输出整个链表。

**注意**: 题目中第 *k* 个插入的数并不是指当前链表的第 *k* 个数。例如操作过程中一共插入了 *n* 个数，则按照插入的时间顺序，这 *n* 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 *n* 个插入的数。

#### 输入格式

第一行包含整数 *M*，表示操作次数。

接下来 *M* 行，每行包含一个操作命令，操作命令可能为以下几种：

1. `L x`，表示在链表的最左端插入数 *x* 。
2. `R x`，表示在链表的最右端插入数 *x* 。
3. `D k`，表示将第 *k* 个插入的数删除。
4. `IL k x`，表示在第 *k* 个插入的数左侧插入一个数。
5. `IR k x`，表示在第 *k* 个插入的数右侧插入一个数。

#### 输出格式

共一行，将整个链表从左到右输出。

#### 数据范围

1≤ *M* ≤100000

所有操作保证合法。



#### 输入样例：

```
10
R 7
D 1
L 3
IL 2 10
D 3
IL 2 7
L 8
R 9
IL 4 7
IR 2 2
```

#### 输出样例：

```
8 7 7 3 2 9
```



#### Algorithm 1:

Time Complexity = $O(m)$ .

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

struct Node {
    int val;
    int prev, next;
};

class DList {
public:
    vector<Node> nodes;
    
    DList() {
        nodes.assign(1, Node{0, 0, 0});
    }
    
    void insert(int k, int x) {
        nodes.push_back(Node{x, k, nodes[k].next});
        nodes[k].next = nodes[nodes[k].next].prev = nodes.size() - 1;
    }
    
    void erase(int k) {
        nodes[nodes[k].prev].next = nodes[k].next;
        nodes[nodes[k].next].prev = nodes[k].prev;
    }
    
    void printList() {
        for (int i = nodes[0].next; i; i = nodes[i].next) {
            cout << nodes[i].val << ' ';
        }
        cout << '\n';
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> m;
    
    DList L;
    while (m--) {
        string op;
        cin >> op;
        if (op == "L") {
            int x;
            cin >> x;
            L.insert(0, x);
        } else if (op == "R") {
            int x;
            cin >> x;
            L.insert(L.nodes[0].prev, x);
        } else if (op == "D") {
            int k;
            cin >> k;
            L.erase(k);
        } else if (op == "IL") {
            int k, x;
            cin >> k >> x;
            L.insert(L.nodes[k].prev, x);
        } else {
            int k, x;
            cin >> k >> x;
            L.insert(k, x);
        }
    }
    
    L.printList();
    
    return 0;
}
```







### 3.AcWing 0828 模拟栈

实现一个栈，栈初始为空，支持四种操作：

1. `push x` – 向栈顶插入一个数 *x* ； 
2. `pop` – 从栈顶弹出一个数； 
3. `empty` – 判断栈是否为空； 
4. `query` – 查询栈顶元素。

现在要对栈进行 *M* 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

##### 输入格式

第一行包含整数 *M*，表示操作次数。

接下来 *M* 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。

##### 输出格式

对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。

其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示栈顶元素的值。

##### 数据范围

1≤ *M* ≤100000,

1≤ *x* ≤10^9

所有操作保证合法。



##### 输入样例：

```
10
push 5
query
push 6
pop
query
pop
empty
push 4
query
empty
```

##### 输出样例：

```
5
5
YES
4
NO
```



#### 算法1(57 ms)：

```c++
#include <iostream>
#include <string>

using namespace std;

const int N = 1e5;

int idx = -1, stk[N];

void push(int x) {
    stk[++idx] = x;
}

void pop() {
    idx--;
}

bool empty() {
    return idx == -1;
}

int top() {
    return stk[idx];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        string op;
        cin >> op;
        
        if (op == "push") {
            int x;
            cin >> x;
            push(x);
        }
        else if (op == "pop") {
            pop();
        }
        else if (op == "empty") {
            cout << (empty() ? "YES" : "NO") << '\n';
        }
        else {
            cout << top() << '\n';
        }
    }
    
    return 0;
}
```





### 4.AcWing3302 表达式求值(medium)

给定一个表达式，其中运算符仅包含 `+,-,*,/`（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。

**注意：**

- 数据保证给定的表达式合法。
- 题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2`,`(2+2)*(-(1+1)+2)` 之类表达式均不会出现。
- 题目保证表达式中所有数字均为正整数。
- 题目保证表达式在中间计算过程以及结果中，均不超过 2^31 − 1。
- 题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。

- C++和Java中的整除默认是向零取整；Python中的整除`//`默认向下取整，因此Python的`eval()`函数中的整除也是向下取整，在本题中不能直接使用。

#### 输入格式

共一行，为给定表达式。

#### 输出格式

共一行，为表达式的结果。

#### 数据范围

表达式的长度不超过 10^5。



#### 输入样例：

```
(2+2)*(1+1)
```

#### 输出样例：

```
8
```



#### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <stack>
#include <string>
#include <unordered_map>

using namespace std;

void evaluate(stack<char>& ops, stack<int>& nums) {
    int b = nums.top(); nums.pop();
    int a = nums.top(); nums.pop();
    char op = ops.top(); ops.pop();
    
    if (op == '+') {
        a += b;
    } else if (op == '-') {
        a -= b;
    } else if (op == '*') {
        a *= b;
    } else {
        a /= b;
    }
    
    nums.push(a);
}

int expressionEvaluation(string& s) {
    stack<char> ops;
    stack<int> nums;
    unordered_map<char, int> prio{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    
    for (int i = 0; i < s.size(); i++) {
        char c = s[i];
        if (isdigit(c)) {
            int num = c - '0';
            while (++i < s.size() && isdigit(s[i])) {
                num = num * 10 + s[i] - '0';
            }
            i--;
            nums.push(num);
        } else if (c == '(') {
            ops.push(c);
        } else if (c == ')') {
            while (ops.top() != '(') {
                evaluate(ops, nums);
            }
            ops.pop();
        } else {
            while (!ops.empty() && ops.top() != '(' && prio[ops.top()] >= prio[c]) {
                evaluate(ops, nums);
            }
            ops.push(c);
        }
    }

    while (!ops.empty()) {
        evaluate(ops, nums);
    }
    
    return nums.top();
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    string s;
    cin >> s;
    
    cout << expressionEvaluation(s) << '\n';
    
    return 0;
}
```





### 5.AcWing0829 模拟队列

实现一个队列，队列初始为空，支持四种操作：

1. `push x` – 向队尾插入一个数 *x* ； 
2. `pop` – 从队头弹出一个数； 
3. `empty` – 判断队列是否为空； 
4. `query` – 查询队头元素。

现在要对队列进行 *M* 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。

#### 输入格式

第一行包含整数 *M*，表示操作次数。

接下来 *M* 行，每行包含一个操作命令，操作命令为 `push x`，`pop`，`empty`，`query` 中的一种。

#### 输出格式

对于每个 `empty` 和 `query` 操作都要输出一个查询结果，每个结果占一行。

其中，`empty` 操作的查询结果为 `YES` 或 `NO`，`query` 操作的查询结果为一个整数，表示队头元素的值。

#### 数据范围

1 ≤ *M* ≤ 100000,

1 ≤ *x* ≤ 10^9,

所有操作保证合法。



#### 输入样例：

```
10
push 6
empty
query
pop
empty
push 3
push 4
pop
query
push 6
```

#### 输出样例：

```
NO
6
YES
4
```



#### Algorithm 1：

Time Complexity = $O(m)$ .

```c++
#include <iostream>
#include <string>

using namespace std;

const int N = 1e5;

int que[N], head = 0, rear = -1;

void push(int x) {
    que[++rear] = x;
}

void pop() {
    head++;
}

bool empty() {
    return head - rear == 1;
}

int front() {
    return que[head];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >>m;
    while (m--) {
        string op;
        cin >> op;
        
        if (op == "push") {
            int x;
            cin >> x;
            push(x);
        }
        else if (op == "pop") {
            pop();
        }
        else if (op == "empty") {
            cout << (empty() ? "YES" : "NO") << '\n';
        }
        else {
            cout << front() << '\n';
        }
    }
    
    return 0;
}
```





### 6.AcWing0839 模拟堆

维护一个集合，初始时集合为空，支持如下几种操作：

1. `I x`，插入一个数 *x* ；
2. `PM`，输出当前集合中的最小值；
3. `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；
4. `D k`，删除第 *k* 个插入的数；
5. `C k x`，修改第 *k* 个插入的数，将其变为 *x* 。

现在要进行 *N* 次操作，对于所有第 2 个操作，输出当前集合的最小值。

#### 输入格式

第一行包含整数 *N* 。

接下来 *N* 行，每行包含一个操作指令，操作指令为 `I x`，`PM`，`DM`，`D k` 或 `C k x` 中的一种。

#### 输出格式

对于每个输出指令 `PM`，输出一个结果，表示当前集合中的最小值。

每个结果占一行。

#### 数据范围

1 ≤ *N* ≤ 10^5

−10^9 ≤ *x* ≤ 10^9

 数据保证合法。



#### 输入样例：

```
8
I -10
PM
I -10
D 1
C 2 8
I 6
PM
DM
```

#### 输出样例：

```
-10
6
```



#### 算法1(186 ms)：

时间复杂度：插入、删除、修改的时间开销为 O(log n)，读堆顶的时间开销为 O(1)。 n 为堆中元素的个数。

```c++
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

const int N = 1e5;

int n, arr[N + 1];
int hp[N + 1], ph[N + 1], idx;

void heap_swap(int u, int v) {
    swap(ph[hp[u]], ph[hp[v]]);
    swap(hp[u], hp[v]);
    swap(arr[u], arr[v]);
}

void down(int u) {
    for (int v = u * 2; v <= n; u = v, v = u * 2) {
        if (v + 1 <= n && arr[v + 1] < arr[v]) {
            ++v;
        }
        if (arr[v] >= arr[u]) {
            return;
        }
        heap_swap(u, v);
    }
}

void up(int u) {
    for (int v = u / 2; v && arr[v] > arr[u]; u = v, v = u / 2) {
        heap_swap(u, v);
    }
}

void push(int val) {
    arr[++n] = val;
    ph[++idx] = n;
    hp[n] = idx;
    up(n);
}

int top() {
    return arr[1];
}

void pop() {
    heap_swap(1, n--);
    down(1);
}

void erase(int k) {
    int u = ph[k];
    heap_swap(u, n--);
    up(u);
    down(u);
}

void modify(int k, int val) {
    int u = ph[k];
    arr[u] = val;
    up(u);
    down(u);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> m;
    
    while (m--) {
        string op;
        cin >> op;
        int k, val;
        
        if (op == "I") {
            cin >> val;
            push(val);
        }
        else if (op == "PM") {
            cout << top() << endl;
        }
        else if (op == "DM") {
            pop();
        }
        else if (op == "D") {
            cin >> k;
            erase(k);
        }
        else {
            cin >> k >> val;
            modify(k, val);
        }
    }
    
    return 0;
}
```





### 7.AcWing0838 堆排序

输入一个长度为 *n* 的整数数列，从小到大输出前 *m* 小的数。

#### 输入格式

第一行包含整数 *n* 和 *m*。

第二行包含 *n* 个整数，表示整数数列。

#### 输出格式

共一行，包含 *m* 个整数，表示整数数列中前 *m* 小的数。

#### 数据范围

1 ≤ *m* ≤ *n* ≤ 10^5，

1 ≤ 数列中元素 ≤ 10^9



#### 输入样例：

```
5 3
4 5 1 3 2
```

#### 输出样例：

```
1 2 3
```



#### 算法1(169 ms)：

时间复杂度：O(n + m log n)。 n, m 分别为数组元素个数，待排序的最小整数个数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5;

int n, arr[N + 1];

void down(int u) {
	for (int v = u * 2; v <= n; v = u * 2) {
		if (v + 1 <= n && arr[v + 1] < arr[v]) {
			++v;
		}
		if (arr[v] >= arr[u]) {
			return;
		}
		swap(arr[v], arr[u]);
		u = v;
	}
}

// void down(int u) {
//     for (int v = 2 * u + 1; v < n; v = u * 2 + 1) {
//         if (v + 1 < n && arr[v + 1] < arr[v]) {
//             v++;
//         }
        
//         if (arr[v] >= arr[u]) {
//             break;
//         }
//         swap(arr[v], arr[u]);
//         u = v;
//     }
// }

void buildHeap() {
	for (int u = n / 2; u; --u) {
		down(u);
	}
}

int top() {
	return arr[1];
}

void pop() {
	swap(arr[1], arr[n--]);
	down(1);
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	for (int i = 1; i <= n; ++i) {
		cin >> arr[i];
	}
	
	buildHeap();
	
	while (m--) {
		cout << top() << " ";
		pop();
	}
	
	return 0;
}
```



#### 算法2(187 ms):

```c++
#include <iostream>

using namespace std;

const int N = 1e5;

// 建立一个大小为 n 的小根堆
int arr[N], n, m;

void down(int u) {
    int v = u * 2 + 1;
    if (v >= n) {
        return;
    }
    
    if (v + 1 < n && arr[v + 1] < arr[v]) {
        v++;
    }
    if (arr[v] < arr[u]) {
        swap(arr[v], arr[u]);
        down(v);
    }
}

void build() {
    for (int i = (n - 1) / 2; i >= 0; i--) {
        down(i);
    }
}

void pop() {
    arr[0] = arr[--n];
    down(0);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    build();
    while (m--) {
        cout << arr[0] << ' ';
        pop();
    }
    
    return 0;
}
```





### 8.LeetCode 0232 Implement Queue using Stacks

Implement a first in first out (FIFO) queue using only two stacks.  The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).

Implement the `MyQueue` class:

- `void push(int x)` Pushes element x to the back of the queue.
- `int pop()` Removes the element from the front of the queue and returns it.
- `int peek()` Returns the element at the front of the queue.
- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.
- Depending on your language, the stack may not be supported  natively. You may simulate a stack using a list or deque (double-ended  queue) as long as you use only a stack's standard operations.

 

**Example 1:**

```
Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

 

**Constraints:**

- `1 <= x <= 9`
- At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.
- All the calls to `pop` and `peek` are valid.

 

##### Algorithm 1:

```c++
class MyQueue {
public:
    MyQueue() {

    }
    
    void push(int x) {
        in.push(x);
    }
    
    int pop() {
        int res = peek();
        out.pop();
        return res;
    }
    
    int peek() {
        if (out.empty()) {
            while (!in.empty()) {
                out.push(in.top());
                in.pop();
            }
        }
        return out.top();
    }
    
    bool empty() {
        return in.empty() && out.empty();
    }

private:
    stack<int> in, out;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```





### 9.LeetCode 0225 Implement Stack using Queues

Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).

Implement the `MyStack` class:

- `void push(int x)` Pushes element x to the top of the stack.
- `int pop()` Removes the element on the top of the stack and returns it.
- `int top()` Returns the element on the top of the stack.
- `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.

**Notes:**

- You must use **only** standard operations of a queue, which means that only `push to back`, `peek/pop from front`, `size` and `is empty` operations are valid.
- Depending on your language, the queue may not be supported  natively. You may simulate a queue using a list or deque (double-ended  queue) as long as you use only a queue's standard operations.

 

**Example 1:**

```
Input
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
```

 

**Constraints:**

- `1 <= x <= 9`
- At most `100` calls will be made to `push`, `pop`, `top`, and `empty`.
- All the calls to `pop` and `top` are valid.



##### Algorithm 1:

```c++
class MyStack {
public:
    MyStack() {
        curr = 0;
    }
    
    void push(int x) {
        que[curr].push(x);
    }
    
    // 把除队尾(栈顶)以外的元素保存在另一个队列中
    int pop() {
        while (que[curr].size() != 1) {
            que[curr ^ 1].push(que[curr].front());
            que[curr].pop();
        }
        int res = que[curr].front();
        que[curr].pop();
        curr ^= 1;
        return res;
    }
    
    int top() {
        int res = this->pop();
        que[curr].push(res);
        return res;
    }
    
    bool empty() {
        return que[curr].empty();
    }

private:
    queue<int> que[2];
    int curr;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```





### 10.LeetCode 0020 Valid Parentheses

Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

 

**Example 1:**

**Input:** s = "()"

**Output:** true

**Example 2:**

**Input:** s = "()[]{}"

**Output:** true

**Example 3:**

**Input:** s = "(]"

**Output:** false

**Example 4:**

**Input:** s = "([])"

**Output:** true

 

**Constraints:**

- `1 <= s.length <= 104`
- `s` consists of parentheses only `'()[]{}'`.



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char, int> map{{'(', 0}, {'[', 1}, {'{', 2},
                                     {')', 3}, {']', 4}, {'}', 5}};
        stack<int> stk;
        for (int i = 0; i < s.size(); i++) {
            if (map[s[i]] < 3) {
                stk.push(s[i]);
            } else {
                if (stk.empty() || map[stk.top()] != map[s[i]] - 3) {
                    return false;
                }
                stk.pop();
            }
        }
        return stk.empty();
    }
};
```





### 11.LeetCode 0150 Evaluate Reverse Polish Notation

You are given an array of strings `tokens` that represents an arithmetic expression in a Reverse Polish Notation.

Evaluate the expression. Return *an integer that represents the value of the expression*.

**Note** that:

- The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.
- Each operand may be an integer or another expression.
- The division between two integers always **truncates toward zero**.
- There will not be any division by zero.
- The input represents a valid arithmetic expression in a reverse polish notation.
- The answer and all the intermediate calculations can be represented in a **32-bit** integer.

 

**Example 1:**

```
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
```

**Example 2:**

```
Input: tokens = ["4","13","5","/","+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
```

**Example 3:**

```
Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

 

**Constraints:**

- `1 <= tokens.length <= 10^4`
- `tokens[i]` is either an operator: `"+"`, `"-"`, `"*"`, or `"/"`, or an integer in the range `[-200, 200]`.



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> nums;

        for (auto& t : tokens) {
            if (t == "+" || t == "-" || t == "*" || t == "/") {
                long long b = nums.top();
                nums.pop();
                long long a = nums.top();
                nums.pop();
                if (t == "+") {
                    nums.push(a + b);
                } else if (t == "-") {
                    nums.push(a - b);
                } else if (t == "*") {
                    nums.push(a * b);
                } else {
                    nums.push(a / b);
                }
            } else {
                nums.push(stoll(t));
            }
        }
        return nums.top();
    }
};
```





### 12.LeetCode 0347 Top K Frequent Elements

Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.

 

**Example 1:**

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

 

**Constraints:**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `k` is in the range `[1, the number of unique elements in the array]`.
- It is **guaranteed** that the answer is **unique**.

 

##### Algorithm 1:

Time Complexity = $O(n \log n)$ .

```c++
class Solution {
public:
    using PII = pair<int, int>;
    struct myComparison {
        bool operator()(PII a, PII b) {
            return a.second < b.second;
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        for (auto x : nums) {
            cnt[x]++;
        }

        priority_queue<PII, vector<PII>, myComparison> maxHeap(cnt.begin(), cnt.end());
        vector<int> res;
        while (k--) {
            res.push_back(maxHeap.top().first);
            maxHeap.pop();
        }
        return res;
    }
};
```

















## 2-2 单调栈

### 0.单调栈模板

```c++
#include <iostream>
#include <vector>
#include <stack>

void findLeftSmaller(vector<int>& nums, vector<int>& left) {
    int n = nums.size();
    left.assign(n, -1); // Initialize left array with -1
        
    stack<int> stk;
    for (int i = 0; i < n; i++) {
        // 1. Pop elements from the stack while the current number is smaller or equal
        while (!stk.empty() && nums[stk.top()] >= nums[i]) {
            stk.pop();
        }
        // 2. If stack is not empty, set left[i] to the index of the top element
        if (!stk.empty()) {
            left[i] = stk.top();
        }
        // 3. Push the current index
        stk.push(i);
    }
}
    
void findRightSmaller(vector<int>& nums, vector<int>& right) {
    int n = nums.size();
    right.assign(n, n); // Initialize right array with n
    stack<int> stk;
    
    for (int i = n - 1; i >= 0; i--) {
        // 1. Pop elements from the stack while the current number is greater or equal
        while (!stk.empty() && nums[stk.top()] <= nums[i]) {
            stk.pop();
        }
        // 2. If stack is not empty, set right[i] to the index of the top element
        if (!stk.empty()) {
            right[i] = stk.top();
        }
        // 3. Push the current index
        stk.push(i);
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    vector<int> left;
    findLeftSmaller(nums, left);
    
    
    
    return 0;
}
```



### 1.AcWing0830 前一个更小的数

给定一个长度为 *N* 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

#### 输入格式

第一行包含整数 *N*，表示数列长度。

第二行包含 *N* 个整数，表示整数数列。

#### 输出格式

共一行，包含 *N* 个整数，其中第 *i* 个输出的数表示数列的第 *i* 个数的左边第一个比它小的数，如果不存在则输出 −1。

#### 数据范围

1 ≤ *N* ≤ 10^5

1 ≤ 数列中元素 ≤ 10^9



#### 输入样例：

```
5
3 4 2 7 5
```

#### 输出样例：

```
-1 3 -1 2 2
```



#### 单调栈：

`stk[0..top1]`保存`arr[0..i-1]`的单调升序序列。插入`arr[i]`时，将栈顶所有不小于`arr[i]`的元素都弹出，再将`arr[i]`压入栈中，因此`stk[0..top2]`保持了单调性。在`arr[i]`入栈前，此时栈顶保存的即为前缀`arr[0..i-1]`中第一个小于`arr[i]`的元素值。



#### 算法1：

Time Complexity = O(n).

```c++
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

void getLeftSmaller(vector<int>& nums, vector<int>& left) {
    int n = nums.size();
    left.assign(n, -1); // Initialize left array with -1
        
    stack<int> stk;
    for (int i = 0; i < n; i++) {
        // 1. Pop elements from the stack while the current number is smaller or equal
        while (!stk.empty() && nums[stk.top()] >= nums[i]) {
            stk.pop();
        }
        // 2. If stack is not empty, set left[i] to the index of the top element
        if (!stk.empty()) {
            left[i] = nums[stk.top()];
        }
        // 3. Push the current index
        stk.push(i);
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    vector<int> left;
    getLeftSmaller(nums, left);
    
    for (int i = 0; i < n; i++) {
        cout << left[i] << ' ';
    }
    
    return 0;
}
```



#### 算法2(151 ms)：

```c++
#include <iostream>
#include <stack>

using namespace std;

stack<int> stk;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    stk.push(-1);
    
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        while (stk.top() >= x) {
            stk.pop();
        }
        cout << stk.top() << ' ';
        
        stk.push(x);
    }
    cout << '\n';
    
    return 0;
}
```





### 2.LeetCode 0739 Daily Temperatures

Given an array of integers `temperatures` represents the daily temperatures, return *an array* `answer` *such that* `answer[i]` *is the number of days you have to wait after the* `ith` *day to get a warmer temperature*. If there is no future day for which this is possible, keep `answer[i] == 0` instead.

 

**Example 1:**

```
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
```

**Example 2:**

```
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
```

**Example 3:**

```
Input: temperatures = [30,60,90]
Output: [1,1,0]
```

 

**Constraints:**

- `1 <= temperatures.length <= 10^5`
- `30 <= temperatures[i] <= 100`



#### Algorithm 1:

Time Compexity = O(n).

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temps) {
        int n = temps.size();
        vector<int> ans(n, 0);  // Initialize answer array
        
        stack<int> stk;  // Stack to store indices of temperatures

        for (int i = 0; i < n; i++) {
            // While stack is not empty and current temp is higher than stack's top
            // Monotone non-decreasing from bottom to top
            while (!stk.empty() && temps[stk.top()] < temps[i]) {
                ans[stk.top()] = i - stk.top();  // Calculate days until warmer temp
                stk.pop();  // Remove the previous index
            }
            stk.push(i);  // Push current index onto stack
        }

        return ans;  // Return the answer array
    }
};
```



#### Algorithm 2:

```c++
class Solution {
    void findRightGreater(vector<int>& nums, vector<int>& right) {
        int n = nums.size();
        right.assign(n, n); // Initialize right array with n
        stack<int> stk;
        
        for (int i = n - 1; i >= 0; i--) {
            // 1. Pop elements from the stack while the current number is greater or equal
            while (!stk.empty() && nums[stk.top()] <= nums[i]) {
                stk.pop();
            }
            // 2. If stack is not empty, set right[i] to the index of the top element
            if (!stk.empty()) {
                right[i] = stk.top();
            }
            // 3. Push the current index
            stk.push(i);
        }
    }
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> right;
        findRightGreater(temperatures, right);
        int n = right.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            ans[i] = right[i] == n ? 0 : right[i] - i;
        }
        return ans;
    }
};
```







### 3.LeetCode 0496 Next Greater Element I

The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.

You are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.

For each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.

Return *an array* `ans` *of length* `nums1.length` *such that* `ans[i]` *is the **next greater element** as described above.*

 

**Example 1:**

```
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
```

**Example 2:**

```
Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.
```

 

**Constraints:**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 10^4`
- All integers in `nums1` and `nums2` are **unique**.
- All the integers of `nums1` also appear in `nums2`.



#### Algorithm 1:

Time Complexity = O(n + m).

```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // <nums1[i], i>
        unordered_map<int, int> index;
        for (int i = 0; i < nums1.size(); i++) {
            index[nums1[i]] = i;
        }

        vector<int> ans(nums1.size(), -1);
        stack<int> stk;
        for (int i = 0; i < nums2.size(); i++) {
            // Monotone non-decreasing from bottom to top
            while (!stk.empty() && stk.top() < nums2[i]) {
                if (index.find(stk.top()) != index.end()) {
                    ans[index[stk.top()]] = nums2[i];
                }
                stk.pop();
            }
            stk.push(nums2[i]);
        }
        return ans;
    }
};
```



### 3.LeetCode 0503 Next Greater Element II

Given a circular integer array `nums` (i.e., the next element of `nums[nums.length - 1]` is `nums[0]`), return *the **next greater number** for every element in* `nums`.

The **next greater number** of a number `x`  is the first greater number to its traversing-order next in the array,  which means you could search circularly to find its next greater number. If it doesn't exist, return `-1` for this number.

 

**Example 1:**

```
Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
```

**Example 2:**

```
Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
```

 

**Constraints:**

- `1 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`



#### Algorithm 1:

Time Complexity = O(n).

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        stack<int> stk;

        for (int loops = 0; loops < 2; loops++) {
            for (int i = 0; i < n; i++) {
                // Monotone non-incresing from bottom to top
                while (!stk.empty() && nums[stk.top()] < nums[i]) {
                    ans[stk.top()] = nums[i];
                    stk.pop();
                }
                stk.push(i);
            }
        }
        return ans;
    }
};
```



### 4.LeetCode 0042 Trappng Rain Water

Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

```
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
```

**Example 2:**

```
Input: height = [4,2,0,3,2,5]
Output: 9
```

 

**Constraints:**

- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`



#### Algorithm 1:

Time Complexity = O(n).

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> left(n), right(n);

        int maxHeight = 0;
        for (int i = 0; i < n; i++) {
            // left[i] represents the maximum height in height[0..i]
            maxHeight = max(maxHeight, height[i]);
            left[i] = maxHeight;
        }
        maxHeight = 0;
        for (int i = n - 1; i >= 0; i--) {
            // right[i] represents the maximum height in height[i..n-1]
            maxHeight = max(maxHeight, height[i]);
            right[i] = maxHeight;
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            // min(left[i], right[i]) represents the water height in i-th position
            ans += min(left[i], right[i]) - height[i];
        }
        return ans;
    }
};
```



### 5.LeetCode 0084 Largest Rectangle in Histogram

Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return *the area of the largest rectangle in the histogram*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

```
Input: heights = [2,4]
Output: 4
```

 

**Constraints:**

- `1 <= heights.length <= 10^5`
- `0 <= heights[i] <= 10^4`



#### Algorithm 1:

Time Complexity = O(n).

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        // left[i] represents index of first less than height[i] in the left
        // right[i] repesents that in the right
        vector<int> left(n, -1), right(n, n);
        stack<int> stk;
        for (int i = 0; i < n; i++) {
            // Strictly monotone increasing from bottom to top
            while (!stk.empty() && heights[stk.top()] >= heights[i]) {
                stk.pop();
            }
            if (!stk.empty()) {
                left[i] = stk.top();
            }
            stk.push(i);
        }
        stk = stack<int>();
        for (int i = n - 1; i >= 0; i--) {
            // Strictly monotone increasing from bottom to top
            while (!stk.empty() && heights[stk.top()] >= heights[i]) {
                stk.pop();
            }
            if (!stk.empty()) {
                right[i] = stk.top();
            }
            stk.push(i);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);
        }
        return ans;
    }
};
```





## 2-3 单调队列

### 0.滑动窗口模板

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <deque>

using namespace std;

void SlidingWindowMin(vector<int>& nums, vector<int>& ans, int k) {
    deque<int> deq;
    for (int i = 0; i < nums.size(); i++) {
        if (i - k >= 0 && deq.front() == nums[i - k]) {
            deq.pop_front();
        }
        while (!deq.empty() && deq.back() > nums[i]) {
            deq.pop_back();
        }
        deq.push_back(nums[i]);
        if (i - k + 1 >= 0) {
            ans.push_back(deq.front());
        }
    }
}

void SlidingWindowMax(vector<int>& nums, vector<int>& ans, int k) {
    deque<int> deq;
    for (int i = 0; i < nums.size(); i++) {
        if (i - k >= 0 && deq.front() == nums[i - k]) {
            deq.pop_front();
        }
        while (!deq.empty() && deq.back() < nums[i]) {
            deq.pop_back();
        }
        deq.push_back(nums[i]);
        if (i - k + 1 >= 0) {
            ans.push_back(deq.front());
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    vector<int> ansMin, ansMax;
    slidingWindowMin(nums, ansMin, k);
    slidingWindowMax(nums, ansMax, k);
    
    
    
    return 0;
}
```





### 1.AcWing0154 滑动窗口

给定一个大小为 *n* ≤ 10^6 的数组。 

有一个大小为 *k* 的滑动窗口，它从数组的最左边移动到最右边。 

你只能在窗口中看到 *k* 个数字。 

每次滑动窗口向右移动一个位置。 

以下是一个例子：

该数组为 `[1 3 -1 -3 5 3 6 7]`，*k* 为 3。

| 窗口位置                  | 最小值 | 最大值 |
| ------------------------- | ------ | ------ |
| [1  3  -1] -3  5  3  6  7 | -1     | 3      |
| 1 [3  -1  -3] 5  3  6  7  | -3     | 3      |
| 1  3 [-1  -3  5] 3  6  7  | -3     | 5      |
| 1  3  -1 [-3  5  3] 6  7  | -3     | 5      |
| 1  3  -1  -3 [5  3  6] 7  | 3      | 6      |
| 1  3  -1  -3  5 [3  6  7] | 3      | 7      |

你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

#### 输入格式

输入包含两行。 

第一行包含两个整数 *n* 和 *k*，分别代表数组长度和滑动窗口的长度。 

第二行有 *n* 个整数，代表数组的具体数值。

同行数据之间用空格隔开。

#### 输出格式

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

#### 输入样例：

```
8 3
1 3 -1 -3 5 3 6 7
```

#### 输出样例：

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```



#### 单调队列：

以求最小值为例：

维护一个单调队列`que[head..tail]`。为输入受限的双端队列：允许在队头删除，或者在队尾进行插入与删除。其内部保存的是窗口`arr[i-k+1..i]`中升序序列的各元素对应的索引（而不是元素值）。

每次 “窗口向右移动一个单位” ，执行下面 3 步：

（1）将窗口左端点右移一个单位。判断队头是否移出了窗口，如果移出，应当出队。

（2）将窗口右端点右移一个单位。将新元素`arr[i]`入队，入队时应当保持单调队列的性质。此时，单调队列表现为一个单调栈：将队尾所有不小于`arr[i]`的元素从队尾弹出，然后将`arr[i]`从队尾入队。

（3）此时队头保存的是当前窗口最小值的索引。



#### 算法1：

时间复杂度：O(n)。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <deque>

using namespace std;

void minSlidingWindow(vector<int>& nums, int k) {
    deque<int> deq;
    for (int i = 0; i < nums.size(); i++) {
        if (i - k >= 0 && deq.front() == nums[i - k]) {
            deq.pop_front();
        }
        while (!deq.empty() && deq.back() > nums[i]) {
            deq.pop_back();
        }
        deq.push_back(nums[i]);
        if (i - k + 1 >= 0) {
            cout << deq.front() << ' ';
        }
    }
    cout << '\n';
}

void maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> deq;
    for (int i = 0; i < nums.size(); i++) {
        if (i - k >= 0 && deq.front() == nums[i - k]) {
            deq.pop_front();
        }
        while (!deq.empty() && deq.back() < nums[i]) {
            deq.pop_back();
        }
        deq.push_back(nums[i]);
        if (i - k + 1 >= 0) {
            cout << deq.front() << ' ';
        }
    }
    cout << '\n';
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    vector<int> ansMin(n), ansMax(n);
    minSlidingWindow(nums, k);
    maxSlidingWindow(nums, k);
    
    return 0;
}
```





#### 算法1-单调队列（84 ms)：

```c++
#include <cstdio>

const int N = 1e6;

void solutionMin(int arr[], int n, int k) {
    // que[head..tail]保存滑动窗口arr[i-k+1..i]单调升序序列的元素索引
    int que[N];
    int head = 0, tail = -1;
    
    que[head] = 0;
    for (int i = 0; i < n; ++i) {
        // 若队头超出窗口左端点，则队头出队
        if (que[head] < i - k + 1) {
            ++head;
        }
        
        // 若队不空，将不小于当前元素arr[i]的队尾元素全部元素弹出，然后将 i 压入队尾
        while (tail >= head && arr[que[tail]] >= arr[i]) {
            --tail;
        }
        que[++tail] = i;
        
        // 队头保存的是当前窗口的最小值
        if (i - k + 1 >= 0) {
            printf("%d ", arr[que[head]]);
        }
    }
    printf("\n");
    
	return;
}

void solutionMax(int arr[], int n, int k) {
    int que[N];
    int head = 0, tail = -1;
    
    for (int i = 1; i < n; ++i) {
        if (tail >= head && que[head] < i - k + 1) {
            ++head;
        }
        
        while (tail >= head && arr[que[tail]] <= arr[i]) {
            --tail;
        }
        que[++tail] = i;
        
        if (i - k + 1 >= 0) {
            printf("%d ", arr[que[head]]);
        }
    }
    printf("\n");
    
	return;
}

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    
    int arr[N];
    for (int i = 0; i < n; ++i) {
        scanf("%d", &arr[i]);
    }
    
    solutionMin(arr, n, k);
    solutionMax(arr, n, k);
    
    return 0;
}
```

用时：84 ms。

时间复杂度：O(n)；

空间复杂度：O(n), n为数组的元素个数。



#### 算法2-双端队列（130ms)：

```c++
#include <iostream>
#include <deque>

using namespace std;

const int N = 1e6;

int n, k, arr[N];

void solutionMin() {
    deque<int> deq;
    
    for (int i = 0; i < n; i++) {
        int j = i - k + 1;
        if (j > 0 && deq.front() < j) {
            deq.pop_front();
        }
        
        while (!deq.empty() && arr[deq.back()] >= arr[i]) {
            deq.pop_back();
        }
        deq.push_back(i);
        
        if (j >= 0) {
            cout << arr[deq.front()] << " ";
        }
    }
    
    cout << endl;
}

void solutionMax() {
    deque<int> deq;
    
    for (int i = 0; i < n; i++) {
        int j = i - k + 1;
        if (j > 0 && deq.front() < j) {
            deq.pop_front();
        }
        
        while (!deq.empty() && arr[deq.back()] <= arr[i]) {
            deq.pop_back();
        }
        deq.push_back(i);
        
        if (j >= 0) {
            cout << arr[deq.front()] << " ";
        }
    }
    
    cout << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    solutionMin();
    
    solutionMax();
    
    return 0;
}
```

时间复杂度：O(n), n 为数组元素个数。

空间复杂度：O(k), k 为窗口大小。

双端队列`deque`操作：

```c++
#include <deque>

using std::deque;

int main() {
    // ...
    int val = 42;
    deque<int> deq;
    
    deq.push_front(val);
    deq.push_back(val);
    deq.pop_front();
    deq.pop_back();
    
    deq.empty();		// 判空，返回bool值
    deq.size();			// 大小
    
    // ...
}
```



#### 算法3-双链表(212 ms)：

也可以使用双链表`list`实现, 其逻辑结构与`deque`完全相同:

```c++
#include <cstdio>
#include <list>

using std::list;
const int N = 1e6;

void solutionMin(int arr[], int n, int k) {
	list<int> lst;
    
    for (int i = 0; i < n; ++i) {
        int j = i - k + 1;
        
        // 若队头超出窗口左端点，则队头出队
        if (!lst.empty() && lst.front() < j) {
            lst.pop_front();
        }
        
        // 若队不空，将不小于当前元素arr[i]的队尾元素全部元素弹出，然后将索引 i 压入队尾
        while (!lst.empty() && arr[lst.back()] >= arr[i]) {
            lst.pop_back();
        }
        lst.push_back(i);
        
        // 队头保存的是当前窗口的最小值
        if (j >= 0) {
            printf("%d ", arr[lst.front()]);
        }
    }
    
    printf("\n");
    return;
}

void solutionMax(int arr[], int n, int k) {
	list<int> lst;
    
    for (int i = 0; i < n; ++i) {
        int j = i - k + 1;
        
        if (!lst.empty() && lst.front() < j) {
            lst.pop_front();
        }
        
        while (!lst.empty() && arr[lst.back()] <= arr[i]) {
            lst.pop_back();
        }
        lst.push_back(i);
        
        if (j >= 0) {
            printf("%d ", arr[lst.front()]);
        }
    }
    
    printf("\n");
    return;
}

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    
    int arr[N];
    for (int i = 0; i < n; ++i) {
        scanf("%d", &arr[i]);
    }
    
    solutionMin(arr, n, k);
    solutionMax(arr, n, k);
    
    return 0;
}
```

双链表`list`操作：

```c++
#include <list>

using std::list;

int main() {
    // ...
    int val = 42;
    list<int> lst;
    
    lst.push_front(val);
    lst.push_back(val);
    lst.pop_front();
    lst.pop_back();
    
    lst.empty();		// 判空，返回bool值
    lst.size();			// 大小
    
    // ...
}
```

时间复杂度：O(n), n 为数组元素个数。

空间复杂度：O(k), k 为窗口大小。



#### 算法4(131 ms)：

尝试在 `deque<int> deq` 内保存元素值，而不是元素的索引。为此，窗口内元素值相同的元素需要在队列中保存多份。

```c++
#include <iostream>
#include <deque>

using namespace std;

const int N = 1e6;

int n, k, arr[N];

void solutionMin() {
    deque<int> deq;
    
    for (int i = 0; i < n; i++) {
        int j = i - k + 1;
        
        if (j > 0 && deq.front() == arr[j - 1]) {
            deq.pop_front();
        }
        
        while (!deq.empty() && deq.back() > arr[i]) {
            deq.pop_back();
        }
        deq.push_back(arr[i]);
        
        if (j >= 0) {
            cout << deq.front() << " ";
        }
    }
    
    cout << endl;
}

void solutionMax() {
    deque<int> deq;
    
    for (int i = 0; i < n; i++) {
        int j = i - k + 1;
        
        if (j > 0 && deq.front() == arr[j - 1]) {
            deq.pop_front();
        }
        
        while (!deq.empty() && deq.back() < arr[i]) {
            deq.pop_back();
        }
        deq.push_back(arr[i]);
        
        if (j >= 0) {
            cout << deq.front() << " ";
        }
    }
    
    cout << endl;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    solutionMin();
    solutionMax();
    
    return 0;
}
```



### 2.LeetCode 0239 Sliding Window Maximum

You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return *the max sliding window*.

 

**Example 1:**

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

 

**Constraints:**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`



#### Algorithm 1:

Time Complexity = O(n).

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> deq;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= k && deq.front() == nums[i - k]) {
                deq.pop_front();
            }
            while (!deq.empty() && deq.back() < nums[i]) {
                deq.pop_back();
            }
            deq.push_back(nums[i]);
            if (i >= k - 1) {
                res.push_back(deq.front());
            }
        }
        return res;
    }
    
};
```





## 2-6 并查集

### 0.并查集模板

时间复杂度：初始化：O(n)，查找/合并：O($\alpha(n)$)。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

class UFSet { 
private:
    int n;                  // Number of nodes
    vector<int> fa;         // Array to store parent pointers

public:
    // Initialize UFSet with number of nodes
    UFSet(int numNodes) {
        n = numNodes;       	// Initialize number of nodes
        fa.assign(n + 1, -1);	// Initialize parent pointers to -1
    }
    
    // Find the root of x with path compression
    int find(int x) {
        return fa[x] < 0 ? x : fa[x] = find(fa[x]);
    }
    
    // Union the sets containing x and y by rank
    void unite(int x, int y) {
        int rx = find(x), ry = find(y);
        if (rx == ry) {
            return;
        }
        
        if (fa[rx] < fa[ry]) {  // Ensure ry is the root of the larger set
            swap(rx, ry);
        }
        fa[ry] += fa[rx];       // Merge rx into ry
        fa[rx] = ry;            // Update parent of rx to ry
    }
    
    // Determine whether the two nodes are connected
    bool isConnected(int x, int y) {
        return find(x) == find(y);
    }
    
    // Get set size of x
    int getSetSize(int x) {
        return -fa[find(x)];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    UFSet ufs(n);
    

    
    return 0;
}
```



### 1.AcWing0836 合并集合

一共有 *n* 个数，编号是 1∼*n* ，最开始每个数各自在一个集合中。

现在要进行 *m* 个操作，操作共有两种：

1. `M a b`，将编号为 *a* 和 *b* 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 *a* 和 *b* 的两个数是否在同一个集合中；

#### 输入格式

第一行输入整数 *n* 和 *m* 。

接下来 *m* 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。

#### 输出格式

对于每个询问指令 `Q a b`，都要输出一个结果，如果 *a* 和 *b* 在同一集合内，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

#### 数据范围

1 ≤ *n* , *m* ≤ 10^5



#### 输入样例：

```
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
```

#### 输出样例：

```
Yes
No
Yes
```



#### 算法思想：

**（1） 并查集简介**

并查集（Disjoint Set）是一种用于处理集合合并与查询问题的数据结构。它主要支持以下两种操作：

1. **合并（Union）：** 将两个集合合并为一个集合。
2. **查找（Find）：** 查找某个元素所属的集合。

并查集常用于解决连通性问题，例如判断图中的两个节点是否连通，以及求解最小生成树等。

并查集的典型应用场景包括但不限于：

- **网络连通性问题：** 在网络中判断两个节点是否连通。
- **最小生成树算法：** 如 Kruskal 算法。
- **图论问题：** 如求解最短路径、最小生成树等。

并查集通常由一个数组表示，数组的每个元素代表一个集合中的一个元素，通过数组的元素来确定集合之间的关系。在实际应用中，还可以使用树形结构或者其他数据结构来实现并查集。

常用的并查集操作包括：

- **初始化并查集：** 初始化数组，使得每个元素都是一个单独的集合。
- **合并两个集合：** 将两个集合合并为一个集合。
- **查找某个元素所属的集合：** 查找某个元素所在的集合，并返回其代表元素（也称为根节点）。

在实现并查集时，通常会采用优化技术来提高效率，如**路径压缩**和**按秩合并**等。

**（2） 基本操作**

1. **初始化（init）： **将所有节点初始化为只有一个节点的集合。

2. **合并（Union）：** 将两个集合合并为一个集合。

   分别找到两个集合的根节点，然后将根 1 指向根 2  。

3. **查找（Find）：** 查找某个元素所属的集合。

   查找根节点。

**（3） 优化技术**

1. **路径压缩：** 每次查找时，将查找路径上的所有节点都指向根节点。
2. **按秩合并：** 每次合并时，将秩较小的集合的根节点指向秩较大的集合的根节点。



#### 算法1：

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

class UFSet { 
private:
    int n;                  // Number of nodes
    vector<int> fa;         // Array to store parent pointers

public:
    // Initialize UFSet with number of nodes
    UFSet(int numNodes) {
        n = numNodes;       		// Initialize number of nodes
        fa.assign(n + 1, -1);	// Initialize parent pointers to -1
    }
    
    // Find the root of x with path compression
    int find(int x) {
        return fa[x] < 0 ? x : fa[x] = find(fa[x]);
    }
    
    // Union the sets containing x and y by rank
    void unite(int x, int y) {
        int rx = find(x), ry = find(y);
        if (rx == ry) {
            return;
        }
        
        if (fa[rx] < fa[ry]) {  // Ensure ry is the root of the larger set
            swap(rx, ry);
        }
        fa[ry] += fa[rx];       // Merge rx into ry
        fa[rx] = ry;            // Update parent of rx to ry
    }
    
    // Determine whether the two nodes are connected
    bool isConnected(int x, int y) {
        return find(x) == find(y);
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    UFSet ufs(n);
    
    while (m--) {
        char op;
        int x, y;
        cin >> op >> x >> y;
        if (op == 'M') {
            ufs.unite(x, y);
        } else {
            cout << (ufs.isConnected(x, y) ? "Yes" : "No") << '\n';
        }
    }
    
    return 0;
}
```





#### 算法2-并查集(154 ms)：

使用了路径压缩技术，但未使用按秩合并技术。

```c++
#include <iostream>

using namespace std;

const int N = 1e5;

int fa[N + 1], n;

int Find(int x) {
    return fa[x] ? fa[x] = Find(fa[x]) : x;
}

void Union(int x, int y) {
    int rx = Find(x), ry = Find(y);
    if (rx != ry) {
        fa[ry] = rx;
    }
}

bool query(int x, int y) {
    return Find(x) == Find(y);
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    while (m--) {
        char op;
        int x, y;
        cin >> op >> x >> y;
        
        if (op == 'M') {
            Union(x, y);
        }
        else {
            cout << (query(x, y) ? "Yes" : "No") << '\n';
        }
    }
    
    return 0;
}
```

时间复杂度：O(n)，

空间复杂度：O(n + m)。

经过路径压缩后，每次查找的时间开销为常数，每次合并的时间开销为常数。



#### 算法3-按秩合并(148 ms)：

除根节点外，每个节点都指向其父节点，后者为非负值。令根节点指向一个负值，其绝对值表示该集合的秩（即 该集合元素的总个数）。

合并时，将秩较小的集合的根指向较大的集合的根，并更新较大的集合的秩为二者之和。

由于通过路径压缩技术已经可以将查找和合并操作的时间开销优化为常数，因此再同时使用按秩合并技术优化的额外效果已经不明显了。(只比算法 1 快了 9 ms， 速度大约快了 6.1%)

```c++
#include <cstdio>

const int N = 1e5;

int arr[N + 1];

void init(int n) {
    for (int i = 1; i <= n; ++i) {
        arr[i] = -1;
    }
}

int find(int x) {
	if (arr[x] < 0) {
        return x;
    }
    // 路径压缩
    return arr[x] = find(arr[x]);
}

void Union(int x, int y) {
    x = find(x);
    y = find(y);
    if (x == y) {
        return;
    }
    // 若 x 的秩比 y 小，则更新 y 的秩并将 x 指向 y
    if (arr[x] > arr[y]) {
        arr[y] += arr[x];
        arr[x] = y;
    }
    else {
        arr[x] += arr[y];
        arr[y] = x;
    }
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    
    init(n);
    while(m--) {
        char op;
        int x, y;
        scanf(" %c%d%d", &op, &x, &y);
        
        if (op == 'M') {
            Union(x, y);
        }
        else {
            printf("%s\n", find(x) == find(y) ? "Yes" : "No");
        }
    }
    
    return 0;
}
```





### 32.AcWing0837 联通块中点的数量

给定一个包含 *n* 个点（编号为 1∼*n* ）的无向图，初始时图中没有边。

现在要进行 *m* 个操作，操作共有三种：

1. `C a b`，在点 *a* 和点 *b* 之间连一条边，*a* 和 *b* 可能相等；
2. `Q1 a b`，询问点 *a* 和点 *b* 是否在同一个连通块中，*a* 和 *b* 可能相等；
3. `Q2 a`，询问点 *a* 所在连通块中点的数量；

#### 输入格式

第一行输入整数 *n* 和 *m* 。

接下来 *m* 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。

#### 输出格式

对于每个询问指令 `Q1 a b`，如果 *a* 和 *b* 在同一个连通块中，则输出 `Yes`，否则输出 `No`。

对于每个询问指令 `Q2 a`，输出一个整数表示点 *a* 所在连通块中点的数量。

每个结果占一行。

#### 数据范围

1 ≤ *n* , *m* ≤ 10^5



#### 输入样例：

```
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
```

#### 输出样例：

```
Yes
2
3
```



#### 算法思想：

每个联通块构成一个集合，维护一个并查集的数据结构。集合的根维护一个负值，其绝对值表示该集合中点的数量。采用路径压缩与按秩合并技术。



#### 算法1：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

class UFSet { 
private:
    int n;                  // Number of nodes
    vector<int> fa;         // Array to store parent pointers

public:
    // Initialize UFSet with number of nodes
    UFSet(int numNodes) {
        n = numNodes;       		// Initialize number of nodes
        fa.assign(n + 1, -1);	// Initialize parent pointers to -1
    }
    
    // Find the root of u with path compression
    int find(int x) {
        return fa[x] < 0 ? x : fa[x] = find(fa[x]);
    }
    
    // Union the sets containing u and v by rank
    void unite(int x, int y) {
        int rx = find(x), ry = find(y);
        if (rx == ry) {
            return;
        }
        
        if (fa[rx] < fa[ry]) {  // Ensure ry is the root of the larger set
            swap(rx, ry);
        }
        fa[ry] += fa[rx];       // Merge rx into ry
        fa[rx] = ry;            // Update parent of rx to ry
    }
    
    // Determine whether the two nodes are connected
    bool isConnected(int x, int y) {
        return find(x) == find(y);
    }
    
    // Get set size of x
    int getSetSize(int x) {
        return -fa[find(x)];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    UFSet ufs(n);
    
    while (m--) {
        string op;
        cin >> op;
        if (op == "C") {
            int x, y;
            cin >> x >> y;
            ufs.unite(x, y);
        } else if (op == "Q1") {
            int x, y;
            cin >> x >> y;
            cout << (ufs.isConnected(x, y) ? "Yes" : "No") << '\n';
        } else {
            int x;
            cin >> x;
            cout << ufs.getSetSize(x) << '\n';
        }
    }
    
    return 0;
}
```



#### 算法2-并查集(146 ms)：

```c++
#include <cstdio>

const int N = 1e5;

int arr[N + 1];

void init(int n) {
    for (int i = 1; i <= n; ++i) {
        arr[i] = -1;
    }
}

int findRoot(int x) {
    if (arr[x] < 0) {
        return x;
    }
    // 路径压缩
    return arr[x] = findRoot(arr[x]);
}

void unionSets(int x, int y) {
    x = findRoot(x);
    y = findRoot(y);
    if (x == y) {
        return;
    }
    
    // 如果集合 x 的秩小于 y ，则将 x 并入 y 中
    if (arr[x] > arr[y]) {
        arr[y] += arr[x];
        arr[x] = y;
    }
    else {
        arr[x] += arr[y];
        arr[y] = x;
    }
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    
    init(n);
    while (m--) {
        char op[3];
        int a, b;
        scanf(" %s", op);
        
        if (op[0] == 'C') {
            scanf("%d %d", &a, &b);
            unionSets(a, b);
        }
        else if (op[0] == 'Q' && op[1] == '1') {
            scanf("%d %d", &a, &b);
            printf("%s\n", findRoot(a) == findRoot(b) ? "Yes" : "No");
        }
        else {
            scanf("%d", &a);
            printf("%d\n", -arr[findRoot(a)]);
        }
    }
    
    return 0;
}
```

时间复杂度：所有基本操作的时间都优化为常数。

空间复杂度：O(n)，用于存储所有点。



#### 算法2-并查集(689 ms)：

与算法 1 基本等同。区别在于使用c++风格的输入输出流和字符串。(总时间开销是算法 1 的 4 倍多)

```c++
#include <iostream>
#include <string>

using namespace std;

const int N = 1e5;

int arr[N + 1], n;

void init() {
    for (int i = 1; i <= n; ++i) {
        arr[i] = -1;
    }
}

int findRoot(int x) {
    if (arr[x] < 0) {
        return x;
    }
    
    return arr[x] = findRoot(arr[x]);
}

void unionSets(int x, int y) {
    x = findRoot(x);
    y = findRoot(y);
    if (x == y) {
        return;
    }
    
    if (arr[x] > arr[y]) {
        arr[y] += arr[x];
        arr[x] = y;
    }
    else {
        arr[x] += arr[y];
        arr[y] = x;
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    init();
    while (m--) {
        string op;
        cin >> op;
        
        int a, b;
        if (op == "C") {
            cin >> a >> b;
            unionSets(a, b);
        }
        else if (op == "Q1") {
            cin >> a >> b;
            cout << (findRoot(a) == findRoot(b) ? "Yes" : "No") << endl;
        }
        else {
            cin >> a;
            cout << -arr[findRoot(a)] << endl;
        }
    }
    
    return 0;
}
```





### 33.AcWing0240 食物链(medium)

动物王国中有三类动物 *A*,*B*,*C* , 这三类动物的食物链构成了有趣的环形。

*A* 吃 *B*，*B* 吃 *C*，*C* 吃 *A*。

现有 *N* 个动物，以 1∼*N* 编号。

每个动物都是 *A* , *B* , *C* 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 *N* 个动物所构成的食物链关系进行描述：

第一种说法是 `1 X Y`，表示 *X* 和 *Y* 是同类。

第二种说法是 `2 X Y`，表示 *X* 吃 *Y* 。

此人对 *N* 个动物，用上述两种说法，一句接一句地说出 *K* 句话，这 *K* 句话有的是真的，有的是假的。

当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

1. 若当前的话与前面的某些真的话冲突，则当前的话为假话；
2. 若当前的话中 *X* 或 *Y* 比 *N* 大，则当前的话就是假话；
3. 若当前的话表示 *X* 吃 *X* ，则当前的话为假话。

你的任务是根据给定的 *N* 和 *K* 句话，输出假话的总数。

#### 输入格式

第一行是两个整数 *N* 和 *M* ，以一个空格分隔。

以下 *M* 行每行是三个正整数 *D*，*X*，*Y*，两数之间用一个空格隔开，其中 *D* 表示说法的种类。

若 *D* = 1，则表示 *X* 和 *Y* 是同类。

若 *D* = 2，则表示 *X* 吃 *Y* 。

#### 输出格式

只有一个整数，表示假话的数目。

#### 数据范围

1 ≤ *N* ≤ 50000 ,
0 ≤ *M* ≤ 100000



#### 输入样例：

```
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
```

#### 输出样例：

```
3
```



#### 算法思想1：

维护一个并查集的数据结构。将相对关系已知的动物放在一个集合。并维护一个一维数组，保存各节点到其父节点的**距离**。

**距离**的定义如下：将食物链 “*A* 吃 *B*，*B* 吃 *C*，*C* 吃 *A* “ 记作“ A -> B -> C -> A ” 。若从 X 出发沿着箭头走 dist 个单位到达 R , 则称节点 X 到节点 R 的距离为 dist 。例如，A 到 B 的距离为 1, 4, 7, ... ，表示 A 吃 B ； A 到 C 的距离为 2, 5, 8, ... ，表示 C 吃 A ；A 到 A1 的距离为 0 , 3, 6, ...，表示 A 与 A1 为同类。



#### 算法1：

Time Complexity = O($n + m\alpha(n)$).

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

class UFSet { 
private:
    int n;                  // Number of nodes
    vector<int> fa;         // Array to store parent pointers
    vector<int> dist;       // Array to store distance in food chain from x to its father
public:
    // Initialize UFSet with number of nodes
    UFSet(int numNodes) {
        n = numNodes;       	// Initialize number of nodes
        fa.assign(n + 1, -1);	// Initialize parent pointers to -1
        dist.assign(n + 1, 0);
    }
    
    // Find the root of x with path compression
    int find(int x) {
        if (fa[x] < 0) {
            return x;
        }
        int rx = find(fa[x]);
        dist[x] = (dist[x] + dist[fa[x]]) % 3;
        return fa[x] = rx;
    }
    
    // Union the sets containing x and y
    void unite(int x, int y, int dxy) {
        int rx = find(x), ry = find(y);
        if (rx == ry) {
            return;
        }
        
        fa[ry] += fa[rx];       // Merge rx into ry
        fa[rx] = ry;            // Update parent of rx to ry
        dist[rx] = (-dist[x] + dxy + dist[y] + 3) % 3;
    }
    
    bool isTale(int x, int y, int dxy) {
        if (x > n || y > n) {
            return true;
        }
    	int rx = find(x), ry = find(y);
    	if (rx == ry) { // Same set, check consistency
            return (dist[x] - dist[y] + 3) % 3 != dxy;
        }
        // Different sets, merge with the given relationship
        unite(x, y, dxy);
        return false;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    UFSet ufs(n);
    
    int ans = 0;
    while (m--) {
        int op, x, y;
        cin >> op >> x >> y;
        ans += ufs.isTale(x, y, op - 1);
    }
    cout << ans << '\n';
    
    return 0;
}
```





#### 算法 1(89 ms)：

```c++
#include <iostream>

using namespace std;

const int N = 5e4;

int n, fa[N + 1], dist[N + 1];
int cnt;

int findRoot(int x) {
	if (!fa[x]) {
		return x;
	}
	
	int rx = findRoot(fa[x]);
	dist[x] = (dist[x] + dist[fa[x]]) % 3;
	return fa[x] = rx;
}

void process(int x, int y, int d) {
	int rx = findRoot(x), ry = findRoot(y);
	int dxy = (dist[x] - dist[y] + 3) % 3;
	if (x > n || y > n || rx == ry && dxy != d) {
		++cnt;
		return;
	}
	
	if (rx != ry) {
		fa[rx] = ry;
		dist[rx] = (-dist[x] + d + dist[y] + 3) % 3;
	}
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int k;
	cin >> n >> k;
	
	while (k--) {
		int op, x, y;
		cin >> op >> x >> y;
		process(x, y, op - 1);
	}
	
	cout << cnt; 
	
	return 0;
}
```



#### 算法2(77 ms)：

```c++
#include <cstdio>

const int N = 50000;

// arr[i]保存 i 结点的父节点
// 根节点指向默认的 0
int arr[N + 1], n, cnt;
// dist[i] 保存 i 到父节点 arr[i] 的距离
int dist[N + 1];

int findRoot(int x) {
    if (!arr[x]) {
        return x;
    }
    
    // 先递归，再更新 dist ,从而保证从根向叶更新 dist
    int root = findRoot(arr[x]);
    dist[x] = (dist[x] + dist[arr[x]]) % 3;
    arr[x] = root;
    return root;
}

// 处理说法1：x 与 y 为同类
void solution1(int x, int y) {
    // 若越界，则该说法为假
    if (x > n || y > n) {
        ++cnt;
        return;
    }
    
    int rx = findRoot(x), ry = findRoot(y);
    int d = (dist[x] - dist[y] + 3) % 3;
    // 如果在同一个集合，且相对距离不为0(mod 3),则该说法为假
    if (rx == ry && d != 0 ) {
        ++cnt;
        return;
    }
    // 否则，该说法为真。若不在同一集合，则合并集合
    else if (rx != ry) {
        arr[ry] = rx;
        dist[ry] = d;
    }
}

// 处理说法2：x 吃 y
void solution2(int x, int y) {
    // 若越界，则该说法为假
    if (x > n || y > n) {
        ++cnt;
        return;
    }
    
    int rx = findRoot(x), ry = findRoot(y);
    int d = (dist[x] - dist[y] + 3) % 3;
    // 如果在同一个集合，且相对距离不为1(mod 3),则该说法为假
    if (rx == ry && d != 1 ) {
        ++cnt;
        return;
    }
    // 否则，该说法为真。若不在同一集合，则合并集合
    else if (rx != ry) {
        arr[ry] = rx;
        dist[ry] = d - 1;
    }
}

int main() {
    int m;
    scanf("%d %d", &n, &m);
    
    while (m--) {
        int op, x, y;
        scanf("%d %d %d", &op, &x, &y);
        
        if (op == 1) {
            solution1(x, y);
        }
        else {
            solution2(x, y);
        }
    }
    
    printf("%d", cnt);
    return 0;
}
```







#### 算法思想x：

维护一个并查集。将所有已知的同类动物划分在同一个集合中。不同种类的或者暂时未知种类是否相同的划分在不同的集合。

同一个集合内，所有非根节点直接或间接地指向根节点，根节点 x 维护一个非负值 `arr[x]`，初值为 0 ，表示该动物食性未知。若 `arr[x]` 为负值，表示其指向根节点为 `-arr[x]` 的集合，并捕食后者。

1. `1 X Y` ：表示 *X* 和 *Y* 是同类。
   - 若 X 或 Y 大于 N ，则该话为假话。
   - 查找二者的根 x , y , 若 x 吃 y 或 y 吃 x , 则该话为假话；
   - 否则，合并两个集合，并分别合并其各自捕食对象的集合（如果有的话），与各自捕食对象的捕食对象的集合（如果有的话）。
2. `2 X Y` : 表示 X 吃 Y 。
   - 若 X 或 Y 大于 N ，则该话为假话。
   - 查找二者的根 x , y , 若 x, y 为同类或 y 吃 x , 则为假话；
   - 否则，则更新：x 吃 y 。顺便地，如果 y 吃 z , 则 z 吃 x ；（如果 x’ 吃 y ，则 x 与 x’ 为同类）（后半句我们已知，但未更新，因为不能快速查找到 x’ 。然而，这不影响我们判断二者是否为同类：我们通过 x 与 x’ 是否位于同一个集合或是否指向同一个非负值来判断二者是否为同类）。





#### 算法 x ：

这种方法暂时弃置。自认为理论上应该是可行的，但实际操作需要分很多情况讨论，过于繁琐，留待以后探讨。（2024-02-20）

```c++
#include <cstdio>

const int N = 50000;

int arr[N + 1];
int n;
int cnt;

int findRoot(int x) {
    if (arr[x] <= 0) {
        return x;
    }
    return arr[x] = findRoot(arr[x]);
}

// 合并时，顺便合并各自捕食对象的集合
void unionSets(int x, int y) {
    x = findRoot(x);
    y = findRoot(y);
    if (x == y) {
        return;
    }
    
    int x1 = -arr[x], y1 = -arr[y];
    // 若 x 食性已知，则将 y 并入 x
    if (x1) {
        arr[y] = -x;
        // 如果 y 食性也已知，则递归地合并 x1 与 y1
        if (y1) {
            unionSets(x1, y1);
        }
    }
    // 如果 x 食性未知，则将 x 并入 y
    else {
        arr[x] = -y;
    }
}

// 处理：是否为同类
void solution1(int x, int y) {
    if (x > n || y > n) {
        ++cnt;
        return;
    }
    
    x = findRoot(x);
    y = findRoot(y);
    if (arr[x] && arr[y] && (arr[x] == -y || arr[y] == -x)) {
        ++cnt;
        return;
    }
    
    unionSets(x, y);
}

// 处理：是否 x 吃 y
void solution2(int x, int y) {
    if (x > n || y > n) {
        ++cnt;
        return;
    }
    
    x = findRoot(x);
    y = findRoot(y);
    
}

int main() {
    int k;
    scanf("%d %d", &n, &k);
    
    while (k--) {
        int op, x, y;
        scanf("%d %d %d", &op, &x, &y);
        
        if (op == 1) {
            solution1(x, y);
        }
        else {
            solution2(x, y);
        }
    }
    
    printf("%d", cnt);
}

```







## 2-7 链表

### 1.LeetCode 0203 Remove Linked List Elements

Given the `head` of a linked list and an integer `val`, remove all the nodes of the linked list that has `Node.val == val`, and return *the new head*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

```
Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]
```

**Example 2:**

```
Input: head = [], val = 1
Output: []
```

**Example 3:**

```
Input: head = [7,7,7,7], val = 7
Output: []
```

 

**Constraints:**

- The number of nodes in the list is in the range `[0, 104]`.
- `1 <= Node.val <= 50`
- `0 <= val <= 50`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *hd = new ListNode(0, head), *p = hd;
        while (p->next != nullptr) {
            ListNode *q = p->next;
            if (q->val == val) {
                p->next = q->next;
                delete q;
            }
            else {
                p = q;
            }
        }
        head = hd->next;
        delete hd;
        return head;
    }
};
```



### 2.LeetCode 0707 Design Linked List

Design your implementation of the linked list. You can choose to use a singly or doubly linked list.
 A node in a singly linked list should have two attributes: `val` and `next`. `val` is the value of the current node, and `next` is a pointer/reference to the next node.
 If you want to use the doubly linked list, you will need one more attribute `prev` to indicate the previous node in the linked list. Assume all nodes in the linked list are **0-indexed**.

Implement the `MyLinkedList` class:

- `MyLinkedList()` Initializes the `MyLinkedList` object.
- `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid, return `-1`.
- `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
- `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list.
- `void addAtIndex(int index, int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list, the node will be appended to the end of the linked list. If `index` is greater than the length, the node **will not be inserted**.
- `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list, if the index is valid.

 

**Example 1:**

```
Input
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
Output
[null, null, null, null, 2, null, 3]

Explanation
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3
myLinkedList.get(1);              // return 3
```

 

**Constraints:**

- `0 <= index, val <= 1000`
- Please do not use the built-in LinkedList library.
- At most `2000` calls will be made to `get`, `addAtHead`, `addAtTail`, `addAtIndex` and `deleteAtIndex`.



##### Algorithm 1:

```c++
struct Node {
    int val;
    Node *next;
    Node(int val, Node *next) : val(val), next(next) {}
};

class MyLinkedList {
public:
    MyLinkedList() {
        head = new Node(0, nullptr);
        size = 0;
    }
    
    int get(int index) {
        if (index < 0 || index >= size) {
            return -1;
        }

        Node *p = head->next;
        while (index--) {
            p = p->next;
        }
        return p->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if (index < 0 || index > size) {
            return;
        }

        Node *p = head;
        while (index--) {
            p = p->next;
        }

        Node *q = new Node(val, p->next);
        p->next = q;
        size++;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {
            return;
        }

        Node *p = head;
        while (index--) {
            p = p->next;
        }
        Node *q = p->next;
        p->next = q->next;
        delete q;
        size--;
    }

private:
    int size;
    Node *head;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```



### 3.LeetCode 0206 Reverse Linked List

Given the `head` of a singly linked list, reverse the list, and return *the reversed list*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**

```
Input: head = []
Output: []
```

 

**Constraints:**

- The number of nodes in the list is the range `[0, 5000]`.
- `-5000 <= Node.val <= 5000`

 

**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?

 

##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) {
            return head;
        }

        ListNode *p = head->next;
        head->next = nullptr;
        while (p) {
            ListNode *q = p;
            p = p->next;
            q->next = head;
            head = q;
        }
        return head;
    }
};
```



### 4.LeetCode 0024 Swap Nodes in Pairs

Given  a linked list, swap every two adjacent nodes and return its head. You  must solve the problem without modifying the values in the list's nodes  (i.e., only nodes themselves may be changed.)

 

**Example 1:**

**Input:** head = [1,2,3,4]

**Output:** [2,1,4,3]

**Explanation:**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

**Example 2:**

**Input:** head = []

**Output:** []

**Example 3:**

**Input:** head = [1]

**Output:** [1]

**Example 4:**

**Input:** head = [1,2,3]

**Output:** [2,1,3]

 

**Constraints:**

- The number of nodes in the list is in the range `[0, 100]`.
- `0 <= Node.val <= 100`



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *hd = new ListNode(0, head);
        ListNode *pre = hd;
        while (pre->next && pre->next->next) {
            ListNode *p = pre->next, *q = p->next;
            p->next = q->next;
            q->next = p;
            pre->next = q;
            pre = p;
        }
        
        head = hd->next;
        delete hd;
        return head;
    }
};
```



### 5.LeetCode 0019 Remove Nth Node From End of List

Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Example 2:**

```
Input: head = [1], n = 1
Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 1
Output: [1]
```

 

**Constraints:**

- The number of nodes in the list is `sz`.
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

 

**Follow up:** Could you do this in one pass?

 

##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *hd = new ListNode(0, head);
        ListNode *p = hd->next, *q = hd;
        int cnt = 1;
        while (p) {
            p = p->next;
            // 找到倒数第 n + 1 个结点 q
            if (++cnt > n + 1) {
                q = q->next;
            }
        }
        p = q->next;
        q->next = p->next;
        delete p;

        head = hd->next;
        delete hd;
        return head;
    }
};
```



### 6.LeetCode 面试题02.07 Intersection of Two Linked Lists LCCI

Given  two (singly) linked lists, determine if the two lists intersect. Return  the inter­ secting node. Note that the intersection is defined based on  reference, not value. That is, if the kth node of the first linked list  is the exact same node (by reference) as the jth node of the second  linked list, then they are intersecting.

**Example 1:** 

```
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
```

**Example 2:** 

```
Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Reference of the node with value = 2
Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
```

**Example 3:** 

```
Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: null
Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.
```

**Notes:**

- If the two linked lists have no intersection at all, return `null`.
- The linked lists must retain their original structure after the function returns.
- You may assume there are no cycles anywhere in the entire linked structure.
- Your code should preferably run in O(n) time and use only O(1) memory.

 

##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    int getLen(ListNode *head) {
        int cnt = 0;
        while (head) {
            cnt++;
            head = head->next;
        }
        return cnt;
    }

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = getLen(headA), lenB = getLen(headB);
        ListNode *pA = headA, *pB = headB; 
        while (lenA > lenB) {
            pA = pA->next;
            lenA--;
        }
        while (lenA < lenB) {
            pB = pB->next;
            lenB--;
        }

        while (pA != pB) {
            pA = pA->next;
            pB = pB->next;
        }
        return pA;
    }
};
```



### 7.LeetCode 0011 Linked List CycleII

Given the `head` of a linked list, return *the node where the cycle begins. If there is no cycle, return* `null`.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to (**0-indexed**). It is `-1` if there is no cycle. **Note that** `pos` **is not passed as a parameter**.

**Do not modify** the linked list.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

```
Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

```
Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.
```

 

**Constraints:**

- The number of the nodes in the list is in the range `[0, 10^4]`.
- `-10^5 <= Node.val <= 10^5`
- `pos` is `-1` or a **valid index** in the linked-list.

 

##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *hd = new ListNode(0, head);
        ListNode *p = hd, *q = hd;
        while (p->next && p->next->next) {
            p = p->next->next;
            q = q->next;
            if (p == q) {
                q = hd;
                while (p != q) {
                    p = p->next;
                    q = q->next;
                }
                delete hd;
                return p;
            }
        }

        delete hd;
        return nullptr;
    }
};
```







## 2-7 哈希表

### 1.LeetCode 0242 Valid Anagram

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

**Tips:** An **anagram** is a word or phrase formed by rearranging the letters of a  different word or phrase, using all the original letters exactly once.

 

**Example 1:**

**Input:** s = "anagram", t = "nagaram"

**Output:** true

**Example 2:**

**Input:** s = "rat", t = "car"

**Output:** false

 

**Constraints:**

- `1 <= s.length, t.length <= 5 * 10^4`
- `s` and `t` consist of lowercase English letters.

 

 

##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        vector<int> counts(26, 0);

        for (auto c : s) {
            counts[c - 'a']++;
        }
        for (auto c : t) {
            counts[c - 'a']--;
        }

        for (auto count : counts) {
            if (count) {
                return false;
            }
        }
        return true;
    }
};
```





### 2.LeetCode 0349 Intersection of Two Arrays

Given two integer arrays `nums1` and `nums2`, return *an array of their*  *intersection* . Each element in the result must be **unique** and you may return the result in **any order**.

 

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
```

 

**Constraints:**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`



##### Algorithm 1:

Time Complexity = $O(n_1 + n_2 + M)$ .

```c++
const int N = 1001;

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int> state(N + 1, 0);
        for (int i = 0; i < nums1.size(); i++) {
            state[nums1[i]] |= 1;
        }
        for (int i = 0; i < nums2.size(); i++) {
            state[nums2[i]] |= 2;
        }

        vector<int> res;
        for (int i = 0; i <= N; i++) {
            if (state[i] == 3) {
                res.push_back(i);
            }
        }
        return res;
    }
};
```





### 3.LeetCode 0001 Two Sum

Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

You may assume that each input would have ***exactly* one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

 

**Example 1:**

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**

```
Input: nums = [3,3], target = 6
Output: [0,1]
```

 

**Constraints:**

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **Only one valid answer exists.**



##### Algorithm 1-Two Pointers:

Time Complexity = $O(n \log n)$ .

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        vector<pair<int, int> > nums2(n);
        for (int i = 0; i < n; i++) {
            nums2[i] = {nums[i], i};
        }

        sort(nums2.begin(), nums2.end());
        int i = 0, j = n - 1;
        while (i < j) {
            int sum = nums2[i].first + nums2[j].first;
            if (sum == target) {
                return {nums2[i].second, nums2[j].second};
            }
            else if (sum > target) {
                j--;
            }
            else {
                i++;
            }
        }

        return {-1, -1};
    }
};
```



##### Algorithm 2-Hash Table:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```





### 4.LeetCode 0454 4Sum II

Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4` all of length `n`, return the number of tuples `(i, j, k, l)` such that:

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

 

**Example 1:**

```
Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Output: 2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**Example 2:**

```
Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
Output: 1
```

 

**Constraints:**

- `n == nums1.length`
- `n == nums2.length`
- `n == nums3.length`
- `n == nums4.length`
- `1 <= n <= 200`
- `-2^28 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 2^28`



##### Algorithm 1:

Time Complexity = $O(n ^ 2)$ .

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        std::unordered_map<int, int> sum12;
        int n = nums1.size();
        for (int x : nums1) {
            for (int y : nums2) {
                sum12[x + y]++;
            }
        }

        int res = 0;
        for (int x : nums3) {
            for (int y : nums4) {
                res += sum12[-x - y];
            }
        }
        return res;
    }
};
```





### 5.LeetCode 0383 Ransom Note

Given two strings `ransomNote` and `magazine`, return `true` *if* `ransomNote` *can be constructed by using the letters from* `magazine` *and* `false` *otherwise*.

Each letter in `magazine` can only be used once in `ransomNote`.

 

**Example 1:**

```
Input: ransomNote = "a", magazine = "b"
Output: false
```

**Example 2:**

```
Input: ransomNote = "aa", magazine = "ab"
Output: false
```

**Example 3:**

```
Input: ransomNote = "aa", magazine = "aab"
Output: true
```

 

**Constraints:**

- `1 <= ransomNote.length, magazine.length <= 10^5`
- `ransomNote` and `magazine` consist of lowercase English letters.



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int count[26] = {0};
        for (auto c : magazine) {
            count[c - 'a']++;
        }

        for (auto c : ransomNote) {
            if (--count[c - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
};
```





### 6.LeetCode 0015 3Sum

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

 

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**

```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

 

**Constraints:**

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`



##### Algorithm 1:

Time Complexity = $O(n ^ 2)$ .

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();

        vector<vector<int>> res;
        for (int i = 0; i < n; i++) {
            // Find binary group with sum -nums[i] in nums[i+1..n-1]
            int j = i + 1, k = n - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    res.push_back({nums[i], nums[j], nums[k]});
                    while (++j < k && nums[j] == nums[j - 1]) ;
                } else if (sum > 0) {
                    k--;
                } else {
                    j++;
                }
            }

            while (++i < n && nums[i] == nums[i - 1]) ;
            i--;
        }

        return res;
    }
};
```





### 7.LeetCode 0018 4Sum

Given an array `nums` of `n` integers, return *an array of all the **unique** quadruplets* `[nums[a], nums[b], nums[c], nums[d]]` such that:

- `0 <= a, b, c, d < n`
- `a`, `b`, `c`, and `d` are **distinct**.
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

You may return the answer in **any order**.

 

**Example 1:**

```
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**Example 2:**

```
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
```

 

**Constraints:**

- `1 <= nums.length <= 200`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`



##### Algorithm 1:

Time Complexity = $O(n ^ 3)$ .

```c++
class Solution {
public:
    // 寻找下一个值不为 nums[i] 的元素, 返回其位序
    int next(vector<int>& nums, int i) {
        while (++i < nums.size() && nums[i] == nums[i - 1]) ;
        return i;
    }
    
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int n = nums.size();

        vector<vector<int>> res;
        for (int i = 0; i < n; i = next(nums, i)) {
            for (int j = i + 1; j < n; j = next(nums, j)) {
                // Find binary group with sum targ in nums[j+1..n-1]
                long long targ = (long long)target - nums[i] - nums[j];
                int k = j + 1, l = n - 1;
                while (k < l) {
                    int sum = nums[k] + nums[l];
                    if (sum == targ) {
                        res.push_back({nums[i], nums[j], nums[k], nums[l]});
                        k = next(nums, k);
                    } else if (sum > targ) {
                        l--;
                    } else {
                        k++;
                    }
                }
            }
        }
        return res;
    }
};
```







## 2-8 红黑树





## 2-9 字典树

### 0.字典树模板

#### 模板1

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

struct TreeNode {
    static const int NC = 26;       // Number of Children
    int count;
    vector<TreeNode*> child;
    
    TreeNode() : count(0), child(NC, nullptr) {}
};

class Trie {
private:
    TreeNode* root;
public:
    Trie() {
        root = new TreeNode;
    }
    
    void insert(string& s) {
        TreeNode* p = root;
        for (auto c : s) {
            int k = c - 'a';
            if (!p->child[k]) {
                p->child[k] = new TreeNode;
                p = p->child[k];
            }
            p = p->child[k];
        }
        p->count++;
    }
    
    int query(string& s) {
        TreeNode* p = root;
        for (auto c : s) {
            int k = c - 'a';
            p = p->child[k];
            if (!p) {
                return 0;
            }
        }
        
        return p->count;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    Trie T;

    
    
    return 0;
}
```



#### 模板2

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

class Trie {
private:
    static const int M = 1e5;
    int idx;
    vector<vector<int>> child;
    vector<int> count;
public:
    Trie() {
        idx = 1;
        child.assign(M + 1, vector<int>(26, 0));
        count.assign(M + 1, 0);
    }
    
    void insert(string& s) {
        int u = 0;
        for (auto c : s) {
            int k = c - 'a';
            if (!child[u][k]) {
                child[u][k] = idx++;
            }
            u = child[u][k];
        }
        count[u]++;
    }
    
    int query(string& s) {
        int u = 0;
        for (auto c : s) {
            int k = c - 'a';
            if (!child[u][k]) {
                return 0;
            }
            u = child[u][k];
        }
        return count[u];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    Trie T;

    
    
    return 0;
}
```



### 1.AcWing0835 Trie字符串统计

维护一个字符串集合，支持两种操作：

1. `I x` 向集合中插入一个字符串 *x* ；
2. `Q x` 询问一个字符串在集合中出现了多少次。

共有 *N* 个操作，所有输入的字符串总长度不超过 10^5 ，字符串仅包含小写英文字母。

#### 输入格式

第一行包含整数 *n* ，表示操作数。

接下来 *n* 行，每行包含一个操作指令，指令为 `I x` 或 `Q x` 中的一种。

#### 输出格式

对于每个询问指令 `Q x`，都要输出一个整数作为结果，表示 *x* 在集合中出现的次数。

每个结果占一行。

#### 数据范围

1 ≤ *n* ≤ 2∗10^4

所有输入的字符串总长度不超过 10^5，字符串仅包含小写英文字母。



#### 输入样例：

```
5
I abc
Q abc
Q ab
I ab
Q ab
```

#### 输出样例：

```
1
0
1
```



#### 算法思想：

**（1） Trie 树简介**

Trie树，也称为字典树、前缀树或单词查找树，是一种树形数据结构，用于高效地存储和检索字符串集合中的键值。Trie树通过将字符串中的字符按顺序存储在树的节点中，并使用共享前缀的方式来降低空间复杂度和提高检索效率。

在Trie树中，每个节点都表示一个字符串的字符，从根节点到叶子节点的路径构成了一个字符串。通常，根节点表示空字符串，而每个节点都可能对应一个或多个子节点，每个子节点代表一个字符。

Trie树的主要特点包括：

1. **前缀搜索：** Trie树支持按照前缀搜索字符串，可以高效地查找具有特定前缀的所有字符串。
2. **空间优化：** Trie树可以利用共享前缀的方式来减少存储空间，特别是在存储大量具有相似前缀的字符串时。
3. **插入和搜索效率高：** 插入和搜索操作的时间复杂度与待存储的字符串的长度无关，取决于Trie树的高度和字母表的大小。

Trie树支持两种基本操作:

1. **插入字符串：**`void insert(char *s)` 。
2. **查询字符串：**`int query(char *s)` 。

Trie树在许多应用中都有广泛的用途，例如单词自动完成、拼写检查、IP路由查找等。它提供了一种高效的方式来处理字符串集合，特别是当需要快速检索具有相同前缀的字符串时。

**（2） 辅助变量**

辅助变量包括 2 个数组和 1 个整型变量：

1. `int child[ML][26]` ,
2. `int cnt[N];`
3. `int idx = 0;`

其中，`ML`为所有插入的串中最长串的长度，`N` 为所有串的总长度。

将 a~z 这 26 个字符映射到数字 0~25 上。

数组`child`维护了一个 26 叉树，树的最大深度为 `N-1` （记根的深度为 0 ） 。其中， `child[p][j]` 表示从节点 `p` 沿着路径 `c` 将到达节点 `child[p][c]` 。所有元素初值为 0 ，表示节点未创建。

数组元素 `cnt[p]` 记录当前集合内以节点 `p` 结尾的串的数量。初值为 0 。

`idx` 记录当前 Trie 树的节点数量。初值为 0 ，表示只有根节点。其作用为：在插入串时，以创建的时间顺序为新创建的节点编号。

**（3） insert 过程描述**

1. 指针 i 从串的 0 号字符枚举到串尾。对于每个字符 c ，指针 p 指向 c 的前一个字符所在的节点。 p 的初值为 0 ，即指向根节点，表示空串。
2. `child[p][c]` 表示当前字符所在的节点。如果该节点未创建，则创建节点。
3. 当 i 右移一单位时，p 跟着向孩子节点移动一次。循环执行步骤 2 至步骤 3 ，直到 i 移到串尾。

**（4） query 过程描述**

1. 指针 i 从串的 0 号字符枚举到串尾。对于每个字符 c ，指针 p 指向 c 的前一个字符所在的节点。 p 的初值为 0 ，即指向根节点，表示空串。
2. `child[p][c]` 表示当前字符所在的节点。如果该节点未创建，说明查找失败，返回 0 。
3. 当 i 右移一单位前，p 随之向孩子节点移动一次。循环执行步骤 2 至步骤 3 ，直到 i 移到串尾。此时 `p` 为尾字符所在节点，若节点存在，返回 `cnt[p]` 。



#### 算法1：

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

struct TreeNode {
    static const int NC = 26;       // Number of Children
    int count;
    vector<TreeNode*> child;
    
    TreeNode() : count(0), child(NC, nullptr) {}
};

class Trie {
private:
    TreeNode* root;
public:
    Trie() {
        root = new TreeNode;
    }
    
    void insert(string& s) {
        TreeNode* p = root;
        for (auto c : s) {
            int k = c - 'a';
            if (!p->child[k]) {
                p->child[k] = new TreeNode;
            }
            p = p->child[k];
        }
        p->count++;
    }
    
    int query(string& s) {
        TreeNode* p = root;
        for (auto c : s) {
            int k = c - 'a';
            p = p->child[k];
            if (!p) {
                return 0;
            }
        }
        
        return p->count;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    Trie T;
    while (n--) {
        char op;
        string s;
        cin >> op >> s;
        if (op == 'I') {
            T.insert(s);
        } else {
            cout << T.query(s) << '\n';
        }
    }
    
    return 0;
}
```



#### 算法2：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>

using namespace std;

class Trie {
private:
    static const int M = 1e5;
    int idx;
    vector<vector<int>> child;
    vector<int> count;
public:
    Trie() {
        idx = 1;
        child.assign(M + 1, vector<int>(26, 0));
        count.assign(M + 1, 0);
    }
    
    void insert(string& s) {
        int u = 0;
        for (auto c : s) {
            int k = c - 'a';
            if (!child[u][k]) {
                child[u][k] = idx++;
            }
            u = child[u][k];
        }
        count[u]++;
    }
    
    int query(string& s) {
        int u = 0;
        for (auto c : s) {
            int k = c - 'a';
            if (!child[u][k]) {
                return 0;
            }
            u = child[u][k];
        }
        return count[u];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    Trie T;
    while (n--) {
        char op;
        string s;
        cin >> op >> s;
        
        if (op == 'I') {
            T.insert(s);
        }
        else {
            cout << T.query(s) << endl;
        }
    }
    
    return 0;
}
```



#### 算法3- Trie 字符串统计(84 ms)：

```c++
#include <iostream>

using namespace std;

const int N = 1e5;

int child[N + 1][26];
int idx, cnt[N + 1];

void insert(char s[]) {
    int p = 0;      // 从头结点出发
    for (int i = 0; s[i]; ++i) {
        int c = s[i] - 'a';
        if (!child[p][c]) {
            child[p][c] = ++idx;
        }
        p = child[p][c];
    }
    
    ++cnt[p];
}

int query(char s[]) {
    int p = 0;
    for (int i = 0; s[i]; ++i) {
        int c = s[i] - 'a';
        p = child[p][c];
        if (!p) {
            return 0;
        }
    }
    
    return cnt[p];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        char op, s[N];
        cin >> op >> s;
        
        if (op == 'I') {
            insert(s);
        }
        else {
            cout << query(s) << endl;
        }
    }
    
    return 0;
}
```



#### 算法4(39 ms)：

```c++
#include <iostream>
#include <string>

using namespace std;

const int N = 1e5;

int child[N + 1][26];
int idx = 0, cnt[N + 1];

void insert(string& s) {
    int p = 0;
    for (int i = 0; i < s.size(); ++i) {
        int c = s[i] - 'a';
        
        if (!child[p][c]) {
            child[p][c] = ++idx;
        }
        
        p = child[p][c];
    }
    
    ++cnt[p];
}

void insert(string s) {
    // 遍历当前串，p 指向前一个字符所在的节点
    int p = 0;
    for (int i = 0; i < s.size(); ++i) {
        int c = s[i] - 'a';		// 当前字符
        // 若当前结点未创建，创建节点并编号
        if (!child[p][c]) {
            child[p][c] = ++idx;
        }
        // p 从父节点移动到当前结点
        p = child[p][c];
    }
    
    // 以 p 所指结点结尾的串的数量加 1
    ++cnt[p];
    return;
}

int query(const string& s) {
    int p = 0;
    for (int i = 0; i < s.size(); ++i) {
        int c = s[i] - 'a';
        p = child[p][c];
        if (!p) {
            return 0;
        }
    }
    
    return cnt[p];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    while (n--) {
        char op;
        string s;
        cin >> op >> s;
        
        if (op == 'I') {
            insert(s);
        }
        else {
            cout << query(s) << endl;
        }
    }
    
    return 0;
}
```

时间复杂度：O(n * N)，

空间复杂度：O(N)。



#### 算法5 (137 ms):

与算法 1 基本等同，区别在于使用C++风格的字符串和输入输出。

```c++
#include <iostream>
#include <string>

using  namespace std;

const int N = 1e5;

int child[N][26];
int cnt[N];
int idx;

void insert(string s) {
    // 遍历当前串，p 指向前一个字符所在的节点
    int p = 0;
    for (int i = 0; i < s.size(); ++i) {
        int c = s[i] - 'a';		// 当前字符
        // 若当前结点未创建，创建节点并编号
        if (!child[p][c]) {
            child[p][c] = ++idx;
        }
        // p 从父节点移动到当前结点
        p = child[p][c];
    }
    
    // 以 p 所指结点结尾的串的数量加 1
    ++cnt[p];
    return;
}

int query(string s) {
    // 遍历当前串，p 指向前一个字符所在的节点
    int p = 0;
    for (int i = 0; i < s.size(); ++i) {
        int c = s[i] - 'a';		// 当前字符
        // p 指向当前结点
        p = child[p][c];
        // 若当前节点为空，返回0，查找失败
        if (!p) {
            return 0;
        } 
    }
    // 查找成功
    return cnt[p];
}

int main() {
    int n;
    scanf("%d", &n);
    
    while (n--) {
        string op, s;
        cin >> op >> s;
        
        if (op == "I") {
            insert(s);
        }
        else {
            cout << query(s) << endl;
        }
    }
    
    return 0;
}
```





### 2.AcWing0143 最大异或对

在给定的 *N* 个整数 *A*1，*A*2……*An* 中选出两个进行 *xor*（异或）运算，得到的结果最大是多少？

#### 输入格式

第一行输入一个整数 *n* 。

第二行输入 *n* 个整数 *A*1～*An* 。

#### 输出格式

输出一个整数表示答案。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

0 ≤ *A* < 2^31



#### 输入样例：

```
3
1 2 3
```

#### 输出样例：

```
3
```



#### 算法思想：

将每个 `int` 变量看作一个长度固定为 31 的位字符串： $b_{30},...,b_1,b_0$ ，构建 Trie 树（二叉树）。

插入时，按照从高位到低位的顺序构建到从根到叶的路径。

查询时，按照从高位到低位的顺序查询路径。如果存在与当前位相反的路径，则对应位异或的结果为 1 ，应当沿该路径向下查找，并记录其位权。否则，即不存在与当前位相反的路径，则对应位异或的结果为 0 ，沿该路径继续向下查找。



#### 算法1：

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

struct TreeNode {
    //vector<TreeNode*> child;
    TreeNode* child[2];
    
    TreeNode() : child({nullptr}) {}
};

class Trie {
private:
    TreeNode* root;
public:
    Trie() {
        root = new TreeNode;
    }
    
    void insert(int num) {
        TreeNode* p = root;
        for (int i = 30; i >= 0; i--) {
            int bit = num >> i & 1;
            if (!p->child[bit]) {
                p->child[bit] = new TreeNode;
            }
            p = p->child[bit];
        }
    }
    
    int query(int num) {
        TreeNode* p = root;
        int res = 0;
        for (int i = 30; i >= 0; i--) {
            int bit = num >> i & 1;
            if (p->child[!bit]) {
                p = p->child[!bit];
                res += 1 << i;
            } else {
                p = p->child[bit];
            }
        }
        return res;
    }
    
    int maxXorPair(vector<int>& nums) {
        for (auto num : nums) {
            insert(num);
        }
        
        int ans = 0;
        for (auto num : nums) {
            ans = max(ans, query(num));
        }
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    Trie T;
    
    cout << T.maxXorPair(nums) << '\n';
    
    return 0;
}
```



#### 算法2(329 ms)：

时间复杂度：O(n)。 n 为给定的数字的个数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5, M = N * 31;

int n, arr[N];
int child[M + 1][2], idx;

void insert(int num) {
	int u = 0;
	for (int i = 30; i >= 0; --i) {
		int b = num >> i & 1;
		if (!child[u][b]) {
			child[u][b] = ++idx;
		}
		u = child[u][b];
	}
}

int query(int num) {
	int u = 0, res = 0;
	for (int i = 30; i >= 0; --i) {
		int b = num >> i & 1;
		if (child[u][!b]) {
			u = child[u][!b];
			res += 1 << i;
		}
		else {
			u = child[u][b];
		}
	}
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	for (int i = 0; i < n; ++i) {
		cin >> arr[i];
		insert(arr[i]);
	}
	
	int res = 0;
	for (int i = 0; i < n; ++i) {
		res = max(res, query(arr[i]));
	}
	
	cout << res;
	
	return 0;
} 
```

时间复杂度：O(n) 。插入操作与查询操作均可在常数时间内完成。

空间复杂度：O(n)， n 为给定的整数的个数。





## 2-10 线段树

### 1.AcWing 1264 动态求连续区间和

给定 *n* 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [*a*,*b*] 的连续和。

#### 输入格式

第一行包含两个整数 *n* 和 *m* ，分别表示数的个数和操作次数。

第二行包含 *n* 个整数，表示完整数列。

接下来 *m* 行，每行包含三个整数 *k*,*a*,*b* （*k*=0，表示求子数列[*a*,*b*]的和；*k*=1，表示第 *a* 个数加 *b* ）。

数列从 1 开始计数。

#### 输出格式

输出若干行数字，表示 *k*=0 时，对应的子数列 [*a*,*b*] 的连续和。

#### 数据范围

1 ≤ *n* ≤ 100000 ,

1 ≤ *m* ≤ 100000 ，

1 ≤ *a* ≤ *b* ≤ *n* ,

数据保证在任何时候，数列中所有元素之和均在 int 范围内。



#### 输入样例：

```
10 5
1 2 3 4 5 6 7 8 9 10
1 1 5
0 1 3
0 4 8
1 7 5
0 4 8
```

#### 输出样例：

```
11
30
35
```



#### 线段树简介：

线段树（Segment Tree）是一种数据结构，用于处理一维区间或区间段的查询和更新操作。它主要用于解决静态或动态数组的区间查询问题，例如区间最小值、区间最大值、区间和等。

线段树的基本思想是将数组分割成若干个区间段，并在每个区间段上维护一些信息，如区间的最大值、最小值、和等。这样，在进行查询或更新操作时，可以利用线段树的结构快速地找到所需的区间信息。

线段树通常采用二叉树的结构表示，每个节点代表数组中的一个区间段，根节点表示整个数组的区间，每个节点的左子树和右子树分别表示左半部分和右半部分的区间。对于每个节点，都会记录该区间段的一些信息，如最大值、最小值、和等，以便进行查询和更新操作。

线段树的构建过程是一个自底向上的过程，从叶子节点开始，逐层向上合并得到父节点的信息，直到根节点。构建完成后，线段树可以在 O(logN) 的时间内完成查询和更新操作，其中 N 表示数组的长度。

线段树的应用非常广泛，特别适用于需要频繁进行区间查询和更新的场景，例如动态数组的最值查询、区间和查询、区间修改等。它在竞赛编程、算法竞赛以及各种工程应用中都有着重要的地位。



#### 算法思想：

线段树的树高：
$$
h = \lceil log_2 n \rceil + 1 \leq log_2 n + 1
$$
其中 n 为原始数组中的元素个数。于是，线段树的节点数为：
$$
n' = 1 + 2 + 4 + \ldots + 2^h = 2^{h+1} - 1 \leq 2^{log_2 n+2} -1 = 4n-1
$$
每个节点维护原始序列从 `left` 到 `right` 的连续序列和 `sum` 。



线段树是用来高效解决区间查询和修改问题的一种数据结构。在线段树中，每个节点代表一个区间，根节点代表整个区间，叶节点表示数组中的单个元素。

------



#### 线段树的结点总数计算

1. **叶节点数**：
   - 如果数组有 n 个元素，线段树的叶节点数量为 n，因为每个叶节点对应一个数组元素。
2. **内部节点数**：
   - 每个内部节点表示一段区间，最终会将整个数组分解为 n 个叶节点。
   - 如果我们从根节点出发，每次将区间分成两半，内部节点的数量大约为 $n−1$，因为一棵二叉树的非叶子节点数量与叶子节点数量的关系是 $n_{internal} = n_{leaf} - 1$。
3. **总节点数**：
   - 总节点数为叶节点数加内部节点数： $n_{total} = n_{leaf} + n_{internal} = n + (n - 1) = 2n - 1$ 。

------

#### 最多的结点数

在构建线段树时，为了简化实现，线段树通常会扩展为满二叉树（每一层完全填满）。因此，为 n 个元素构建的线段树最多需要以下数量的结点：

1. 找到比 n 大的最小的 $2^k$ ：
   - 假设 n 向上取整为 $2^k$，例如，如果 $n = 5$，则 $2^k = 8$。
2. 总节点数为：
   - 满二叉树的结点总数是 $2 \times 2^k - 1$，这是 $2^k$ 个叶子节点以及对应的内部节点数。

------

#### 示例

1. **n=5**：
   - 向上扩展到 $2^3 = 8$。
   - 满二叉树的总节点数为 $2 \times 8 - 1 = 15$。
2. **n=7**：
   - 向上扩展到 $2^3 = 8$。
   - 满二叉树的总节点数为 $2 \times 8 - 1 = 15$。
3. **n=8**：
   - 不需要扩展，满二叉树的总节点数为 $2 \times 8 - 1 = 15$。

------

#### 总结

- 如果严格构建线段树，总节点数是 $2n - 1$。
- 如果构建成满二叉树，为了实现方便，最多可能有 $2 \times 2^k - 1$ 个节点，其中 $k = \lceil log_2 n \rceil$。
- \*注：为构建满二叉树，为了实现方便，同层最多添加 $n - 2$ 的叶节点，再添加 $2n-3$ 个分支节点，因此节点数最多为 $4n-5(n>1) $。



#### 算法1：

时间复杂度：建树的时间开销为 O(n)，查询和更新操作的时间开销为 O(log n)。

```c++
#include <iostream>
#include <vector>

using namespace std;

class SegmentTree {
private:
    vector<int> nodes;  // Array to store the segment tree nodes
    int n;              // Number of elements in the original array

public:
    // Constructor: Initializes the segment tree with a given array
    SegmentTree(vector<int>& nums) {
        n = nums.size() - 1;  // Store size of array (1-indexed)
        // Initialize segment tree with 4 times the size of input array
        nodes = vector<int>(4 * n, 0);
        build(nums, 1, 1, n);  // Build the segment tree (root at index 1)
    }
    
    // Helper function to build the segment tree (recursive)
    void build(vector<int>& nums, int u, int left, int right) {
        if (left == right) {  		// Base case: leaf node
            nodes[u] = nums[left];  // Store the value at the leaf node
            return;
        }
        
        // Divide the segment and recursively build left and right children
        int mid = (left + right) / 2, v = u * 2;
        build(nums, v, left, mid);
        build(nums, v + 1, mid + 1, right);
        
        // Combine results from left and right child to set the value of current node
        nodes[u] = nodes[v] + nodes[v + 1];
    }
    
    // Function to update the value at a specific position in the segment tree
    void update(int pos, int val, int u, int left, int right) {
        // Base case: Update the value at the leaf node
        if (left == right) {
            nodes[u] += val;
            return;
        }
        
        // Divide the segment and recursively update the left or right child
        int mid = (left + right) / 2, v = u * 2;
        if (pos <= mid) {
            update(pos, val, v, left, mid);
        } else {
            update(pos, val, v + 1, mid + 1, right);
        }
        
        // After the update, recompute the value of the current node
        nodes[u] = nodes[v] + nodes[v + 1];
    }

    // Wrapper function to call the update function (using default arguments)
    void update(int pos, int val) {
        update(pos, val, 1, 1, n);
    }
    
    // Function to query the sum of a range [start, end] in the segment tree
    int query(int start, int end, int u, int left, int right) {
        // If the current segment is completely within the query range
        if (left >= start && right <= end) {
            return nodes[u];  // Return the value of the node
        }
        
        int mid = (left + right) / 2, v = u * 2, res = 0;
        // If the query range overlaps with the left child, query the left child
        if (start <= mid) {
            res += query(start, end, v, left, mid);
        }
        // If the query range overlaps with the right child, query the right child
        if (end > mid) {
            res += query(start, end, v + 1, mid + 1, right);
        }
        return res;  // Return the sum of both left and right segments
    }

    // Wrapper function to call the query function (using default arguments)
    int query(int beg, int end) {
        return query(beg, end, 1, 1, n);
    }
};


int main() {
    cin.tie(0);
    std::ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> nums(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
    }
    
    SegmentTree T(nums);
    while (m--) {
        int op, a, b;
        cin >> op >> a >> b;
        if (op == 0) {
            cout << T.query(a, b) << '\n';
        }
        else {
            T.update(a, b);
        }
    }
    
    return 0;
}
```



#### 树状数组：

Fenwick Tree (芬威克树) ，也称为二进制索引树（Binary Indexed Tree，BIT），是一种用于高效实现动态数组的前缀和查询与单点更新的数据结构。Fenwick Tree 是由 Peter M. Fenwick 在1994年提出的，用于解决一维数组的前缀和查询问题。

Fenwick Tree 主要用于支持两种操作：

1. 单点更新（Single Point Update）：修改数组中某一个元素的值。
2. 区间查询（Range Query）：查询数组中某一段连续区间的元素和。

Fenwick Tree 的关键思想是利用了二进制的特性，以空间换时间，在 O(logN) 的时间复杂度内完成单点更新和区间查询操作。

Fenwick Tree 的基本结构是一个数组，数组的索引从 1 开始，数组的长度为 n+1，其中 n 是原始数组的长度。数组中的每个元素代表了原始数组中某一范围内的元素之和，具体的计算规则是通过索引的二进制表示来确定。

Fenwick Tree 的操作如下：

1. 单点更新（单点加法）：更新 Fenwick Tree 中索引为 i 的元素的值，需要将索引 i 的二进制表示中最后一个 1 及其后面的所有 1 都加上当前元素的值。更新完成后，需要继续更新后续的节点，直到超出数组范围为止。

2. 区间查询（前缀和查询）：查询 Fenwick Tree 中索引为 i 的前缀和，需要将索引 i 的二进制表示中所有为 1 的位置的元素之和。通过不断地减去最后一个 1 及其前面的所有 1 的元素之和，可以得到查询区间的前缀和。

Fenwick Tree 的优点在于其简单而高效的实现，可以在较小的内存占用下完成区间查询和单点更新的操作，并且在实践中具有较好的性能表现。因此，Fenwick Tree 在许多需要高效处理区间查询与更新的问题中被广泛应用，如数值计算、离线算法、树状数组等领域。



#### 算法思想：

假设 x 的二进制表示中末尾有 k 个 0 ，则
$$
lowbit(x) = 2^k = x \&-x
$$
定义树状数组的编号为 x(x = 1, 2, ..., n) 的结点的值为：
$$
tree[x] = \sum_{i = x - 2 ^k + 1} ^{x} arr[i] = \sum_{i = x - lowbit(x) + 1} ^{x} arr[i]
$$
易知，每个节点 `x` 的父节点为 `x + lowbit(x)` ，每个节点 x 的左边第一个兄弟节点为 `x - lowbit(x)` 。

- 单点更新：更新该点，然后从该点出发遍历并更新所有的祖先节点。节点 `x` 的父节点为 `x + lowbit(x)` 。时间复杂度：O(log n)。

- 区间查询：求区间 `[1, x]` 的前缀和时，向左遍历所有的左兄弟（包括自己）并相加即可。节点 x 的左边第一个兄弟节点为 `x - lowbit(x)` 。时间复杂度：O(log n)。

![树状数组](AcWing_assets/树状数组.png)



#### 算法2：

时间复杂度：建树的时间开销为 O(n)，单点更新与区间查询操作的时间开销为 O(log n)。

```c++
#include <iostream>
#include <vector>

using namespace std;

class FenwickTree {
private:
    vector<int> nodes; 	// Nodes that store the tree array
public:
    // Constructor: Initialize the segment tree with a given array length
    FenwickTree(int n) {
        nodes.resize(n + 1, 0);
    }
    // Constructor: Initialize the segment tree with a given array
    FenwickTree(vector<int>& nums) {
        int n = nums.size();
        nodes = vector<int>(n, 0);
        for (int i = 1; i < n; i++) {
            nodes[i] += nums[i];
            int j = i + (i & -i);
            if (j < n) {
                nodes[j] += nodes[i];
            }
        }
    }
    
    // Single point update : Increase the value of position u by val
    void update(int u, int val) {
        while (u < nodes.size()) {
            nodes[u] += val;
            u += u & -u;
        }
    }
    
    // Interval query : Return the prefix sum from position 1 to u.
    int query(int u) {
        int res = 0;
        while (u) {
            res += nodes[u];
            u -= u & -u;
        }
        return res;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> nums(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
    }
    
    FenwickTree T(nums);
    while (m--) {
        int k, a, b;
        cin >> k >> a >> b;
        if (k == 0) {
            cout << T.query(b) - T.query(a - 1) << '\n';
        } else {
            T.update(a, b);
        }
    }
    
    return 0;
}
```





### 2.AcWing 1270 数列区间最大值

输入一串数字，给你 *M* 个询问，每次询问就给你两个数字 *X*,*Y*，要求你说出 *X* 到 *Y* 这段区间内的最大数。

#### 输入格式

第一行两个整数 *N*,*M* 表示数字的个数和要询问的次数；

接下来一行为 *N* 个数；

接下来 *M* 行，每行都有两个整数 *X*,*Y* 。

#### 输出格式

输出共 *M* 行，每行输出一个数。

#### 数据范围

$1 ≤ N ≤ 10^5,$

$1 ≤ M ≤ 10^6,$

$1 ≤ X ≤ Y ≤ N,$

数列中的数字均不超过 $2^{31}−1$ 。



#### 输入样例：

```
10 2
3 2 4 5 6 8 1 2 9 7
1 4
3 8
```

#### 输出样例：

```
5
8
```



#### 算法1：

时间复杂度：建树的时间开销为 O(n)，查询操作的时间开销为 O(log n)。

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

class SegmentTree {
public:
    // 构造函数：通过传入的数组 nums 初始化线段树
    SegmentTree(vector<int>& nums) {
        n = nums.size() - 1;        // 数组大小
        nodes = vector<int>(4 * n, 0);   // 初始化线段树的存储空间，大小为 4n
        build(nums, 1, 1, n);       // 构建线段树，从根结点开始构建整个区间 [1, n]
    }
    
    // 递归构建线段树
    void build(vector<int>& nums, int u, int left, int right) {
    	if (left == right) {        // 如果当前区间是单个元素
    		nodes[u] = nums[left];   // 直接存储该元素的值
    		return;
    	}
    	
    	// 递归地构建左右子树，然后构建树根节点
    	int mid = (left + right) / 2, v = u * 2;
    	build(nums, v, left, mid);
    	build(nums, v + 1, mid + 1, right);
    	// 当前结点的值为左右子结点的最大值
    	nodes[u] = max(nodes[v], nodes[v + 1]);
    }
    
    // 在原数组 nums 的下标 [beg, end] 区间内，查询最大元素值
    int query(int beg, int end, int u, int left, int right) {
        // 如果当前区间 [left, right] 完全包含于 [beg, end]
    	if (left >= beg && right <= end) {
    		return nodes[u];     // 返回 [beg, end] 内的最大值
    	}
    	
    	// 将区间 [left, right] 划分为 [left, mid], [mid+1, right] 两部分
    	int mid = (left + right) / 2, v = u * 2, res = INT_MIN;
    	
    	if (beg <= mid) {       // 如果查询区间与左子区间有交集
    		res = max(res, query(beg, end, v, left, mid));  // 查询左子区间
    	}
    	if (end > mid) {        // 如果查询区间与右子区间有交集
    		res = max(res, query(beg, end, v + 1, mid + 1, right)); // 查询右子区间
    	}
    	return res;             // 返回结果
	}
	int query(int beg, int end) {
        return query(beg, end, 1, 1, n);
    }
    
private:
    vector<int> nodes;
    int n;
};

int main() {
    cin.tie(0);
    std::ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<int> nums(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
    }
    
    SegmentTree T(nums);
    while (m--) {
        int beg, end;
        cin >> beg >> end;
        cout << T.query(beg, end) << '\n';
    }
    
    return 0;
}
```







## 2-11 树状数组

### 1.LeetCode 0406 Queue Reconstruction by Height

You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`.

Reconstruct and return *the queue that is represented by the input array* `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).

 

**Example 1:**

```
Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
```

**Example 2:**

```
Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

 

**Constraints:**

- `1 <= people.length <= 2000`
- `0 <= hi <= 10^6`
- `0 <= ki < people.length`
- It is guaranteed that the queue can be reconstructed.



##### Algorithm 1:

Time complexity = $O(n \times (\log n) ^ 2)$ .

```c++
// 定义一个 FenwickTree（树状数组）类
class FenwickTree {
private:
    vector<int> nodes; // 存储树状数组的节点
public:
    // 构造函数
    FenwickTree(int n) {
        nodes.resize(n + 1, 0);
    }
    
    // 单点更新：将位置 u 的值增加 val
    void update(int u, int val) {
        while (u < nodes.size()) { // 遍历从 u 开始的每个相关节点
            nodes[u] += val;       // 更新当前节点的值
            u += u & -u;           // 跳到下一个需要更新的父节点
        }
    }
    
    // 区间查询：返回从位置 1 到 u 的前缀和
    int query(int u) {
        int res = 0;               // 初始化结果为 0
        while (u) {                // 当 u > 0 时，不断向左查找兄弟节点
            res += nodes[u];       // 累加当前节点的值
            u -= u & -u;           // 跳到左兄弟节点
        }
        return res;                // 返回结果
    }
};

class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        // 按照规则排序，首先按身高升序排列，如果身高相同则按 k 值降序排列
        sort(people.begin(), people.end(), [](const vector<int>& a, const vector<int>& b) {
            if (a[0] != b[0]) return a[0] < b[0];
            return a[1] > b[1];
        });

        // 初始化树状数组
        int n = people.size();
        FenwickTree T(n);
        vector<vector<int>> ans(people);

        // 遍历每个元素，按规则重建队列
        for (auto pi : people) {
            int hi = pi[0], ki = pi[1];

            // 贪心选择：使用二分查找来找到合适的位置
            // 对于已被使用的位置标记为 1，未使用的位置为 0，
            // 则第一个满足「0 的个数大于等于 ki+1」的位置即是目标位置 pos
            // (易知 pos 左边的空位将来一定被身高更高(或等高)的人占用, 可证贪心选择是全局最优)
            int low = 1, high = n;
            while (low < high) {
                // 如果 mid - query(mid) >= ki + 1，说明中点位置可以容纳该元素
                int mid = (low + high) / 2;
                if (mid - T.query(mid) >= ki + 1) {
                    high = mid;
                } else {
                    low = mid + 1;
                }
            }
            ans[low - 1] = pi;
            T.update(low, 1);
        }
        return ans;
    }
};
```





### 2.AcWing 1016 最大上升子序列和(Hard)

一个数的序列 $b_i$ ，当 $b_1<b_2<\dots < b_N$ 的时候，我们称这个序列是上升的。

对于给定的一个序列 ( $a_1, a_2, \dots, a_N$ )，我们可以得到一些上升的子序列 ( $a_{i_1}, a_{i_2}, \dots, a_{i_K}$ )，这里 $1 \leq i_1 < i_2 <\dots < i_K \leq N$ 。

比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。

这些子序列中和最大为18，为子序列(1,3,5,9)的和。

你的任务，就是对于给定的序列，求出最大上升子序列和。

注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。

#### 输入格式

输入的第一行是序列的长度N。

第二行给出序列中的N个整数，这些整数的取值范围都在0到10000(可能重复)。

#### 输出格式

输出一个整数，表示最大上升子序列和。

#### 数据范围

1 ≤ *N* ≤ 1000



#### 输入样例：

```
7
1 7 3 5 9 4 8
```

#### 输出样例：

```
18
```



##### Algorithm 1:

Time Complexity = $O(n \log n)$ .

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class FenwickTree {
private:
    int n;
    vector<int> nodes;

public:
    FenwickTree(int n) : n(n), nodes(vector<int>(n + 1, 0)) {}
    
    void update(int u, int val) {
        while (u <= n) {
            nodes[u] = max(nodes[u], val);
            u += u & -u;
        }
    }
    
    int query(int u) {
        int res = 0;
        while (u) {
            res = max(res, nodes[u]);
            u -= u & -u;
        }
        return res;
    }
};

int maxSumOfIS(vector<int>& nums) {
    int n = nums.size();
    
    vector<int> sorted(nums);
    sort(sorted.begin(), sorted.end());
    
    vector<int> indices(n);
    for (int i = 0; i < n; i++) {
        indices[i] = lower_bound(sorted.begin(), sorted.end(), nums[i]) - sorted.begin() + 1;
    }
    
    FenwickTree T(n);
    int maxSum = 0;
    for (int idx : indices) {
        // query(u) finds the maximum sum of increasing subsequences 
        // for indices smaller than the current index u.
        int curSum = T.query(idx - 1) + sorted[idx - 1];
        // update(u) stores the maximum sum of increasing subsequences
        // ending at a particular index u.
        T.update(idx, curSum);
        maxSum = max(maxSum, curSum);
    }
    return maxSum;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    cout << maxSumOfIS(nums) << '\n';
    
    return 0;
}
```





















