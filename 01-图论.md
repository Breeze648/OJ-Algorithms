# 一、图论

## 1-0.图的存储

### 1.图的邻接表存储

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh with istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
        }
    }
    
    
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    ALGragh G(cin, n, m);
    
    
    
    return 0;
}
```





### 2.图的邻接矩阵存储

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9;

class AMGragh {
private:
    int n;							// Number of vertices
    vector<vector<int>> weight;		// Edge table
public:
    // Initialize gragh with istream
    AMGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        weight.resize(n + 1, vector(n + 1, INF));
        for (int i = 0; i <= n; i++) {
            weight[i][i] = 0;
        }
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            weight[u][v] = min(weight[u][v], w);
        }
    }
	
    
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    AMGragh G(cin, n, m);
    
	
    
    return 0;
}
```







### 3.图的三元组存储

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

struct Edge {
    int u, v, w;
};

// Triple Table
class TTGragh {
private:
    int n;					// Number of vertices
    vector<Edge> edges;		// Edge table
public:
    // Initialize gragh with istream
    TTGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        for (int i = 0; i < numEdge; i++) {
            int u, v, w;
            cin >> u >> v >> w;
            edges.push_back({u, v, w});
        }
    }
    
	
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    TTGragh G(cin, n, m);
    
    
    return 0;
}
```





### 4.图的链式前向星存储

```c++
struct ArcNode {
    int adjVex;
    int nextEdge;
    int weight;
};

// Chain Forword Star
class CFSGragh {
private:
    int n;						// Number of vertices
    int m;						// Number of edges
    vector<int> firstEdge;		// Adjacent list
    vector<ArcNode> edges;		// Edge list
public:
    CGragh(int numVex) {
        n = numVex;
        m = 0;
        firstEdge.resize(n, 0);
        edges.resize(2 * n - 2, 0);
    }
    
    void addEdge(int u, int v, int w) {
        edges[m] = {w, v, firstEdge[u]};
        firstEdge[u] = m++;
    }
    
    
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    TTGragh G(cin, n, m);
    
    
    return 0;
}
```



### 5.并查集

```c++
class UFSet { 
private:
    int n;                  // Number of nodes
    vector<int> fa;         // Array to store parent pointers

public:
    // Initialize UFSet with number of nodes
    UFSet(int numNodes) {
        n = numNodes;       	// Initialize number of nodes
        fa.resize(n + 1, -1);	// Initialize parent pointers to -1
    }
    
    // Find the root of u with path compression
    int Find(int u) {
        return fa[u] == -1 ? u : fa[u] = Find(fa[u]);
    }
    
    // Union the sets containing u and v
    void Union(int u, int v) {
        fa[Find(u)] = Find(v);
    }
};
```







## 1-1.最短路模型

### 1.AcWing0849 朴素Dijstra(稠密图)

给定一个 *n* 个点 *m* 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 1 号点到 *n* 号点的最短距离，如果无法从 1 号点走到 *n* 号点，则输出 −1 。

##### 输入格式

第一行包含整数 *n* 和 *m* 。

接下来 *m* 行每行包含三个整数 *x* , *y* , *z* ，表示存在一条从点 *x* 到点 *y* 的有向边，边长为 *z* 。

##### 输出格式

输出一个整数，表示 1 号点到 *n* 号点的最短距离。

如果路径不存在，则输出 −1 。

##### 数据范围

1 ≤ *n* ≤ 500 ,

1 ≤ *m* ≤ 10^5 ,

 图中涉及边长均不超过10000。



##### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

##### 输出样例：

```
3
```



#### Dijkstra 算法：（贪心-不适合负边权）

Dijkstra算法是一种用于解决单源最短路径问题的经典算法，由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）于1956年提出。该算法可以求解从图中的一个顶点出发到其它所有顶点的最短路径。

Dijkstra算法的基本思想是从起始顶点开始，逐步扩展到尚未确定最短路径的顶点，通过不断更新各个顶点的最短路径长度，直到所有顶点的最短路径都被确定。具体步骤如下：

1. 初始化：将起始顶点的最短路径长度设置为0，其它顶点的最短路径长度设置为无穷大（或者一个较大的数值表示无穷大），并将起始顶点加入到一个待访问的顶点集合中。

2. 重复以下步骤直到所有顶点的最短路径都被确定：
   - 进行一次贪心选择：从待访问的顶点集合中选择一个顶点 u，该顶点的最短路径长度最小。
   - 扩展待访问的集合：对于顶点 u 的每一个邻接顶点 v，如果通过顶点 u 到达顶点 v 的路径长度比当前已知的最短路径长度小，则更新顶点 v 的最短路径长度为通过顶点 u 到达顶点 v 的路径长度，并将顶点 v 加入到待访问的顶点集合中。

3. 当所有顶点的最短路径长度都被确定时，算法结束。

Dijkstra算法使用了贪心策略，每次选择最小路径长度的顶点进行扩展。由于每次扩展都是基于当前已知的最短路径长度，因此该算法的正确性得到了保证。

Dijkstra算法的时间复杂度为 O(V^2)，其中 V 是图中顶点的数量。对于稀疏图，可以使用优先队列（最小堆）来优化，将时间复杂度降低至 O((V + E)logV)，其中 E 是图中边的数量。



#### 算法1-Dijkstra:

时间复杂度：O(V ^ 2)。 V 为顶点数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9;

class AMGragh {
private:
    int n;							// Number of vertices
    vector<vector<int>> weight;		// Edge table
public:
    // Initialize gragh with istream
    AMGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        weight.resize(n + 1, vector(n + 1, INF));
        for (int i = 0; i <= n; i++) {
            weight[i][i] = 0;
        }
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            weight[u][v] = min(weight[u][v], w);
        }
    }
	
    // Returns the shortest path length from the start 1 to the end 1
    // Specially, INF represents no shortest path
    int dijkstra(int start, int end) {
        vector<int> dist(n + 1, INF);
        vector<bool> visited(n + 1, false);
        
        // Start from vertex 'start'
        dist[start] = 0;
        
        // Traverse all reachable vertices
        for (int steps = 0; steps < n; steps++) {
            // 1. Pop the heap top(i.e., the nearest vertex)
            int u = 0;
            for (int v = 1; v <= n; v++) {
                if (!visited[v] && (!u || dist[v] < dist[u])) {
                    u = v;
                }
            }
            // 2. Visit the nearest vertex u
            visited[u] = true;
            // 3. Visit and try to relax all out edges of u
            for (int v = 1; v <= n; v++) {
                dist[v] = min(dist[v], dist[u] + weight[u][v]);
            }
        }
        return dist[end] == INF ? -1 : dist[n];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    AMGragh G(cin, n, m);
    
    cout << G.dijkstra(1, n) << '\n';
    
    return 0;
}
```



#### 算法2(113 ms)：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 500, INF = (N - 1) * 10000 + 1;

int matrix[N + 1][N + 1], n;

int dijkstra() {
    int dist[N + 1];
    bool vis[N + 1];
    
    // 顶点 0 为假想的距离永远为无穷的点
    for (int i = 0; i <= n; ++i) {
        dist[i] = INF;
        vis[i] = false;
    }
    
    // 从源点出发
    dist[1] = 0;
    
    // steps 维护走过的路径的长度
    for (int steps = 0; steps < n - 1; ++steps) {		// 改为 steps < n 亦可
        // 从未访问过的顶点集合中选择一个距源点最近的点 k
        int k = 0;
        for (int j = 1; j <= n; ++j) {		//稀疏图可用最小堆优化这一步
            if (!vis[j] && (!k || dist[j] < dist[k])) {
                k = j;
            }
        }
        
        // 访问顶点 k
        vis[k] = true;
        // 访问并尝试松弛 k 的所有出边
        for (int j = 1; j <= n; ++j) {
            // 如果经过点 k 到达点 j 的路径更短，更新路径长度dist[j]
            dist[j] = min(dist[j], dist[k] + matrix[k][j]);
        }
    }
    
    // 返回到终点的最短路径长度
    return dist[n] == INF ? -1 : dist[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            matrix[i][j] = i == j ? 0 : INF;
        }
    }
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        matrix[u][v] = min(matrix[u][v], w);
    }
    
    cout << dijkstra();
    
    return 0;
}
```



#### 算法3-堆优化(114 ms)：

时间复杂度：O((V + E) log E)。V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <queue>
#include <functional>
#include <algorithm>

using namespace std;

const int N = 500, INF = (N - 1) * 10000 + 1;

int n, matrix[N + 1][N + 1];

int dijkstra() {
    int dist[N + 1];
    bool vis[N + 1];
    
    for (int u = 1; u <= n; ++u) {
        dist[u] = INF;
        vis[u] = false;
    }
    
    // <dist, vertex>
    using PII = pair<int, int>;
    priority_queue<PII, vector<PII>, greater<PII> > minHeap;
    
    minHeap.push({0, 1});
    dist[1] = 0;
    
    while (minHeap.size()) {
        int u = minHeap.top().second;
        minHeap.pop();
        
        if (vis[u]) {
            continue;
        }
        
        vis[u] = true;
        for (int v = 1; v <= n; ++v) {
            int d = dist[u] + matrix[u][v];
            if (d < dist[v]) {
                dist[v] = d;
                minHeap.push({d, v});
            }
        }
    }
    
    return dist[n] == INF ? -1 : dist[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            matrix[i][j] = i == j ? 0 : INF;
        }
    }
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        matrix[u][v] = min(matrix[u][v], w);
    }
    
    cout << dijkstra();
    
    return 0;
}
```



#### 算法4-SPFA算法(113 ms)：

时间复杂度：通常接近 O(V + E)，其中 V, E 分别为顶点数，边数。最坏情况下时间复杂度为 O(VE)。

```c++
#include <iostream>
#include <queue>
#include <algorithm>

using namespace std;

const int N = 500, INF = N * 10000;

int n, matrix[N + 1][N + 1];

int spfa() {
	int dist[N + 1];
	queue<int> que;
	bool inque[N + 1];
	
	fill_n(dist, n + 1, INF);
	fill_n(inque, n + 1, false);
	
	dist[1] = 0;
	que.push(1);
	inque[1] = true;
	
	while (que.size()) {
		int u = que.front(); que.pop();
		inque[u] = false;
		
		for (int v = 1; v <= n; ++v) {
			int d = dist[u] + matrix[u][v];
			if (d < dist[v]) {
				dist[v] = d;
				if (!inque[v]) {
					que.push(v);
					inque[v] = true;
				}
			}
		}
	}
	
	return dist[n] == INF ? -1 : dist[n];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			matrix[i][j] = i == j ? 0 : INF;
		}
	}
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		matrix[u][v] = min(matrix[u][v], w);
	}
	
	cout << spfa();
	
	return 0;
}
```





### 2.AcWing0850 堆优化Dijstra(稀疏图)

给定一个 *n* 个点 *m* 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。

请你求出 1 号点到 *n* 号点的最短距离，如果无法从 1 号点走到 *n* 号点，则输出 −1 。

##### 输入格式

第一行包含整数 *n* 和 *m* 。

接下来 *m* 行每行包含三个整数 *x* , *y* , *z* ，表示存在一条从点 *x* 到点 *y* 的有向边，边长为 *z* 。

##### 输出格式

输出一个整数，表示 1 号点到 *n* 号点的最短距离。

如果路径不存在，则输出 −1 。

##### 数据范围

1 ≤ *n* , *m* ≤ 1.5×10^5 ,

图中涉及边长均不小于 0，且不超过 10000。

数据保证：如果最短路存在，则最短路的长度不超过 10^9。

##### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

##### 输出样例：

```
3
```



#### 算法思想：

在稀疏图中，顶点的数量相对边的数量较少。在普通的Dijkstra算法中，每次选择未访问过的顶点中距离源点最近的一个顶点，并更新从源点到其他顶点的距离。然而，在稀疏图中，由于边的数量较少，我们可能会多次更新同一个顶点的距离，导致效率降低。

优先队列（最小堆）的优化思想在于，通过优先级队列按照顶点到源点的距离进行排序，每次从队列中取出距离源点最近的顶点进行松弛操作。这样可以确保每个顶点仅被松弛一次，避免了多次更新同一顶点的距离，从而提高了算法的效率。

具体而言，优先队列（最小堆）在每次选择下一个顶点时，都会选择距离源点最近的顶点进行松弛操作，而不是遍历所有未访问的顶点。这样可以确保在稀疏图中，每个顶点仅被松弛一次，避免了不必要的重复操作。由于优先队列可以在 O(logV) 的时间内完成插入和删除最小元素的操作，因此总体时间复杂度为 O((V + E)logV)。

总之，优先队列（最小堆）的优化思想在于按照顶点到源点的距离排序，每次选择最近的顶点进行松弛操作，从而避免了多次更新同一顶点的距离，提高了算法的效率。



对于稠密图，最小堆优化并不适用，因为在稠密图中，顶点的数量和边的数量都很大，每个顶点都有大量的边相连，导致优先队列中需要存储大量的边，使得优先队列的操作复杂度变高，从而失去了优化的效果。

在稠密图中，由于边的数量非常大，使用优先队列存储所有边会导致插入和删除操作的时间复杂度变高，使得总体时间复杂度不再优于普通的Dijkstra算法。因此，对于稠密图，通常使用普通的Dijkstra算法，其时间复杂度为O(V^2)，其中V为顶点的数量。



#### 算法1：

时间复杂度：O((V + E)log E)。其中 V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh by istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
        }
    }
    
    // Returns the shortest path length from the start 1 to the end 1
    // Specially, INF represents no shortest path
    int dijkstra() {
        vector<int> dist(n + 1, INF);
        vector<bool> vis(n + 1, false);
    	using PII = pair<int, int>;			// <distance, vertex>
        priority_queue<PII, vector<PII>, greater<PII> > minHeap;
        
        // Start from vertex 1
        dist[1] = 0;
        minHeap.emplace(0, 1);
        
        // Traverse all reachable vertices
        while (!minHeap.empty()) {
            // 1. Pop the heap top(i.e., the nearest vertex)
            int u = minHeap.top().second;
            minHeap.pop();
            // 2. Visit the nearest vertex
            if (vis[u]) {
                continue;
            }
            vis[u] = true;
            // 3. Visit and try to relax all adjacent edges of u
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    minHeap.emplace(dist[v], v);
                }
            }
        }
        return dist[n];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    ALGragh G(cin, n, m);
    
    int ret = G.dijkstra();
    cout << (ret == INF ? -1 : ret) << '\n';
    
    return 0;
}
```



#### 算法2-最小堆优化(811 ms)：

时间复杂度：O((V + E)log E)。其中 V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <queue>
#include <functional>

using namespace std;

const int N = 150000, M = 150000;
const int INF = 1e9 + 1;

int n, first[N + 1];
int ne[M + 1], vertex[M + 1], weight[M + 1], idx;

void addEdge(int u, int v, int w) {
    vertex[++idx] = v;
    weight[idx] = w;
    ne[idx] = first[u];
    first[u] = idx;
}

int dijkstra() {
    int dist[N + 1];
    bool vis[N + 1];
    
    // <distance, vertex>
	using PII = pair<int, int>;
    priority_queue<PII, vector<PII>, greater<PII> > minHeap;
    
    for (int i = 0; i <= n; ++i) {
        dist[i] = INF;
        vis[i] = false;
    }
    
    // 从源点出发
    dist[1] = 0;
    minHeap.emplace(0, 1);
    
    // 遍历所有可达点
    while (minHeap.size()) {
        // 弹出堆顶,即弹出当前最近点
        int u = minHeap.top().second;
        minHeap.pop();
        
        // 访问最近点
        if (vis[u]) {
            continue;
        }
        
        // 访问并尝试松弛 u 的所有邻边
        vis[u] = true;
        for (int i = first[u]; i; i = ne[i]) {
            // 若经过点 u 到达点 v 的路径更短，更新并入队
            int v = vertex[i];
            int d = dist[u] + weight[i];
            if (d < dist[v]) {
                dist[v] = d;
                minHeap.emplace(d, v);
            }
        }
    }
    
    return dist[n] == INF ? -1 : dist[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
    }
    
    cout << dijkstra();
    
    return 0;
}
```



#### 算法2-SPFA算法(TLE, 13/15)：

时间复杂度：通常接近 O(V + E)，其中 V, E 分别为顶点数，边数。最坏情况下时间复杂度为 O(VE)。

```c++
#include <iostream>
#include <queue>
#include <algorithm>

using namespace std;

const int N = 15e4, M = 15e4, INF = 1e9 + 1;

int n, first[N + 1];
int idx, ne[M + 1], vertex[M + 1], weight[M + 1];

void addEdge(int u, int v, int w) {
	weight[++idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx;
}

int spfa() {
	int dist[N + 1];
	bool inque[N + 1];
	queue<int> que;
	
	fill_n(dist, n + 1, INF);
	fill_n(inque, n + 1, false);
	
	dist[1] = 0;
	inque[1] = true;
	que.push(1);
	
	while (que.size()) {
		int u = que.front(); que.pop();
		inque[u] = false;
		
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			int d = dist[u] + weight[i];
			if (d < dist[v]) {
				dist[v] = d;
				if (!inque[v]) {
					inque[v] = true;
					que.push(v);
				}
			}
		}
	}
	
	return dist[n] == INF ? -1 : dist[n];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
	}
	
	cout << spfa();
	
	return 0;
}
```





### 3.AcWing0853 Bellman-Ford最短路算法

给定一个 *n* 个点 *m* 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出从 1 号点到 *n* 号点的最多经过 *k* 条边的最短距离，如果无法从 1 号点走到 *n* 号点，输出 `impossible`。

注意：图中可能 **存在负权回路** 。

#### 输入格式

第一行包含三个整数 *n* , *m* , *k* 。

接下来 *m* 行，每行包含三个整数 *x* , *y* , *z* ，表示存在一条从点 *x* 到点 *y* 的有向边，边长为 *z* 。

点的编号为 1∼*n* 。

#### 输出格式

输出一个整数，表示从 1 号点到 *n* 号点的最多经过 *k* 条边的最短距离。

如果不存在满足条件的路径，则输出 `impossible`。

#### 数据范围

1 ≤ *n* , *k* ≤ 500,

1 ≤ *m* ≤ 10000,

1 ≤ *x* , *y* ≤ *n*，

任意边的边长的绝对值不超过 10000。



#### 输入样例：

```
3 3 1
1 2 1
2 3 1
1 3 3
```

#### 输出样例：

```
3
```



#### 算法思想：

Bellman-Ford算法是一种用于求解单源最短路径的算法，能够处理带有负权边的图，并且可以检测出图中是否存在负权环。

**算法思想：**

1. 初始化：将源点到所有其他顶点的距离初始化为无穷大，源点到自身的距离为0。
2. 进行n-1轮松弛操作：遍历图中的每条边，尝试以当前边的权值更新边的终点顶点的距离值。
3. 检测负权环：若第n轮松弛操作仍然能够更新距离值，则说明存在负权环。

**算法步骤：**

1. 初始化：将源点到所有顶点的距离设置为无穷大，源点到自身的距离设置为0。
2. 进行n-1轮松弛操作：重复执行以下操作n-1次：
   - 遍历图中的每一条边(u, v)，尝试以边的权值更新顶点v的距离值。
3. 检测负权环：再进行一轮松弛操作，若仍有边的距离值被更新，则说明存在负权环。

**算法特点：**

- Bellman-Ford算法适用于带有负权边的图，并且能够检测负权环。
- 时间复杂度为O(V*E)，其中V为顶点数量，E为边数量。
- Bellman-Ford算法在实际应用中通常用于解决一般性的单源最短路径问题，但是对于边数较多的图，效率可能较低，因此不适用于稠密图。



在图论和动态规划中，“松弛”通常指的是通过更新当前最优值来尝试改善当前状态的操作。在最短路径算法中，例如Dijkstra算法和Bellman-Ford算法中，松弛操作指的是尝试通过经过当前顶点的路径来更新源点到其他顶点的最短距离。如果新路径的长度比已知的最短路径更短，则更新相应的最短距离。



#### 算法1(333 ms)：

时间复杂度：O(V * E)。其中 V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

struct Edge {
    int u, v, w;
};

// Triple Table
class TTGragh {
private:
    int n;					// Number of vertices
    vector<Edge> edges;		// Edge table
public:
    // Initialize gragh by istream
    TTGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        for (int i = 0; i < numEdge; i++) {
            int u, v, w;
            cin >> u >> v >> w;
            edges.push_back({u, v, w});
        }
    }
    
    // Return the shortest path from vertex 1 to vertex n with at most k hops
    // Specially, INF represents no shortest path
    int bellmanFord(int k) {
        vector<vector<int>> dist(2, vector<int>(n + 1, INF));

        dist[0][1] = 0;  // Start from vertex 1 with distance 0

        // The hop count is limited to k
        for (int hops = 1; hops <= k; hops++) {
            // 1. Copy previous distances
            int cur = hops & 1;
            copy(dist[!cur].begin(), dist[!cur].end(), dist[cur].begin());
            // 2. Relax all edges for the current number of hops
            for (auto [u, v, w] : edges) {
                dist[cur][v] = min(dist[cur][v], dist[!cur][u] + w);
            }
        }
        return dist[k & 1][n];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m, k;
    cin >> n >> m >> k;
    TTGragh G(cin, n, m);
    
    int ret = G.bellmanFord(k);
    if (ret >= INF / 2) {
        cout << "impossible" << '\n';
    } else {
        cout << ret << '\n';
    }
    
    return 0;
}
```



#### 算法1(120 ms)：

时间复杂度：O(V * E)。其中 V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 500, M = 1e4, INF = 1e9;

int n, k;

int idx;
struct Edge {
    int u, v, w;
} edges[M];

int dist[2][N + 1];

int BellmanFord() {
    fill_n(dist[0] + 1, n, INF);
    
    dist[0][1] = 0;
    for (int hops = 1; hops <= k; hops++) {
        int curr = hops & 1, pre = curr ^ 1;
        copy_n(dist[pre] + 1, n, dist[curr] + 1);
        
        for (int i = 0; i < idx; i++) {
            dist[curr][edges[i].v] = min(dist[curr][edges[i].v], dist[pre][edges[i].u] + edges[i].w);
        }
    }
    
    return dist[k & 1][n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m >> k;
    
    while (m--) {
        cin >> edges[idx].u >> edges[idx].v >> edges[idx].w;
        idx++;
    }
    
    int ret = BellmanFord();
    if (ret >= INF / 2) {
        cout << "impossible" << '\n';
    }
    else {
        cout << ret << '\n';
    }
    
    return 0;
}
```



#### 算法2(124 ms)：

```c++
#include <iostream>
#include <algorithm>
#include <iterator>

using namespace std;

const int N = 500, M = 10000;
const int K = 500, W = 10000;
const int INF = K * W * 2;

int n, m, k;
int first[N + 1];
int ne[M + 1], vertex[M + 1], weight[M + 1], idx;

void addEdge(int u, int v, int w) {
    vertex[++idx] = v;
    weight[idx] = w;
    ne[idx] = first[u];
    first[u] = idx;
}

int BellmanFord() {
    int dist[N + 1];
    for (int i = 1; i <= n; ++i) {
        dist[i] = INF;
    }
    
    dist[1] = 0;
    
    // 执行 k 轮循环,即最多允许走 k 条边
    // 每一轮循环，对所有的边尝试执行松弛操作
    // 拓展：如果第 n 轮循环仍然可以进行松弛，说明存在负权环
    for (int i = 0; i < k; ++i) {
        // 防止一轮循环在某条路径上松弛多条边
        int dist2[N + 1];
        copy_n(begin(dist) + 1, n, begin(dist2) + 1);
        
        // 遍历所有顶点
        for (int u = 1; u <= n; ++u) {
            // 遍历所有出边,对所有边尝试执行松弛
            for (int j = first[u]; j; j = ne[j]) {
                int v = vertex[j];
                // 只能用上一轮迭代的结果更新这一轮的 dist
                dist[v] = min(dist[v], dist2[u] + weight[j]);
            }
        }
    }
    
    return dist[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m >> k;
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
    }
    
    int res = BellmanFord();
    if (res >= INF / 2) {
        cout << "impossible";
    }
    else {
        cout << res;
    }
    
    return 0;
}
```



#### 算法3(132 ms)：

时间复杂度：O(V * E)。其中 V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 500, M = 1e4;
const int K = 500, W = 1e4, INF = K * W + 1;

int n, first[N + 1], k;
int idx, ne[M + 1], vertex[M + 1], weight[M + 1];

void addEdge(int u, int v, int w) {
    weight[++idx] = w;
    vertex[idx] = v;
    ne[idx] = first[u];
    first[u] = idx;
}

int BellmanFord() {
    int dist[N + 1];
    bool acc[N + 1];        // accessible, 维护所有可达点
    
    for (int u = 1; u <= n; ++u) {
        dist[u] = INF;
        acc[u] = false;
    }
    
    dist[1] = 0;
    acc[1] = true;
    
    for (int steps = 0; steps < k; ++steps) {
        int dist0[N + 1];
        bool acc0[N + 1];
        copy_n(dist + 1, n, dist0 + 1);
        copy_n(acc + 1, n, acc0 + 1);
        
        // 对所有从可达点出发的边尝试松弛, 并维护可达点状态
        for (int u = 1; u <= n; ++u) {
            if (!acc0[u]) {
                continue;
            }
            
            for (int i = first[u]; i; i = ne[i]) {
                int v = vertex[i];
                dist[v] = min(dist[v], dist0[u] + weight[i]);
                if (dist[v] != INF) {
                    acc[v] = true;
                }
            }
        }
    }
    
    return dist[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    
    int m;
    cin >> n >> m >> k;
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
    }
    
    int ret = BellmanFord();
    if (ret == INF) {
        cout << "impossible";
    }
    else {
        cout << ret;
    }
    
    return 0;
}
```







### 4.AcWing0851 SPFA最短路算法

给定一个 *n* 个点 *m* 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出 1 号点到 *n* 号点的最短距离，如果无法从 1 号点走到 *n* 号点，则输出 `impossible`。

数据保证**不存在负权回路**。

##### 输入格式

第一行包含整数 *n* 和 *m* 。

接下来 *m* 行每行包含三个整数 *x* , *y* , *z* ，表示存在一条从点 *x* 到点 *y* 的有向边，边长为 *z* 。

##### 输出格式

输出一个整数，表示 1 号点到 *n* 号点的最短距离。

如果路径不存在，则输出 `impossible`。

##### 数据范围

1 ≤ *n* , *m* ≤ 10^5,

图中涉及边长绝对值均不超过 10000 。



##### 输入样例：

```
3 3
1 2 5
2 3 -3
1 3 4
```

##### 输出样例：

```
2
```



#### 算法思想：

SPFA（Shortest Path Faster Algorithm）算法是一种用于求解单源最短路径的算法，它基于Bellman-Ford算法的基本思想，并进行了一些优化。SPFA算法通过利用队列来减少不必要的松弛操作，从而提高了算法的效率。

SPFA算法的基本思想如下：

1. 将起点加入队列，并将起点的距离初始化为0。
2. 不断从队首取出一个顶点，并遍历该顶点的所有邻接点。
3. 对于每个邻接点，如果通过当前顶点可以获得更短的距离，则更新距离，并将该邻接点加入队列。
4. 继续从队首取出顶点，重复步骤2和步骤3，直到队列为空。

SPFA算法的优化主要在于使用了队列来动态地选择需要进行松弛操作的顶点，避免了对所有顶点进行无效的松弛操作，从而减少了算法的时间复杂度。具体来说，当某个顶点的距离被更新后，如果它不在队列中，则将它加入队列；如果它已经在队列中，则不需要重复加入队列，因为它在下一次出队时会被重新考虑。

SPFA算法的时间复杂度取决于队列的操作次数，通常情况下可以达到O(V + E)，其中V是顶点数，E是边数。然而，由于SPFA算法使用了队列，并且允许重复加入队列，因此在存在负权环的情况下，算法可能会陷入无限循环，导致时间复杂度无穷大。因此，SPFA算法适用于没有负权环的图，但在存在负权环的情况下，需要使用Bellman-Ford算法进行检测。



#### 算法1(516 ms)：

时间复杂度：通常情况下可以达到O(V + E)，其中V是顶点数，E是边数。可以处理负权边，但不能处理含负权环的图。

最坏时间复杂度为 O(VE) ，此时多数顶点与边会被多次访问。

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh with istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
        }
    }
    
    int spfa(int start, int end) {
        vector<int> dist(n + 1, INF);
        // inque[i] == true represents vertex i is in queue to be visited
        vector<bool> inque(n + 1, false);
        queue<int> que;
        
        // Star from vertex start
        que.push(start);
        inque[start] = true;
        dist[start] = 0;
        
        // Loop until all edges cannot be relaxed
        while (!que.empty()) {
            // 1. Dequeue and visit the front vertex u
            int u = que.front();
            que.pop();
            inque[u] = false;
            // 2. Vist and try to relax all out edges of u
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    // If not in queue, enqueue
                    if (!inque[v]) {
                        que.push(v);
                        inque[v] = true;
                    }
                }
            }
        }
        return dist[end];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    ALGragh G(cin, n, m);
    
    int ret = G.spfa(1, n);
    if (ret == INF) {
        cout << "impossible" << '\n';
    } else {
        cout << ret << '\n';
    }
    
    return 0;
}
```



#### 算法1(239 ms)：

时间复杂度：通常情况下可以达到O(V + E)，其中V是顶点数，E是边数。可以处理负权边，但不能处理含负权环的图。

最坏时间复杂度为 O(VE) ，此时多数顶点与边会被多次访问。

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <iterator>

using namespace std;

const int N = 100000, M = 100000;
const int INF = (N - 1) * 10000 + 1;

int n, m, first[N + 1];
int vertex[M + 1], ne[M + 1], weight[M + 1], idx;

void addEdge(int u, int v, int w) {
    vertex[++idx] = v;
    weight[idx] = w;
    ne[idx] = first[u];
    first[u] = idx;
}

int SPFA() {
    int dist[N + 1];
    bool inque[N + 1];		// inque[i] == true 表示 i 在队中，等待访问
    fill_n(begin(dist) + 1, n, INF);
    fill_n(begin(inque) + 1, n, false);
    
    queue<int> que;
    
    // 源点入队
    que.push(1);
    inque[1] = true;
    dist[1] = 0;
    
    // 循环至所有边都不可再松弛(因此,可以处理负边,但不能处理负回路)
    while (que.size()) {
        // 队头出队
        int u = que.front();
        que.pop();
        inque[u] = false;
        
        // 遍历所有出边并尝试松弛
        for (int i = first[u]; i; i = ne[i]) {
            int v = vertex[i];
            int d = dist[u] + weight[i];
            if (d < dist[v]) {
                dist[v] = d;
                
                // 如果未入队，则入队
                if (!inque[v]) {
                    que.push(v);
                    inque[v] = true;
                } 
            }
        }
    }
    
    return dist[n];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
    }
    
    int res = SPFA();
    if (res == INF) {
        cout << "impossible";
    }
    else {
        cout << res;
    }
    
    return 0;
}
```



### 5.AcWing0854 Floyd多源最短路

给定一个 *n* 个点 *m* 条边的有向图，图中可能存在重边和自环，边权**可能为负数**。

再给定 *k* 个询问，每个询问包含两个整数 *x* 和 *y*，表示查询从点 *x* 到点 *y* 的最短距离，如果路径不存在，则输出 `impossible`。

数据保证图中不存在负权回路。

#### 输入格式

第一行包含三个整数 *n* , *m* , *k* 。

接下来 *m* 行，每行包含三个整数 *x* , *y* , *z* ，表示存在一条从点 *x* 到点 *y* 的有向边，边长为 *z* 。

接下来 *k* 行，每行包含两个整数 *x* , *y* ，表示询问点 *x* 到点 *y* 的最短距离。（点从 1 开始编号）

#### 输出格式

共 *k* 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 `impossible`。

#### 数据范围

1 ≤ *n* ≤ 200,

1 ≤ *m* ≤ 20000,

1 ≤ *k* ≤ *n*^2,

图中涉及边长绝对值均不超过 10000。



#### 输入样例：

```
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
```

#### 输出样例：

```
impossible
1
```



#### 算法思想：-可以有负权边，但不能有负权回路

Floyd算法，也称为Floyd-Warshall算法，是一种用于解决所有节点对之间最短路径的经典算法。它适用于有向图或无向图，可以处理带有负权边（但不能存在负权环）的图，时间复杂度为O(V^3)，其中V是图中的节点数。

Floyd算法的基本思想是动态规划。它通过逐步地更新图中每对节点之间的最短路径长度来计算最终的最短路径。算法的具体步骤如下：

1. 初始化一个二维数组`dist`，其中`dist[i][j]`表示节点i到节点j的最短路径长度。初始时，若节点i和节点j之间有直接的边相连，则`dist[i][j]`等于这条边的权重；否则，`dist[i][j]`设为无穷大，同时`dist[i][i]`设为0。
2. 对于每一个中间节点k（从1到V），遍历所有节点对(i, j)，更新节点i到节点j的最短路径长度`dist[i][j]`。更新的方式是通过比较直接从节点i到节点j的路径长度和从节点i经过节点k再到节点j的路径长度，选择较小的那个。
3. 不断地迭代执行步骤2，直到所有节点对的最短路径长度都被计算出来为止。

Floyd算法的优点是实现简单、易于理解，并且适用于各种类型的图。然而，由于它的时间复杂度为O(V^3)，因此在处理大规模图时可能效率较低。另外，Floyd算法不能处理存在负权环的情况，因为负权环可能导致无法计算出正确的最短路径长度。



#### 算法1(1113 ms)：

时间复杂度：O(V ^ 3)。 V 为顶点数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9;

class AMGragh {
private:
    int n;							// Number of vertices
    vector<vector<int>> weight;		// Edge table
public:
    // Initialize gragh by istream
    AMGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        weight.resize(n + 1, vector(n + 1, INF));
        for (int i = 0; i <= n; i++) {
            weight[i][i] = 0;
        }
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            weight[u][v] = min(weight[u][v], w);
        }
    }
	
    // dist[u][v] represents the shortest path length from u to v
    void floyd(vector<vector<int>>& dist) {
        dist = weight;
        // Traverse all intermediate transit vertices
    	for (int k = 1; k <= n; ++k) {
            // Traverse all starting vertices
    		for (int i = 1; i <= n; ++i) {
                // Traverse all ending vertices
    			for (int j = 1; j <= n; ++j) {
    				dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
    			}
    		}
    	}
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m, k;
    cin >> n >> m >> k;
    AMGragh G(cin, n, m);
    
    vector<vector<int>> dist;
	G.floyd(dist);
	
	while (k--) {
	    int u, v;
	    cin >> u >> v;
	    if (dist[u][v] >= INF / 2) {
	        cout << "impossible" << '\n';
	    } else {
	        cout << dist[u][v] << '\n';
	    }
	}
    
    return 0;
}
```



#### 算法2(497 ms)：

时间复杂度：O(V ^ 3)。 V 为顶点数。

1. 维护数组`int dist[1..n][1..n]` 。`dist[i][j]` 表示只允许从前 k 个节点中转的情况下，节点 `i` 到节点 `j` 的当前最短距离。初始化为图的邻接矩阵，即 `k == 0` 。
2. 进行 n 次迭代。每次迭代增加一个可供选择的中转节点 k ：
   - 分别枚举所有的始点 `i` ，所有的终点 `j` 。若允许在顶点 `k` 中转后，始点 `i` 到终点 `j` 的距离更短，则更新该距离，即 `dist[i][j] = dist[i][k] + dist[k][j]` 。
3. n 次迭代结束后，`dist[i][j]` 即为始点 `i` 到终点 `j` 的全局最短距离。

```c++
#include <iostream>
#include <algorithm>

#define endl '\n'

using namespace std;

const int N = 200, INF = N * 10000 * 2;		// 注意乘 2

int n, dist[N + 1][N + 1];

void floyd() {
    // 每轮迭代增加一个供选择的中转点
	for (int k = 1; k <= n; ++k) {
        // 枚举所有的起点
		for (int i = 1; i <= n; ++i) {
            // 枚举所有的终点
			for (int j = 1; j <= n; ++j) {
				dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
			}
		}
	}
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m, k;
	cin >> n >> m >> k;
	
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			dist[i][j] = i == j ? 0 : INF;
		}
	}
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		dist[u][v] = min(dist[u][v], w);
	}
	
	floyd();
	
	while (k--) {
		int u, v;
		cin >> u >> v;
		if (dist[u][v] > INF / 2) {
			cout << "impossible" << endl;
		}
		else {
			cout << dist[u][v] << endl;
		}
	}
	
	return 0;
}
```





### 6.AcWing0852 SPFA判断负环

给定一个 *n* 个点 *m* 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你判断图中是否存在负权回路。

#### 输入格式

第一行包含整数 *n* 和 *m* 。

接下来 *m* 行每行包含三个整数 *x*,*y*,*z*，表示存在一条从点 *x* 到点 *y* 的有向边，边长为 *z* 。

#### 输出格式

如果图中**存在**负权回路，则输出 `Yes`，否则输出 `No`。

#### 数据范围

1 ≤ *n* ≤ 2000 ,

1 ≤ *m* ≤ 10000,

图中涉及边长绝对值均不超过 10000。



#### 输入样例：

```
3 3
1 2 -1
2 3 4
3 1 -4
```

#### 输出样例：

```
Yes
```



#### 算法思想：

维护一组计数器 `int paths[1..n]` ，初值为 0 。`paths[v] == c` 表示从源点到点 `v` 的最短路径的边数为 `c` 。每次对 `v` 的入边 `<u, v>` 执行一次松弛操作时，更新对应的计数器，即 `paths[v] = paths[u] + 1`  。若计数器大于等于 n ，则说明存在负权回路。

若所有边均不可再松弛，则说明不存在负权回路。



#### 算法1：

```c++
#pragma GCC optimize(2)
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh by istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
        }
    }
    
    // Return true if negative weight ring exists
    bool existNegativeRing() {
        vector<int> hops(n + 1, 0);
        vector<int> dist(n + 1, 0);
        vector<bool> inque(n + 1, true);
        queue<int> que;
        
        for (int i = 1; i <= n; i++) {
            que.push(i);
        }
        
        // Loop until all edges cannot be relaxed
        while (!que.empty()) {
            // 1. Dequeue and visit the front vertex u
            int u = que.front();
            que.pop();
            inque[u] = false;
            
            // 2. Vist and try to relax all out edges of u
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    hops[v] = hops[u] + 1;
                    // If there is a n-length shortest path, negative ring exists
                    if (hops[v] >= n) {
                        return true;
                    }
                    // If not in queue, enqueue
                    if (!inque[v]) {
                        que.push(v);
                        inque[v] = true;
                    }
                }
            }
        }
        
        return false;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    ALGragh G(cin, n, m);
    
    cout << (G.existNegativeRing() ? "Yes" : "No") << '\n';
    
    return 0;
}
```



#### 算法2：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;
    int weight;
};

class ALGragh {
private:
    int n;
    vector<list<ArcNode>> head;
public:
    ALGragh(istream& cin) {
        int m;
        cin >> n >> m;
        head.resize(n + 1);
        while (m--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
        }
    }
    
    bool existNegativeRing() {
        vector<int> hops(n + 1, 0);
        vector<int> dist(n + 1, 0);
        vector<bool> inque(n + 1, true);
        queue<int> que;
        
        for (int i = 1; i <= n; i++) {
            que.push(i);
        }
        
        // 循环至所有边均不可再松弛
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            inque[u] = false;
            
            // 遍历所有出边并尝试松弛
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    hops[v] = hops[u] + 1;
                    // 如果存在一条长度为 n 的最短路，说明存在负环
                    if (hops[v] >= n) {
                        return true;
                    }
                    if (!inque[v]) {
                        que.push(v);
                        inque[v] = true;
                    }
                }
            }
        }
        
        return false;
    }
    
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    ALGragh G(cin);
    
    cout << (G.existNegativeRing() ? "Yes" : "No") << '\n';
    
    return 0;
}
```



#### 算法1（1771 ms)：（注意遍历所有的联通块）

时间复杂度：通常情况下可以达到O(V + E)，其中V是顶点数，E是边数。最坏时间复杂度为 O(VE)。

1. 假想一个超级源点 `O`，它有 n 条假想的出边，分别指向节点 1 到 n ，且所有假想边权重均为 0 (可以初始化为任意相同值）；
2. 新图是否有负环等价于原始的图。
3. `int dist[1..n]` 维护从假想点 `O` 到各点的最短路径长度。

因此，开始时将所有节点入队，表示从假想点出发，所有点均可达。

```c++
#include <iostream>
#include <queue>

using namespace std;

const int N = 2000, M = 10000;

int n, first[N + 1];
int vertex[M + 1], ne[M + 1], weight[M + 1], idx;

void addEdge(int u, int v, int w) {
    vertex[++idx] = v;
    weight[idx] = w;
    ne[idx] = first[u];
    first[u] = idx;
}

bool spfa() {
    int dist[N + 1], paths[N + 1];
    bool in[N + 1];
    queue<int> que;
    
    for (int i = 1; i <= n; ++i) {
        que.push(i);
        in[i] = true;
        dist[i] = paths[i] = 0;
    }
    
    // 循环至所有边均不可再松弛
    while (que.size()) {
        int u = que.front();
        que.pop();
        in[u] = false;
        
        // 遍历所有出边并尝试松弛
        for (int i = first[u]; i; i = ne[i]) {
            int v = vertex[i];
            int d = dist[u] + weight[i];
            
            if (d < dist[v]) {
                dist[v] = d;
                paths[v] = paths[u] + 1;
                
                if (paths[v] >= n) {
                    return true;
                }
                
                if (!in[v]) {
                    que.push(v);
                    in[v] = true;
                }
            }
        }
    }
    
    return false;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
    }
    
    cout << (spfa() ? "Yes" : "No");
    
    return 0;
}
```



#### 算法2：

```c++
#pragma GCC optimize(2)
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;
    int weight;
};

class ALGragh {
private:
    int n;
    vector<list<ArcNode>> head;
public:
    ALGragh(istream& cin) {
        int m;
        cin >> n >> m;
        head.resize(n + 1);
        while (m--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
        }
    }
    
    bool existNegativeRing() {
        vector<int> hops(n + 1, 0);
        vector<int> dist(n + 1, 0);
        vector<bool> inque(n + 1, true);
        queue<int> que;
        
        for (int i = 1; i <= n; i++) {
            que.push(i);
        }
        
        // 循环至所有边均不可再松弛
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            inque[u] = false;
            
            // 遍历所有出边并尝试松弛
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    hops[v] = hops[u] + 1;
                    // 如果存在一条长度为 n 的最短路，说明存在负环
                    if (hops[v] >= n) {
                        return true;
                    }
                    if (!inque[v]) {
                        que.push(v);
                        inque[v] = true;
                    }
                }
            }
        }
        
        return false;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    ALGragh G(cin);
    
    cout << (G.existNegativeRing() ? "Yes" : "No") << '\n';
    
    return 0;
}
```



### 7.AcWing 1127 spfa多源最短路

农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。

把糖放在一片牧场上，他知道 N 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。

当然，他将付出额外的费用在奶牛上。

农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。

他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。

农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。

给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。

**数据保证至少存在一个牧场和所有牛所在的牧场连通**。

#### 输入格式

第一行: 三个数：奶牛数 N，牧场数 P，牧场间道路数 C。

第二行到第 N+1 行: 1 到 N 头奶牛所在的牧场号。

第 N+2 行到第 N+C+1 行：每行有三个数：相连的牧场A、B，两牧场间距 D，当然，连接是双向的。

#### 输出格式

共一行，输出奶牛必须行走的最小的距离和。

#### 数据范围

1 ≤ *N* ≤ 500 ,

2 ≤ *P* ≤ 800 ,

1 ≤ *C* ≤ 1450 ,

1 ≤ *D* ≤ 255



#### 输入样例：

```
3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
```

#### 输出样例：

```
8
```



#### 算法1-dijkstra：

Time Complexity = O(V E log E).

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh by istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
            head[v].push_back({u, w});
        }
    }
    
    int dijkstra(int start, vector<int>& ends) {
        vector<int> dist(n + 1, INF);
        vector<bool> vis(n + 1, false);
    	using PII = pair<int, int>;			// <distance, vertex>
        priority_queue<PII, vector<PII>, greater<PII> > minHeap;
        
        dist[start] = 0;
        minHeap.emplace(0, start);
        
        while (!minHeap.empty()) {
            // 1. Pop the heap top(i.e., the nearest vertex)
            int u = minHeap.top().second;
            minHeap.pop();
            // 2. Visit the nearest vertex
            if (vis[u]) {
                continue;
            }
            vis[u] = true;
            // 3. Visit and try to relax all adjacent edges of u
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    minHeap.emplace(dist[v], v);
                }
            }
        }
        
        int res = 0;
        for (auto end : ends) {
            if (dist[end] == INF) {
                return INF;
            } else {
                res += dist[end];
            }
        }
        return res;
    }
    
    int sumMinDist(vector<int>& ends) {
        int res = INF;
        for (int i = 1; i <= n; i++) {
            res = min(res, dijkstra(i, ends));
        }
        return res;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int cows, n, m;
    cin >> cows >> n >> m;
    vector<int> ends(cows);
    for (int i = 0; i < cows; i++) {
        cin >> ends[i];
    }
    ALGragh G(cin, n, m);
    
    cout << G.sumMinDist(ends) << '\n';
    
    return 0;
}
```



#### 算法2-spfa：

Time complexity = O(V (V + E)).

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh with istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
            head[v].push_back({u, w});
        }
    }
    
    int spfa(int start, vector<int>& ends) {
        vector<int> dist(n + 1, INF);
        // inque[i] == true represents vertex i is in queue to be visited
        vector<bool> inque(n + 1, false);
        queue<int> que;
        
        // Star from vertex start with distance 0
        que.push(start);
        inque[start] = true;
        dist[start] = 0;
        
        // Loop until all edges cannot be relaxed
        while (!que.empty()) {
            // 1. Dequeue and visit the front vertex u
            int u = que.front();
            que.pop();
            inque[u] = false;
            // 2. Visit and try to relax all out edges of u
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    // If not in queue, enqueue
                    if (!inque[v]) {
                        que.push(v);
                        inque[v] = true;
                    }
                }
            }
        }
        
        int res = 0;
        for (auto end : ends) {
            if (dist[end] == INF) {
                return INF;
            } else {
                res += dist[end];
            }
        }
        return res;
    }
    
    int sumMinDist(vector<int>& ends) {
        int res = INF;
        for (int i = 1; i <= n; i++) {
            res = min(res, spfa(i, ends));
        }
        return res;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int cows, n, m;
    cin >> cows >> n >> m;
    vector<int> ends(cows);
    for (int i = 0; i < cows; i++) {
        cin >> ends[i];
    }
    ALGragh G(cin, n, m);
    
    cout << G.sumMinDist(ends) << '\n';
    
    return 0;
}
```



#### 算法1-spfa算法(426 ms)：

时间复杂度：O(V (V + E))。V, E 分别为牧场数目，路径数目。

```c++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int C = 500, V = 800, E = 1450 * 2, INF = 1e9;

int cows, id[C];
int n, first[V + 1];
int idx = 1, ne[E + 1], vertex[E + 1], weight[E + 1];

int dist[V + 1];
bool inque[V + 1];

void addEdge(int u, int v, int w) {
	weight[idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx++;
}

int spfa(int bg) {
	queue<int> que;
	
	fill_n(dist + 1, n, INF);
	fill_n(inque + 1, n, false);
	
	
	dist[bg] = 0;
	inque[bg] = true;
	que.push(bg);
	
	while (que.size()) {
		int u = que.front(); que.pop();
		inque[u] = false;
		
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (dist[u] + weight[i] < dist[v]) {
				dist[v] = dist[u] + weight[i];
				
				if (!inque[v]) {
					que.push(v);
					inque[v] = true;
				}
			}
		}
	}
	
	int res = 0;
	for (int i = 0; i < cows; i++) {
		int u = id[i];
		if (dist[u] == INF) {
			return INF;
		}
		else {
			res += dist[u];
		}
	}
	
	return res;
}

int get_ans() {
	int res = INF;
	for (int i = 1; i <= n; i++) {
		res = min(res, spfa(i));
	}
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> cows >> n >> m;
	
	for (int i = 0; i < cows; i++) {
		cin >> id[i];
	}
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
		addEdge(v, u, w);
	}
	
	cout << get_ans() << '\n';
	
	return 0;
}
```



#### 算法2-Dijkstra算法(2051 ms)：

时间复杂度：O((V + E) log E)。c, V, E 分别为牧场的数量，道路的数量。

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>

using namespace std;

const int N = 500, V = 800, E = 1450 * 2, INF = 1e9;

int cows, id[N];
int n, first[V + 1];
int idx = 1, ne[E + 1], vertex[E + 1], weight[E + 1];
 
int dist[V + 1];
bool vis[V + 1];

void addEdge(int u, int v, int w) {
	weight[idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx++;
}

int dijkstra(int bg) {
	// <dist, vertex>
	using PII = pair<int, int>;
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	
	fill_n(dist + 1, n, INF);
	fill_n(vis + 1, n, false);
	
	dist[bg] = 0;
	heap.push({0, bg});
	
	while (heap.size()) {
		int u = heap.top().second; heap.pop();
		
		if (vis[u]) {
			continue;
		}
		
		vis[u] = true;
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (!vis[v] && dist[u] + weight[i] < dist[v]) {
				dist[v] = dist[u] + weight[i];
				heap.push({dist[v], v});
			}
		}
	}
	
	int res = 0;
	for (int i = 0; i < cows; i++) {
		int ed = id[i];
		if (dist[ed] == INF) {
			return INF;
		}
		else {
			res += dist[ed];
		}
	}
	
	return res;
}

int get_ans() {
	int res = INF;
	for (int i = 1; i <= n; i++) {
		res = min(res, dijkstra(i));
	} 
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> cows >> n >> m;
	for (int i = 0; i < cows; i++) {
		cin >> id[i];
	}
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
		addEdge(v, u, w);
	}
	
	cout << get_ans() << '\n';
	
	return 0;
}
```







### 8.AcWing 1126 最小花费

在 *n* 个人中，某些人的银行账号之间可以互相转账。

这些人之间转账的手续费各不相同。

给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 *A* 最少需要多少钱使得转账后 *B* 收到 100 元。

#### 输入格式

第一行输入两个正整数 *n*,*m* ，分别表示总人数和可以互相转账的人的对数。

以下 *m* 行每行输入三个正整数 *x*,*y*,*z*，表示标号为 *x* 的人和标号为 *y* 的人之间互相转账需要扣除 *z*% 的手续费 ( *z*<100 )。

最后一行输入两个正整数 *A*,*B* 。

数据保证 *A* 与 *B* 之间可以直接或间接地转账。

#### 输出格式

输出 *A* 使得 *B* 到账 100 元最少需要的总费用。

精确到小数点后 8 位。

#### 数据范围

1 ≤ *n* ≤ 2000 ,

*m* ≤ 10^5



#### 输入样例：

```
3 3
1 2 1
2 3 2
1 3 3
1 3
```

#### 输出样例：

```
103.07153164
```



#### 算法1-dijkstra：

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

using namespace std;

class AMGragh {
private:
    int n;							// Number of vertices
    vector<vector<double>> weight;		// Edge table
public:
    AMGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        weight.resize(n + 1, vector(n + 1, 0.0));
        while (numEdge--) {
            int u, v;
            double w;
            cin >> u >> v >> w;
            weight[u][v] = weight[v][u] = 1.0 - w / 100.0;
        }
    }
	
    double dijkstra(int start, int end) {
        vector<double> dist(n + 1, 0.0);
        vector<bool> vis(n + 1, false);
        
        dist[start] = 1.0;
        
        for (int steps = 0; steps < n; steps++) {
            int u = 0;
            for (int v = 1; v <= n; v++) {
                if (!vis[v] && (!u || dist[v] > dist[u])) {
                    u = v;
                }
            }
            
            vis[u] = true;

            for (int v = 1; v <= n; v++) {
                dist[v] = max(dist[v], dist[u] * weight[u][v]);
            }
        }
        return dist[end];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    AMGragh G(cin, n, m);
    
    int start, end;
    cin >> start >> end;
    cout << fixed << setprecision(8) << 100.0 / G.dijkstra(start, end) << '\n';
    
    return 0;
}
```



#### 算法1(319 ms)：

时间复杂度：O((V + E) log E)。V, E 分别为总人数和可以互相转账的人的对数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int V = 2000;

int n, m;
double matrix[V + 1][V + 1];

double dist[V + 1];
bool vis[V + 1];

double dijkstra(int bg, int ed) {
	dist[bg] = 1.0;
	
	for (int steps = 0; steps < n - 1; steps++) {
		int u = 0;
		for (int v = 1; v <= n; v++) {
			if (!vis[v] && dist[v] > dist[u]) {
				u = v;
			}
		}
		
		if (u == ed) {
		    return dist[u];
		}
		
		vis[u] = true;
		for (int v = 1; v <= n; v++) {
			if (!vis[v]) {
				dist[v] = max(dist[v], dist[u] * matrix[u][v]);
			}
		}
	}
}

int main() {
	scanf("%d %d", &n, &m);
	while (m--) {
		int u, v, w;
		scanf("%d %d %d", &u, &v, &w);
		matrix[u][v] = matrix[v][u] = 1.0 - (double)w / 100;
	}
	
	int bg, ed;
	scanf("%d %d", &bg, &ed);
	
	printf("%.08lf\n", 100.0 / dijkstra(bg, ed));
	
	return 0;
}
```





### 9.AcWing 1101 献给阿尔吉侬的花束(flood fill)

阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。

今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。

现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。

迷宫用一个 *R*×*C* 的字符矩阵来表示。

字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。

阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。

#### 输入格式

第一行是一个正整数 *T*，表示一共有 *T* 组数据。

每一组数据的第一行包含了两个用空格分开的正整数 *R* 和 *C*，表示地图是一个 *R*×*C* 的矩阵。

接下来的 *R* 行描述了地图的具体内容，每一行包含了 *C* 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。

#### 输出格式

对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。

若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。

每组数据的输出结果占一行。

#### 数据范围

1 < *T* ≤ 10 ,

2 ≤ *R* , *C* ≤ 200



#### 输入样例：

```
3
3 4
.S..
###.
..E.
3 4
.S..
.E..
....
3 4
.S..
####
..E.
```

#### 输出样例：

```
5
1
oop!
```



##### Algorithm 1:

Time complexity : $O(tnm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

using PII = pair<int, int>;
const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

class AMGragh {
private:
    int n, m;
    PII start, end;
    vector<vector<int>> grid;

public:
    AMGragh(istream& cin) {
        cin >> n >> m;
        grid.resize(n + 2, vector<int>(m + 2, 1));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                char c;
                cin >> c;
                grid[i][j] = c == '#';
                if (c == 'S') {
                    start = {i, j};
                    grid[i][j] = 1;
                } else if (c == 'E') {
                    end = {i, j};
                }
            }
        }
    }

    int floodFill() {
        vector<vector<int>> dist(n + 2, vector<int>(m + 2, -1));
        queue<PII> que;
        
        dist[start.first][start.second] = 0;
        que.push(start);
        
        while (!que.empty()) {
            auto [x, y] = que.front();
            que.pop();
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i], ny = y + dy[i];
                if (grid[nx][ny] == 0) {
                    grid[nx][ny] = 1;
                    dist[nx][ny] = dist[x][y] + 1;
                    que.push({nx, ny});
                }
            } 
        }
        
        return dist[end.first][end.second];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int t;
    cin >> t;
    
    while (t--) {
        AMGragh G(cin);
        auto ret = G.floodFill();
        if (ret == -1) {
            cout << "oop!" << '\n';
        } else {
            cout << ret << '\n';
        }
    }
    
    return 0;
}
```





### 10.AcWing 1233 全球变暖

你有一张某海域 *N*×*N* 像素的照片，”.”表示海洋、”#”表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2 座岛屿。  

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。

具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。  

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 

#### 输入格式

第一行包含一个整数N。

以下 *N* 行 *N* 列，包含一个由字符”#”和”.”构成的 *N*×*N* 字符矩阵，代表一张海域照片，”#”表示陆地，”.”表示海洋。

照片保证第 1 行、第 1 列、第 *N* 行、第 *N* 列的像素都是海洋。

#### 输出格式

一个整数表示答案。

#### 数据范围

1 ≤ *N* ≤ 1000



#### 输入样例1：

```
7
.......
.##....
.##....
....##.
..####.
...###.
.......
```

#### 输出样例1：

```
1
```

#### 输入样例2：

```
9
.........
.##.##...
.#####...
.##.##...
.........
.##.#....
.#.###...
.#..#....
.........
```

#### 输出样例2：

```
1
```



##### Algorithm 1:

Time complexity : $O(n^2)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

class AMGragh {
private:
    int n, m;
    vector<vector<bool>> grid;

public:
    AMGragh(istream& cin) {
        cin >> n;
        m = n;
        grid.resize(n, vector<bool>(m));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                char c;
                cin >> c;
                grid[i][j] = c == '#';
            }
        }
    }
    
    vector<vector<bool>> vis;
    
    // Return if current island will be submerged or not
    bool dfs(int x, int y) {
        vis[x][y] = true;
        
        bool cur = false, adj = true;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (vis[nx][ny]) {
                continue;
            }
            
            // If current land is adjacent to the ocean, it will be submerged
            if (grid[nx][ny] == 0) {
                cur = true;
            }
            // If at least one adjacent land will not be not submerged,
            // adjacent land will not be submerged.
            else if (!dfs(nx, ny)) {
                adj = false;
            }
        }
        
        // Current island is submerged if and only if 
        // current land and all adjacent lands are submerged
        return cur && adj;
    }
    
    int traverse() {
        vis.resize(n, vector<bool>(m, false));
        int ans = 0;
        for (int i = 1; i < n - 1; i++) {
            for (int j = 1; j < m - 1; j++) {
                if (grid[i][j] && !vis[i][j]) {
                    ans += dfs(i, j);
                }
            }
        }
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    AMGragh G(cin);
    
    cout << G.traverse() << '\n';
    
    return 0;
}
```





### x48.AcWing 1113 红与黑(flood fill)

有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。

你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。

请写一个程序，计算你总共能够到达多少块黑色的瓷砖。

#### 输入格式

输入包括多个数据集合。

每个数据集合的第一行是两个整数 *W* 和 *H*，分别表示 *x* 方向和 *y* 方向瓷砖的数量。

在接下来的 *H* 行中，每行包括 *W* 个字符。每个字符表示一块瓷砖的颜色，规则如下

1）‘.’：黑色的瓷砖；
 2）‘#’：红色的瓷砖；
 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。

当在一行中读入的是两个零时，表示输入结束。

#### 输出格式

对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。

#### 数据范围

1 ≤ *W* , *H* ≤ 20



#### 输入样例：

```
6 9 
....#. 
.....# 
...... 
...... 
...... 
...... 
...... 
#@...# 
.#..#. 
0 0
```

#### 输出样例：

```
45
```



##### Algorithm 1:

Time complexity : $O(tnm)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

using PII = pair<int, int>;

const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

class AMGragh {
private:
    int n, m;
    PII start;
    vector<vector<int>> grid;

public:
    AMGragh(istream& cin, int n, int m) : n(n), m(m) {
        grid.resize(n, vector<int>(m));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                char c;
                cin >> c;
                grid[i][j] = c != '.';
                if (c == '@') {
                    start = {i, j};
                }
            }
        }
    }

    int floodFill() {
        queue<PII> que;
        
        que.push(start);
        
        int cnt = 1;
        while (!que.empty()) {
            auto [x, y] = que.front();
            que.pop();
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] == 0) {
                    grid[nx][ny] = 1;
                    cnt++;
                    que.push({nx, ny});
                }
            }
        }
        
        return cnt;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    while (cin >> m >> n, n || m) {
        AMGragh G(cin, n, m);
        cout << G.floodFill() << '\n';
    }
    
    return 0;
}
```





### y49.AcWing 1224 交换瓶子(置换群)

有 *N* 个瓶子，编号 1∼*N*，放在架子上。

比如有 5 个瓶子：

```
2 1 3 5 4
```

要求每次拿起 2 个瓶子，交换它们的位置。

经过若干次后，使得瓶子的序号为：

```
1 2 3 4 5
```

对于这么简单的情况，显然，至少需要交换 2 次就可以复位。

如果瓶子更多呢？你可以通过编程来解决。

#### 输入格式

第一行包含一个整数 *N*，表示瓶子数量。

第二行包含 *N* 个整数，表示瓶子目前的排列状况。

#### 输出格式

输出一个正整数，表示至少交换多少次，才能完成排序。

#### 数据范围

1 ≤ *N* ≤ 10000 ,



#### 输入样例1：

```
5
3 1 2 5 4
```

#### 输出样例1：

```
3
```

#### 输入样例2：

```
5
5 4 3 2 1
```

#### 输出样例2：

```
2
```



##### Algorithm 1:

Time complexity : $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    vector<int> nums(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> nums[i];
    }
    
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        while (nums[i] != i) {
            swap(nums[i], nums[nums[i]]);
            ans++;
        }
    }
    
    cout << ans << '\n';
    
    return 0;
}
```





### y50.AcWing 1240 完全二叉树的权值

给定一棵包含 *N* 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 *A*1,*A*2,⋅⋅⋅*AN*

，如下图所示：

![QQ截图20191205124611.png](https://cdn.acwing.com/media/article/image/2019/12/05/19_2f0cae5817-QQ截图20191205124611.png) 

现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？

如果有多个深度的权值和同为最大，请你输出其中最小的深度。

注：根的深度是 1 。

#### 输入格式

第一行包含一个整数 *N* 。

第二行包含 *N* 个整数 *A*1,*A*2,⋅⋅⋅*AN* 。

#### 输出格式

输出一个整数代表答案。

#### 数据范围

1 ≤ *N* ≤ 10^5 ,

−10\^5 ≤ *Ai* ≤ 10^5



#### 输入样例：

```
7
1 6 5 4 3 2 1
```

#### 输出样例：

```
2
```



##### Algorithm 1:

Time complexity : $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

const long long INF = (long long)1e10;

class CompleteBTree {
private:
    int n;
    vector<int> nodes;
    
public:
    CompleteBTree(istream& cin) {
        cin >> n;
        nodes.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            cin >> nodes[i];
        }
    }
    
    int depthOfMinTotalWeights() {
        long long maxSum = -INF, ans = 0;
        for (int depth = 1; 1 << depth - 1 <= n; depth++) {
            long long curSum = 0;
            for (int j = 1 << depth - 1; j <= min(n, (1 << depth) - 1); j++) {
                curSum += nodes[j];
            }
            if (curSum > maxSum) {
                maxSum = curSum;
                ans = depth;
            }
        }
        
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    CompleteBTree T(cin);
    
    cout << T.depthOfMinTotalWeights() << '\n';
    
    return 0;
}
```





### x51.AcWing 1096 地牢大师(flood fill)

你现在被困在一个三维地牢中，需要找到最快脱离的出路！ 

地牢由若干个单位立方体组成，其中部分不含岩石障碍可以直接通过，部分包含岩石障碍无法通过。 

向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。 

你不能沿对角线移动，迷宫边界都是坚硬的岩石，你不能走出边界范围。

请问，你有可能逃脱吗？ 

如果可以，需要多长时间？

#### 输入格式

输入包含多组测试数据。

每组数据第一行包含三个整数 *L*,*R*,*C* 分别表示地牢层数，以及每一层地牢的行数和列数。

接下来是 *L* 个 *R* 行 *C* 列的字符矩阵，用来表示每一层地牢的具体状况。

每个字符用来描述一个地牢单元的具体状况。

其中, 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。

每一个字符矩阵后面都会包含一个空行。

当输入一行为”0 0 0”时，表示输入终止。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

如果能够逃脱地牢，则输出”Escaped in x minute(s).”，其中X为逃脱所需最短时间。

如果不能逃脱地牢，则输出”Trapped!”。

#### 数据范围

1 ≤ *L* , *R* , *C* ≤ 100



#### 输入样例：

```
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0
```

#### 输出样例：

```
Escaped in 11 minute(s).
Trapped!
```



#### 算法1(849 ms)：

时间复杂度：O($nlrc$) 。 l, r, c 分别为迷宫层数，每层行数，每层列数， n 为迷宫的个数。

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

const int dx[6] = {1, -1, 0, 0, 0, 0};
const int dy[6] = {0, 0, 1, -1, 0, 0};
const int dz[6] = {0, 0, 0, 0, 1, -1};


class AMGragh {
private:
    int n, m, l;
    vector<vector<vector<int>>> maze;
    struct Pos {
        int x, y, z;
    } start, end;
    
public:
    AMGragh(istream& cin, int n, int m, int l) : n(n), m(m), l(l) {
        maze.resize(n + 2, vector<vector<int>>(m + 2, vector<int>(l + 2, 1)));
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                for (int k = 1; k <= l; k++) {
                    char c;
                    cin >> c;
                    maze[i][j][k] = c == '#';
                    if (c == 'S') {
                        start = {i, j, k};
                        maze[i][j][k] = 1;
                    } else if (c == 'E') {
                        end = {i, j, k};
                    }
                }
            }
        }
    }
    
    int floodFill() {
        vector<vector<vector<int>>> dist(n + 2, vector<vector<int>>(m + 2, vector<int>(l + 2, -1)));
        queue<Pos> que;
        
        dist[start.x][start.y][start.z] = 0;
        que.push(start);
        
        while (!que.empty()) {
            auto [x, y, z] = que.front();
            que.pop();
            
            for (int i = 0; i < 6; i++) {
                int nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];
                if (maze[nx][ny][nz] == 0) {
                    maze[nx][ny][nz] = 1;
                    dist[nx][ny][nz] = dist[x][y][z] + 1;
                    que.push({nx, ny, nz});
                }
            }
        }
        
        return dist[end.x][end.y][end.z];
    }
};

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int n, m, l;
	while (cin >> n >> m >> l, n || m || l) {
		AMGragh G(cin, n, m, l);
		
		int ret = G.floodFill();
		if (ret != -1) {
			cout << "Escaped in " << ret << " minute(s)." << '\n';
		} else {
			cout << "Trapped!" << '\n';
		}
	}
	
	return 0;
}
```















### x1.AcWing 1129 热浪

德克萨斯纯朴的民众们这个夏天正在遭受巨大的热浪！！！

他们的德克萨斯长角牛吃起来不错，可是它们并不是很擅长生产富含奶油的乳制品。

农夫John此时身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。

John已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。

这些路线包括起始点和终点一共有 *T* 个城镇，为了方便标号为 1 到 *T* 。

除了起点和终点外的每个城镇都由 **双向道路** 连向至少两个其它的城镇。

每条道路有一个通过费用（包括油费，过路费等等）。

给定一个地图，包含 *C* 条直接连接 2 个城镇的道路。

每条道路由道路的起点 *Rs*，终点 *Re* 和花费 *Ci* 组成。

求从起始的城镇 *Ts* 到终点的城镇 *Te* 最小的总费用。

#### 输入格式

第一行: 4 个由空格隔开的整数: *T* , *C* , *Ts* , *Te* ;

第 2 到第 *C*+1 行: 第 *i*+1 行描述第 *i* 条道路，包含 3 个由空格隔开的整数: *Rs* , *Re* , *Ci* 。

#### 输出格式

一个单独的整数表示从 *Ts* 到 *Te* 的最小总费用。

数据保证至少存在一条道路。

#### 数据范围

1 ≤ *T* ≤ 2500 ,

1 ≤ *C* ≤ 6200 ,

1 ≤ *Ts* , *Te* , *Rs* , *Re* ≤ *T* ,

1 ≤ *Ci* ≤ 1000



#### 输入样例：

```
7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1
```

#### 输出样例：

```
7
```



#### 算法1：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh by istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
            head[v].push_back({u, w});
        }
    }
    
    // Returns the shortest path length from the start 1 to the end 1
    // Specially, INF represents no shortest path
    int dijkstra(int start, int end) {
        vector<int> dist(n + 1, INF);
        vector<bool> vis(n + 1, false);
    	using PII = pair<int, int>;			// <distance, vertex>
        priority_queue<PII, vector<PII>, greater<PII> > minHeap;
        
        // Start from vertex start with distance 0
        dist[start] = 0;
        minHeap.emplace(0, start);
        
        // Traverse all reachable vertices
        while (!minHeap.empty()) {
            // 1. Pop the heap top(i.e., the nearest vertex)
            int u = minHeap.top().second;
            minHeap.pop();
            // 2. Visit the nearest vertex
            if (vis[u]) {
                continue;
            }
            vis[u] = true;
            // 3. Visit and try to relax all adjacent edges of u
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    minHeap.emplace(dist[v], v);
                }
            }
        }
        return dist[end];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m, start, end;
    cin >> n >> m >> start >> end;
    ALGragh G(cin, n, m);
    
    int ret = G.dijkstra(start, end);
    cout << (ret == INF ? -1 : ret) << '\n';
    
    return 0;
}
```



#### 算法1(21 ms)：

时间复杂度：O((V + E) log E)。V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>

using namespace std;

const int V = 2500, E = 6200 * 2, INF = 1e9;

int n, m, bg, ed, first[V + 1];
int idx = 1, ne[E + 1], vertex[E + 1], weight[E + 1];

int dist[V + 1];
bool vis[V + 1];

void addEdge(int u, int v, int w) {
	weight[idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx++;
}

int dijkstra() {
	// <dist, vertex>
	using PII = pair<int, int>;
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	
	fill_n(dist, n + 1, INF);
	
	dist[bg] = 0;
	heap.push({0, bg});
	
	while (heap.size()) {
		int u = heap.top().second; heap.pop();
		if (vis[u]) {
			continue;
		} 
		
		if (u == ed) {
			return dist[u];
		}
		
		vis[u] = true;
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (!vis[v] && dist[u] + weight[i] < dist[v]) {
				dist[v] = dist[u] + weight[i];
				heap.push({dist[v], v});
			}
		}
	}
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> m >> bg >> ed;
	for (int i = 0; i < m; i++) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
		addEdge(v, u, w);
	}
	
	cout << dijkstra() << '\n';
	
	return 0;
}
```





### x2.AcWing 1128 信使

战争时期，前线有 *n* 个哨所，每个哨所可能会与其他若干个哨所之间有通信联系。

信使负责在哨所之间传递信息，当然，这是要花费一定时间的（以天为单位）。

指挥部设在第一个哨所。

当指挥部下达一个命令后，指挥部就派出若干个信使向与指挥部相连的哨所送信。

当一个哨所接到信后，这个哨所内的信使们也以同样的方式向其他哨所送信。**信在一个哨所内停留的时间可以忽略不计**。

直至所有 *n* 个哨所全部接到命令后，送信才算成功。

因为准备充足，每个哨所内都安排了足够的信使（如果一个哨所与其他 *k* 个哨所有通信联系的话，这个哨所内至少会配备 *k* 个信使）。

现在总指挥请你编一个程序，计算出完成整个送信过程最短需要多少时间。

#### 输入格式

第 1 行有两个整数 *n* 和 *m*，中间用 1 个空格隔开，分别表示有 *n* 个哨所和 *m* 条通信线路。

第 2 至 *m*+1 行：每行三个整数 *i*、*j*、*k*，中间用 1 个空格隔开，表示第 *i* 个和第 *j* 个哨所之间存在 **双向** 通信线路，且这条线路要花费 *k*  天。

#### 输出格式

一个整数，表示完成整个送信过程的最短时间。

如果不是所有的哨所都能收到信，就输出 -1 。

#### 数据范围

1 ≤ *n* ≤ 100 ,

1 ≤ *m* ≤ 200 ,

1 ≤ *k* ≤ 1000



#### 输入样例：

```
4 4
1 2 4
2 3 7
2 4 1
3 4 6
```

#### 输出样例：

```
11
```



算法1：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>
#include <functional>

using namespace std;

const int INF = 1e9;

struct ArcNode {
    int adjvex;		// Adjacent vertex
    int weight;		// Weight of edge
};

class ALGragh {
private:
    int n;							// Number of vertices
    vector<list<ArcNode>> head;		// Adjacent list
public:
    // Initialize gragh with istream
    ALGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        head.resize(n + 1);
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            head[u].push_back({v, w});
            head[v].push_back({u, w});
        }
    }
    
    int dijkstra(int start, int end) {
        vector<int> dist(n + 1, INF);
        vector<bool> vis(n + 1, false);
    	using PII = pair<int, int>;			// <distance, vertex>
        priority_queue<PII, vector<PII>, greater<PII> > minHeap;
        
        // Start from vertex start with distance 0
        dist[start] = 0;
        minHeap.emplace(0, start);
        
        // Traverse all reachable vertices
        int res = 0, cnt = 0;
        while (!minHeap.empty()) {
            // 1. Pop the heap top(i.e., the nearest vertex)
            auto [curDist, u] = minHeap.top();
            minHeap.pop();
            // 2. Visit the nearest vertex
            if (vis[u]) {
                continue;
            }
            vis[u] = true;
            res = curDist;
            cnt++;
            // 3. Visit and try to relax all adjacent edges of u
            for (auto [v, w] : head[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    minHeap.emplace(dist[v], v);
                }
            }
        }
        return cnt == n ? res : -1;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    ALGragh G(cin, n, m);
    
    cout << G.dijkstra(1, n) << '\n';
    
    return 0;
}
```



#### 算法1(12 ms)：

时间复杂度：O((V + E) log E)。V, E 分别为图的顶点数，边数。

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>

using namespace std;

const int V = 100, E = 200 * 2, INF = 1e9;

int n, first[V + 1];
int idx = 1, ne[E + 1], vertex[E + 1], weight[E + 1];

int dist[V + 1];
bool vis[V + 1];

void addEdge(int u, int v, int w) {
	weight[idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx++;
}

int dijkstra() {
	// <dist, vertex>
	using PII = pair<int, int>;
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	
	fill_n(dist, n + 1, INF);
	
	dist[1] = 0;
	heap.push({0, 1});
	
	int res = 0, cnt = 0;
	while (heap.size()) {
		int d = heap.top().first, u = heap.top().second;
		heap.pop();
		
		if (vis[u]) {
			continue;
		}
		
		vis[u] = true;
		res = d;
		cnt++;
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (!vis[v] && dist[u] + weight[i] < dist[v]) {
				dist[v] = dist[u] + weight[i];
				heap.push({dist[v], v});
			}
		}
	}
	
	return cnt == n ? res : -1;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
		addEdge(v, u, w);
	}
	
	cout << dijkstra() << '\n';
	
	return 0;
}
```







### x96.AcWing 1127 香甜的黄油(spfa)

农夫John发现了做出全威斯康辛州最甜的黄油的方法：糖。

把糖放在一片牧场上，他知道 N 只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。

当然，他将付出额外的费用在奶牛上。

农夫John很狡猾，就像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。

他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。

农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。

给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。

**数据保证至少存在一个牧场和所有牛所在的牧场连通**。

#### 输入格式

第一行: 三个数：奶牛数 N，牧场数 P，牧场间道路数 C。

第二行到第 N+1 行: 1 到 N 头奶牛所在的牧场号。

第 N+2 行到第 N+C+1 行：每行有三个数：相连的牧场A、B，两牧场间距 D，当然，连接是双向的。

#### 输出格式

共一行，输出奶牛必须行走的最小的距离和。

#### 数据范围

1 ≤ *N* ≤ 500 ,

2 ≤ *P* ≤ 800 ,

1 ≤ *C* ≤ 1450 ,

1 ≤ *D* ≤ 255



#### 输入样例：

```
3 4 5
2
3
4
1 2 1
1 3 5
2 3 7
2 4 3
3 4 5
```

#### 输出样例：

```
8
```



##### Algorithm 1-SPFA:

Time complexity : $O(n(n + m))$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

class ALGraph {
private:
    struct Edge {
        int adjvex; // Adjacent vertex
        int weight; // Edge weight
    };

    int n;                            // Number of vertices
    vector<int> cows;                 // Locations of cows
    vector<list<Edge>> heads;         // Adjacency list for edges

public:
    ALGraph(istream& cin, int numCow, int numVex, int numEdge) {
        cows.resize(numCow);
        for (auto& x : cows) {
            cin >> x;
        }
        
        n = numVex;
        heads.resize(n + 1); // Vertices are 1-indexed
        
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            heads[u].push_back({v, w});
            heads[v].push_back({u, w});
        }
    }
    
    // Shortest Path Faster Algorithm (SPFA)
    int spfa(int start) {
        vector<int> dist(n + 1, INF);  // Distance from start to each vertex
        vector<bool> inque(n + 1, false); // Whether a vertex is in the queue
        queue<int> que;
        
        dist[start] = 0;
        inque[start] = true;
        que.push(start);
        
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            inque[u] = false;
            
            for (auto [v, w] : heads[u]) {
                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    if (!inque[v]) {
                        inque[v] = true;
                        que.push(v);
                    }
                }
            }
        }
        
        int res = 0;
        for (auto u : cows) {
            if (dist[u] == INF) {
                return INF; // If any cow is unreachable
            }
            res += dist[u];
        }
        return res;
    }
    
    // Minimize the total distance for all cows
    int minTotalDist() {
        int ans = INF;
        for (int i = 1; i <= n; i++) {
            ans = min(ans, spfa(i));
        }
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int t, n, m;
    cin >> t >> n >> m; // t = number of cows, n = number of vertices, m = number of edges
    
    ALGraph G(cin, t, n, m);
    
    int result = G.minTotalDist();
    cout << result << '\n';
    
    return 0;
}

```



#### 算法2-Dijkstra算法(2051 ms)：

时间复杂度：O((V + E) log E)。c, V, E 分别为牧场的数量，道路的数量。

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>

using namespace std;

const int N = 500, V = 800, E = 1450 * 2, INF = 1e9;

int cows, id[N];
int n, first[V + 1];
int idx = 1, ne[E + 1], vertex[E + 1], weight[E + 1];
 
int dist[V + 1];
bool vis[V + 1];

void addEdge(int u, int v, int w) {
	weight[idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx++;
}

int dijkstra(int bg) {
	// <dist, vertex>
	using PII = pair<int, int>;
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	
	fill_n(dist + 1, n, INF);
	fill_n(vis + 1, n, false);
	
	dist[bg] = 0;
	heap.push({0, bg});
	
	while (heap.size()) {
		int u = heap.top().second; heap.pop();
		
		if (vis[u]) {
			continue;
		}
		
		vis[u] = true;
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (!vis[v] && dist[u] + weight[i] < dist[v]) {
				dist[v] = dist[u] + weight[i];
				heap.push({dist[v], v});
			}
		}
	}
	
	int res = 0;
	for (int i = 0; i < cows; i++) {
		int ed = id[i];
		if (dist[ed] == INF) {
			return INF;
		}
		else {
			res += dist[ed];
		}
	}
	
	return res;
}

int get_ans() {
	int res = INF;
	for (int i = 1; i <= n; i++) {
		res = min(res, dijkstra(i));
	} 
	
	return res;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> cows >> n >> m;
	for (int i = 0; i < cows; i++) {
		cin >> id[i];
	}
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
		addEdge(v, u, w);
	}
	
	cout << get_ans() << '\n';
	
	return 0;
}
```







### x98.AcWing 0920 最优乘车(bfs最短路)

*H* 城是一个旅游胜地，每年都有成千上万的人前来观光。

为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。

每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。

一名旅客最近到 *H* 城旅游，他很想去 *S* 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 *S* 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 *S* 公园。

现在用整数 1,2,…*N* 给 *H* 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 1，*S* 公园巴士站的编号为 *N* 。

写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 *S* 公园的过程中换乘的次数最少。

#### 输入格式

第一行有两个数字 *M* 和 *N*，表示开通了 *M* 条单程巴士线路，总共有 *N* 个车站。

从第二行到第 *M*+1 行依次给出了第 1 条到第 *M* 条巴士线路的信息，其中第 *i*+1 行给出的是第 *i* 条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号，相邻两个站号之间用一个空格隔开。

#### 输出格式

共一行，如果无法乘巴士从饭店到达 *S* 公园，则输出 `NO`，否则输出最少换乘次数，换乘次数为 0 表示不需换车即可到达。

#### 数据范围

1 ≤ *M* ≤ 100 ,

2 ≤ *N* ≤ 500		-经测试，每条巴士线路上的车站数不超过 100 -2024/04/11 注



#### 输入样例：

```
3 7
6 7
4 7 3 6
2 1 3 5
```

#### 输出样例：

```
2
```



##### Algorithm 1:

Time complexity : $O(n ^ 2)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <string>
#include <sstream>

using namespace std;

class AMGragh {
private:
    int n;
    vector<vector<bool>> weight;

public:
    AMGragh(istream& cin) {
        int m;
        cin >> m >> n;
        
        weight.assign(n + 1, vector<bool>(n + 1, 0));
        
        cin.ignore(10, '\n');
        while (m--) {
            string line;
            getline(cin, line);
            stringstream ssin(line);
            
            vector<int> stops;
            int v;
            while (ssin >> v) {
                for (auto u : stops) {
                    weight[u][v] = 1;
                }
                stops.push_back(v);
            }
        }
    }

    int bfs() {
        vector<int> dist(n + 1, -1);
        queue<int> que;
        
        dist[1] = 0;
        que.push(1);
        
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            
            for (int v = 1; v <= n; v++) {
                if (dist[v] == -1 && weight[u][v]) {
                    dist[v] = dist[u] + 1;
                    que.push(v);
                }
            }
        }
        
        return dist[n];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    AMGragh G(cin);
    
    int ret = G.bfs();
    if (ret == -1) {
        cout << "NO" << '\n';
    } else {
        cout << ret - 1 << '\n';
    }
    
    return 0;
}
```











### x99.AcWing 0903 昂贵的聘礼(dijkstra)

年轻的探险家来到了一个印第安部落里。

在那里他和酋长的女儿相爱了，于是便向酋长去求亲。

酋长要他用 10000 个金币作为聘礼才答应把女儿嫁给他。

探险家拿不出这么多金币，便请求酋长降低要求。

酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要 8000 金币。如果你能够弄来他的水晶球，那么只要 5000 金币就行了。”

探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。

探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。

不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。

探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。

另外他要告诉你的是，在这个部落里，等级观念十分森严。

地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。

他是一个外来人，所以可以不受这些限制。

但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。

因此你需要在考虑所有的情况以后给他提供一个最好的方案。 

为了方便起见，我们把所有的物品从 1 开始进行编号，酋长的允诺也看作一个物品，并且编号总是 1 。

每个物品都有对应的价格 *P* ，主人的地位等级 *L*，以及一系列的替代品 *Ti* 和该替代品所对应的”优惠” *Vi* 。

如果两人地位等级差距超过了 *M* ，就不能”间接交易”。

你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。 

#### 输入格式

输入第一行是两个整数 *M*，*N* ，依次表示地位等级差距限制和物品的总数。

接下来按照编号从小到大依次给出了 *N* 个物品的描述。

每个物品的描述开头是三个非负整数 *P*、*L*、*X* ，依次表示该物品的价格、主人的地位等级和替代品总数。

接下来 *X* 行每行包括两个整数 *T* 和 *V* ，分别表示替代品的编号和”优惠价格”。

#### 输出格式

输出最少需要的金币数。

#### 数据范围

1 ≤ *N* ≤ 100 ,

1 ≤ *P* ≤ 10000 ,

1 ≤ *L* , *M* ≤ *N* ,

0 ≤ *X* < *N*



#### 输入样例：

```
1 4
10000 3 2
2 8000
3 5000
1000 2 1
4 200
3000 2 1
4 200
50 2 0
```

#### 输出样例：

```
5250
```



##### Algorithm 1:

Time complexity = $O(mn^2)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

class AMGraph {
private:
    int delta;
    int n;
    vector<int> levels;
    vector<vector<int>> weight;

public:
    AMGraph(istream& cin) {
        cin >> delta >> n;

        levels.resize(n + 1);
        weight.assign(n + 1, vector<int>(n + 1, INF));
        for (int i = 0; i <= n; i++) {
            weight[i][i] = 0;  // Self-loops have zero weight
        }

        for (int v = 1; v <= n; v++) {
            int t;
            cin >> weight[0][v] >> levels[v] >> t;  // Vex_0 is the super source point

            while (t--) {
                int u, w;
                cin >> u >> w;
                weight[u][v] = w;  // Directed edge u -> v with weight w
            }
        }
    }
    
    int dijkstra(int low, int high) {
        vector<int> dist(n + 1, INF);
        vector<bool> vis(n + 1, false);
        
        dist[0] = 0;        // Start from the super source
        
        for (int s = 0; s <= n; s++) {
            int u = -1;
            for (int v = 0; v <= n; v++) {
                if (!vis[v] && (u == -1 || dist[v] < dist[u])) {
                    u = v;
                }
            }
            
            vis[u] = true;
            for (int v = 1; v <= n; v++) {
                // Only update if vertex `v` is within the valid level range and has an edge
                if (!vis[v] && levels[v] >= low && levels[v] <= high) {
                    dist[v] = min(dist[v], dist[u] + weight[u][v]);
                }
            }
        }
        
        return dist[1];
    }

    int minTotalCost() {
        int ans = INF;
        for (int i = levels[1] - delta; i <= levels[1]; i++) {
            ans = min(ans, dijkstra(i, i + delta));
        }
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    AMGraph G(cin);

    cout << G.minTotalCost() << '\n';

    return 0;
}

```





### x100.AcWing 1135 新年好(tag.)

重庆城里有 *n* 个车站，*m* 条 **双向** 公路连接其中的某些车站。

每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。

在一条路径上花费的时间等于路径上所有公路需要的时间之和。

佳佳的家在车站 1，他有五个亲戚，分别住在车站 *a*,*b*,*c*,*d*,*e*。

过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。

怎样走，才需要最少的时间？

#### 输入格式

第一行：包含两个整数 *n*,*m* ，分别表示车站数目和公路数目。

第二行：包含五个整数 *a*,*b*,*c*,*d*,*e* ，分别表示五个亲戚所在车站编号。

以下 *m* 行，每行三个整数 *x*,*y*,*t* ，表示公路连接的两个车站编号和时间。

#### 输出格式

输出仅一行，包含一个整数 *T* ，表示最少的总时间。

#### 数据范围

1 ≤ *n* ≤ 50000 ,

1 ≤ *m* ≤ 10^5 ,

1 < *a* , *b* , *c* , *d* , *e* ≤ *n* ,

1 ≤ *x* , *y* ≤ *n* ,

1 ≤ *t* ≤ 100



#### 输入样例：

```
6 6
2 3 4 5 6
1 2 8
2 3 3
3 4 4
4 5 5
5 6 2
1 6 7
```

#### 输出样例：

```
21
```



```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <list>

using namespace std;

const int INF = 1e9;

class ALGragh {
private:
    struct Edge {
        int adjvex;
        int weight;
    };

    int n;
    int n2 = 6;
    vector<int> stops;
    vector<list<Edge>> heads;

public:
    ALGragh(istream& cin) {
        int m;
        cin >> n >> m;
        
        stops.resize(n2);
        stops[1] = 1;
        for (int i = 2; i <= n2; i++) {
            cin >> stops[i];
        }
        
        heads.resize(n + 1);
        while (m--) {
            int u, v, w;
            cin >> u >> v >> w;
            heads[u].push_back({v, w});
            heads[v].push_back({u, w});
        }
    }
    
    vector<vector<int>> minDist;
    
    void dijkstra(int idx, int start) {
        vector<int> dist(n + 1, INF);
        vector<bool> vis(n + 1, false);
        
        // <dist, adjvex>
        using PII = pair<int, int>;
        priority_queue<PII, vector<PII>, greater<PII>> minHeap;
        
        dist[start] = 0;
        minHeap.push({0, start});
        
        while (!minHeap.empty()) {
            int u = minHeap.top().second;
            minHeap.pop();
            
            vis[u] = true;
            for (auto [v, w] : heads[u]) {
                if (!vis[v] && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    minHeap.push({dist[v], v});
                }
            }
        }
        
        for (int i = 1; i <= n2; i++) {
            int end = stops[i];
            minDist[idx][end] = dist[end];
        }
    }
    
    void dfs(int u, int state, int preStop, int curSum, int& ans) {
        if (u == n2) {
            ans = min(ans, curSum);
            return;
        }
        
        for (int i = 0; i < n2; i++) {
            if (!(state >> i & 1)) {
                int curStop = stops[i + 1];
                dfs(u + 1, state | 1 << i, curStop, curSum + minDist[preStop][curStop], ans);
            }
        }
    }
    
    int minTotalDist() {
        minDist.resize(n2 + 1, vector<int>(n2 + 1, 0));
        for (int i = 1; i <= n2; i++) {
            dijkstra(i, stops[i]);
        }
        
        int ans = INF;
        dfs(0, 0, 0, 0, ans);
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    ALGragh G(cin);
    
    cout << G.minTotalDist() << '\n';
    
    return 0;
}
```



#### 算法1(1163 ms)：

时间复杂度：O((V + E) log E)。V, E 分别为车站数，公路数。

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>

using namespace std;

const int N = 50000, M = 1e5 * 2, INF = 1e9;
const int N2 = 5;

int n, m, first[N + 1];
int idx = 1, ne[M + 1], vertex[M + 1], weight[M + 1];

// dijkstra() 的辅助变量
int dist[N + 1];
bool vis[N + 1];

// stops[i] = 0, a, b, c, d, e;
// matrix[i][j] 维护 6 者两两间的距离
int n2 = N2, stops[N2 + 1];
int matrix[N2 + 1][N2 + 1];

void addEdge(int u, int v, int w) {
	weight[idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx++;
}

int dijkstra(int bg) {
	// <dist, vertex>
	using PII = pair<int, int>;
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	
	fill_n(dist + 1, n, INF);
	fill_n(vis + 1, n, false);
	
	dist[bg] = 0;
	heap.push({0, bg});
	
	while (heap.size()) {
		int u = heap.top().second;
		heap.pop();
		
		if (vis[u]) {
			continue;
		}
		
		vis[u] = true;
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (!vis[v] && dist[u] + weight[i] < dist[v]) {
				dist[v] = dist[u] + weight[i];
				heap.push({dist[v], v});
			}
		}
	}
}

int ans = INF;

// 当前已经枚举了 u 个数，上一个是 pre, 
// state 维护是否已选择, sum 是总距离的和
void dfs(int u, int pre, int state, int sum) {
    if (u == n2) {
        ans = min(ans, sum);
        return;
    }
    
    for (int i = 1; i <= n2; i++) {
        if (!(state >> i & 1)) {
            dfs(u + 1, i,  state | 1 << i, sum + matrix[pre][i]);
        }
    }
}

void get_ans() {
	for (int i = 0; i <= n2; i++) {
	    dijkstra(stops[i]);
		for (int j = i + 1; j <= n2; j++) {
			matrix[i][j] = matrix[j][i] = dist[stops[j]];
		}
	}
	
	dfs(0, 0, 1, 0);
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n >> m;
	stops[0] = 1;
	for (int i = 1; i <= n2; i++) {
		cin >> stops[i];
	}
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
		addEdge(v, u, w);
	}
	
	get_ans();
	
	cout << ans << '\n';
	
	return 0;
}
```







## 1-2.最小生成树模型

### 1.AcWing0858 Prim算法（稠密图）

给定一个 *n* 个点 *m* 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 *G* = ( *V* , *E* ) ，其中 *V* 表示图中点的集合，*E* 表示图中边的集合，*n*=|*V*|，*m*=|*E*| 。

由 *V* 中的全部 *n* 个顶点和 *E* 中 *n*−1 条边构成的无向连通子图被称为 *G* 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 *G* 的最小生成树。

##### 输入格式

第一行包含两个整数 *n* 和 *m* 。

接下来 *m* 行，每行包含三个整数 *u* , *v* , *w* , 表示点 *u* 和点 *v* 之间存在一条权值为 *w* 的边。

##### 输出格式

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

##### 数据范围

1 ≤ *n* ≤ 500 ,

1 ≤ *m* ≤ 10^5,

图中涉及边的边权的绝对值均不超过 10000 。



##### 输入样例：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

##### 输出样例：

```
6
```



#### 算法思想：

Prim算法是一种用于解决加权无向图的最小生成树（Minimum Spanning Tree，MST）问题的经典算法。它的基本思想是贪心算法，通过逐步选择边来构建最小生成树，保证每一步选择的边都是当前连接已选择节点和未选择节点的最小权重边。

Prim算法的具体步骤如下：

1. 选择一个起始节点作为树的根节点，并将其加入最小生成树中。
2. 从树中已选择的节点开始，不断选择与树相连的未选择节点中权重最小的边，并将其加入最小生成树中。
3. 重复步骤2，直到所有节点都被加入到最小生成树中为止。

在Prim算法的执行过程中，通常使用一个优先队列（最小堆）来存储当前与已选择节点相连的未选择节点，并按照它们与已选择节点的边的权重进行排序。每次从优先队列中取出权重最小的节点，并将其加入最小生成树中。

Prim算法的时间复杂度与优先队列的实现方式有关，通常为O(ElogV)，其中V是图中的节点数，E是图中的边数。Prim算法在实践中效率较高，尤其适用于稠密图（边数较多）的最小生成树问题。



#### 算法过程：

使用到的辅助信息如下：

1. `bool vis[1..n]` ，维护一个待访问过的点的集合（简称“圈”）。初始为 `false` ，表示所有点均未访问。

2. `int dist[1..n]` ，维护圈外各点连接圈内的点的最短边的的权值。`dist[i] == w` 表示顶点 `i` 的所有连接圈内的边的最小边权为 `w` ，初始化为正无穷。

算法过程如下：

1. 标记 `dist[sour] = 0` ，表示我们将从源点 `sour` 开始建树。
2. 进行 n 轮迭代。每轮迭代访问一个节点，并加入圈内：
   - 从圈外找到距离圈内的距离最小的点 `u` 。访问顶点 `u` 。
   - 记录该边的边权 `dist[u]` ，若为 `INF` ，则说明圈外的点与圈内的点不联通，即最小生成树不存在，退出算法。否则更新当前树的权重，即 `res += dist[u]` 。
   - 遍历 `u` 的所有边，更新圈外的点到点 `u` 的距离。
3. 若所有节点已访问，返回最终结果 `res` 。



#### 算法1：

时间复杂度：O(V ^ 2)。V 为顶点数。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9;

class AMGragh {
private:
    int n;							// Number of vertices
    vector<vector<int>> weight;		// Edge table
public:
    // Initialize gragh by istream
    AMGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        weight.resize(n + 1, vector(n + 1, INF));
        for (int i = 0; i <= n; i++) {
            weight[i][i] = 0;
        }
        while (numEdge--) {
            int u, v, w;
            cin >> u >> v >> w;
            weight[u][v] = weight[v][u] = min(weight[u][v], w);
        }
    }
	
	// Returns the sum of the tree edge weights of the minimum spanning tree
    // Specially, INF represents the minimum spanning tree does not exist
    int prim() {
        vector<int> dist(n + 1, INF);
        vector<bool> vis(n + 1, false);

        // Start from vertex 1
        dist[1] = 0;
        
        // An n-round iteration is performed, and one node is visited per round.
        int res = 0;
        for (int i = 0; i < n; ++i) {
            // 1. Find the vertex u with the smallest distance outside the circle.
            int u = 0;
            for (int v = 1; v <= n; ++v) {
                if (!vis[v] && dist[v] < dist[u]) {
                    u = v;
                }
            }
            
            // 2. Visit vertex u
            if (dist[u] == INF) {
                return INF;
            }
            vis[u] = true;
            res += dist[u];
            
            // 3. Visit and try to relax all adjacent edges of u
            for (int v = 1; v <= n; ++v) {
                dist[v] = min(dist[v], weight[u][v]);
            }
        }
        
        return res;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    AMGragh G(cin, n, m);
    
	int ret = G.prim();
	if (ret == INF) {
	    cout << "impossible" << '\n';
	} else {
	    cout << ret << '\n';
	}
    
    return 0;
}
```



#### 算法1(127 ms)：

时间复杂度：O(V ^ 2)。V 为顶点数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 500, INF = (N - 1) * 10000 + 1;

int matrix[N + 1][N + 1], n;

void addEdge(int u, int v, int w) {
    matrix[v][u] = matrix[u][v] = min(matrix[u][v], w);
}

int Prim() {
    bool vis[N + 1];
    int dist[N + 1];
    
	for (int i = 0; i <= n; ++i) {
        vis[i] = false;
        dist[i] = INF;
    }
    
    // 从源点 1 出发
    dist[1] = 0;
    
    // 进行 n 轮迭代,每轮访问一个节点
    int res = 0;
    for (int i = 0; i < n; ++i) {
        // 从圈外找到距离圈内的距离最小的点 u
        int u = 0;
        for (int v = 1; v <= n; ++v) {
            if (!vis[v] && dist[v] < dist[u]) {
                u = v;
            }
        }
        
        if (dist[u] == INF) {
            return INF;
        }
        
        // 访问点 u
        vis[u] = true;
        res += dist[u];
        
        // 访问并尝试松弛 u 的所有出边
        for (int v = 1; v <= n; ++v) {
            dist[v] = min(dist[v], matrix[u][v]);
        }
    }
    
    // n 轮迭代后,返回结果
    return res;
}

int main () {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= n; ++j) {
            matrix[i][j] = i == j ? 0 : INF;
        }
    }
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        addEdge(u, v, w);
    }
    
    int res = Prim();
    if (res == INF) {
        cout << "impossible";
    }
    else {
        cout << res;
    }
    
    return 0;
}
```



#### 算法2-最小堆(785 ms)：

时间复杂度：O(V log E)。其中 V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#include <functional>

using namespace std;

const int N = 500, INF = (N - 1) * 10000 + 1;

int n, matrix[N + 1][N + 1];

int prim() {
    // <dist, vertex>
    using PII = pair<int, int>;
    priority_queue<PII, vector<PII>, greater<PII> > minHeap;
    
    bool vis[N + 1];
    
    fill_n(vis, n + 1, false);
    
    minHeap.push({0, 1});
    
    int res = 0;
    while (minHeap.size()) {
        auto ret = minHeap.top();
        int d = ret.first, u = ret.second;
        minHeap.pop();
        
        if (vis[u]) {
            continue;
        }
        
        vis[u] = true;
        if (d == INF) {
            return INF;
        }
        
        res += d;
        for (int v = 1; v <= n; ++v) {
            if (!vis[v]) {
                minHeap.push({matrix[u][v], v});
            }
        }
    }
    
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1 ; j <= n; ++j) {
            matrix[i][j] = i == j ? 0 : INF;
        }
    }
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        matrix[u][v] = matrix[v][u] = min(matrix[u][v], w);
    }
    
    int ret = prim();
    if (ret == INF) {
        cout << "impossible";
    }
    else {
        cout << ret;
    }
    
    return 0;
}
```







### 2.AcWing0859 Kruskal算法（稀疏图）

给定一个 *n* 个点 *m* 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 *G* = ( *V* , *E* ) ，其中 *V* 表示图中点的集合，*E* 表示图中边的集合，*n*=|*V*|，*m*=|*E*| 。

由 *V* 中的全部 *n* 个顶点和 *E* 中 *n*−1 条边构成的无向连通子图被称为 *G* 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 *G* 的最小生成树。

#### 输入格式

第一行包含两个整数 *n* 和 *m* 。

接下来 *m* 行，每行包含三个整数 *u* , *v* , *w* ，表示点 *u* 和点 *v* 之间存在一条权值为 *w* 的边。

#### 输出格式

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

1 ≤ *m* ≤ 2∗10^5 ,

图中涉及边的边权的绝对值均不超过 1000 。



#### 输入样例：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

#### 输出样例：

```
6
```



#### 算法思想：

Kruskal算法是一种用于解决加权无向图的最小生成树（Minimum Spanning Tree，MST）问题的经典算法。与Prim算法类似，Kruskal算法也是一种贪心算法，通过逐步选择边来构建最小生成树，但其不同之处在于它是基于边的选择而不是基于节点的选择。

Kruskal算法的基本思想是：

1. 将图中的所有边按照权重从小到大进行排序。
2. 依次遍历排序后的边，对于每条边，如果将其加入到当前的最小生成树中不会形成环（即不会造成已经加入最小生成树的节点之间有路径连接），则将该边加入到最小生成树中。
3. 重复步骤2，直到最小生成树中包含了图中的所有节点为止。

Kruskal算法通常使用并查集（Disjoint Set Union）来判断加入一条边是否会形成环，同时也用来维护当前已选择的节点集合的连通性。具体来说，每次加入一条边时，都检查该边的两个端点是否属于同一个连通分量（集合），如果不属于同一个连通分量，则可以加入该边，否则会形成环。

Kruskal算法的时间复杂度取决于排序边的时间复杂度和并查集的操作时间复杂度，通常为O(ElogE + ElogV)，其中V是图中的节点数，E是图中的边数。Kruskal算法在实践中效率较高，尤其适用于**稀疏图**（边数较少）的最小生成树问题。



#### 算法过程：

算法过程如下：

注：以下描述中，如果一条边被选择用于构成最小生成树，则我们称它为“在圈内”，否则称为“在圈外”。初始时，所有边均在圈外。

1. 初始时计数器 `cnt` 为 0 ，圈内各边的权重和 `res` 等于 0 。初始化并查集。初始化所有边，即将所有边按边权递增的顺序排序。
2. 按边权重递增的顺序遍历所有边。每次从圈外选择一条权重最小，且选择后不会形成环的边，将这条边加入圈内，更新圈内边的权重和，并增加计数器。
3. 当所有边遍历结束后，如果计数器的值为 n-1 ，则说明最小生成树已构建，返回 `res` 。否则，说明最小生成树不存在，返回 `INF` 。



#### 算法1：

时间复杂度通常为O($E log_2 E + E \alpha (V)$)，其中V是图中的节点数，E是图中的边数。

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int INF = 1e9;

class UFSet { 
private:
    int n;                  // Number of nodes
    vector<int> fa;         // Array to store parent pointers

public:
    // Initialize UFSet with number of nodes
    UFSet(int numNodes) {
        n = numNodes;       	// Initialize number of nodes
        fa.resize(n + 1, -1);	// Initialize parent pointers to -1
    }
    
    // Find the root of u with path compression
    int Find(int u) {
        return fa[u] == -1 ? u : fa[u] = Find(fa[u]);
    }
    
    // Union the sets containing u and v
    void Union(int u, int v) {
        fa[Find(u)] = Find(v);
    }
};

struct Edge {
    int u, v, w;
    
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
};

// Triple Table
class TTGragh {
private:
    int n;					// Number of vertices
    vector<Edge> edges;		// Edge table
public:
    // Initialize gragh by istream
    TTGragh(istream& cin, int numVex, int numEdge) {
        n = numVex;
        for (int i = 0; i < numEdge; i++) {
            int u, v, w;
            cin >> u >> v >> w;
            edges.push_back({u, v, w});
        }
    }
    
    // Returns the sum of the tree edge weights of the minimum spanning tree
    // Specially, INF represents the minimum spanning tree does not exist
    int kruskal() {
        sort(edges.begin(), edges.end());
        UFSet ufs(n);
        
        // Select an edge with the smallest weight from the outside of the circle 
        // with no ring formed after selection, and perform n-1 times.
        int res = 0, cnt = 0;
        for (auto [u, v, w] : edges) {
            // 1. Ring cannot be formed after selection
            int ru = ufs.Find(u), rv = ufs.Find(v);
            if (ru == rv) {
                continue;
            }
            // 2. Visit edge (u, v)
            cnt++;
            res += w;
            // 3. Update current state
            ufs.Union(ru, rv);
        }
        return cnt == n - 1 ? res : INF;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    TTGragh G(cin, n, m);
    
    int ret = G.kruskal();
    if (ret == INF) {
        cout << "impossible" << '\n';
    }
    else {
        cout << ret << '\n';
    }
    
    return 0;
}
```



#### 算法1(453 ms)：

时间复杂度通常为O($E log_2 E + E \alpha (V)$)，其中V是图中的节点数，E是图中的边数。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100000, M = N * 2, INF = N * 1000;

// 并查集
int n, m, fa[N + 1];

struct Edge {
    int u, v, w;
    
    // 按边权比较
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
} edges[M];

// 带路径压缩的查找
int findRoot(int u) {
    if (!fa[u]) {
        return u;
    }
    
    return fa[u] = findRoot(fa[u]);
}

int Kruskal() {
    sort(edges, edges + m);
    
    // 从圈外选择一条权重最小，且选择后不会形成环的边，选择 n-1 条
    int res = 0, cnt = 0;
    for (int i = 0; i < m; ++i) {
        // 选择后不能形成环
        int ru = findRoot(edges[i].u), rv = findRoot(edges[i].v);
        if (ru == rv) {
            continue;
        }
        
        // 访问边 (u, v)
        ++cnt;
        res += edges[i].w;
        fa[ru] = rv;
    }
    
    // 返回最终结果
    return cnt == n - 1 ? res : INF;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> m;
	for (int i = 0; i < m; ++i) {
		cin >> edges[i].u >> edges[i].v >> edges[i].w;
    }
    
    int ret = Kruskal();
    if (ret == INF) {
        cout << "impossible";
    }
    else {
        cout << ret;
    }
    
    return 0;
}
```



#### 算法2-Prim算法-最小堆优化(1410 ms)：

时间复杂度：O(V log E) 。V, E 分别为顶点数，边数。

```c++
#include <iostream>
#include <queue>
#include <functional>
#include <algorithm>

using namespace std;

const int N = 1e5, M = 4e5, INF = N * 1000;

int n, first[N + 1];
int idx, ne[M + 1], vertex[M + 1], weight[M + 1]; 

void addEdge(int u, int v, int w) {
	weight[++idx] = w;
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx;
}

int prim() {
	bool vis[N + 1];
	fill_n(vis, n + 1, false);
	
	// <weight, vertex>
	using PII = pair<int, int>;
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	
	heap.push({0, 1});
	
	int res = 0, cnt = 0;
	while (heap.size()) {
		auto ret = heap.top(); heap.pop();
		int w = ret.first, u = ret.second;
		if (vis[u]) {
			continue;
		}
		
		vis[u] = true;
		cnt++;
		res += w;
		
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (!vis[v]) {
				heap.push({weight[i], v});
			}
		}
	}
	
	return cnt == n ? res : INF;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	while (m--) {
		int u, v, w;
		cin >> u >> v >> w;
		addEdge(u, v, w);
		addEdge(v, u, w);
	}
	
	int ret = prim();
	if (ret == INF) {
		cout << "impossible";
	}
	else {
		cout << ret;
	}
	
	return 0;
}
```





## 1-3 广度优先搜索

### 1.AcWing0847 图中点的层次

给定一个 *n* 个点 *m* 条边的有向图，图中可能存在重边和自环。

所有边的长度都是 1 ，点的编号为 1∼*n* 。

请你求出 1 号点到 *n* 号点的最短距离，如果从 1 号点无法走到 *n* 号点，输出 −1 。

#### 输入格式

第一行包含两个整数 *n* 和 *m* 。

接下来 *m* 行，每行包含两个整数 *a* 和 *b*，表示存在一条从 *a* 走到 *b* 的长度为 1 的边。

#### 输出格式

输出一个整数，表示 1 号点到 *n* 号点的最短距离。

#### 数据范围

1 ≤ *n* , *m* ≤ 10^5



#### 输入样例：

```
4 5
1 2
2 3
3 4
1 3
1 4
```

#### 输出样例：

```
1
```



#### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

class ALGragh {
private:
    int n;
    vector<list<int>> heads;

public:
    ALGragh(istream& cin, int numVex, int numEdges) {
        n = numVex;
        heads.resize(n + 1);
        
        while (numEdges--) {
            int u, v;
            cin >> u >> v;
            heads[u].push_back(v);
        }
    }
    
    int bfs() {
        queue<int> que;
        vector<int> dist(n + 1, -1);
        
        que.push(1);
        dist[1] = 0;
        
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            
            for (auto v : heads[u]) {
                if (dist[v] != -1) {
                    continue;
                }
                dist[v] = dist[u] + 1;
                que.push(v);
            }
        }
        
        return dist[n] == INF ? -1 : dist[n];
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    ALGragh T(cin, n, m);
    
    cout << T.bfs() << '\n';
    
    return 0;
}
```





#### 算法12-BFS(105 ms):

```c++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100000, M = 100000;

int n, first[N + 1];
int idx, ne[M + 1], vertex[M + 1];

void addEdge(int a, int b) {
    vertex[++idx] = b;
    ne[idx] = first[a];
    first[a] = idx;
}

int BFS() {
    queue<int> que;
    int dist[N + 1];
    
    for (int i = 1; i <= n; ++i) {
        dist[i] = -1;
    }
    
    // 源点入队
    que.push(1);
    dist[1] = 0;
    
    while (que.size()) {
        int u = que.front();
        que.pop();
        
        // 遍历 u 的所有出边
        for (int i = first[u]; i; i = ne[i]) {
            int v = vertex[i];
            if (dist[v] == -1) {
                que.push(v);
                dist[v] = dist[u] + 1;
            }
            
            // 如果到达终点，返回当前距离
            if (v == n) {
                return dist[v];
            }
        }
    }
    
    // 若所有可达点已遍历，返回 -1
    return -1;
} 

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    while (m--) {
        int a, b;
        cin >> a >> b;
        addEdge(a, b);
    }
    
    cout << BFS();
    
    return 0;
}
```







### 2.AcWing0844 走迷宫

给定一个 *n*×*m* 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问：该人从左上角移动至右下角 (*n*,*m*) 处，至少需要移动多少次？

数据保证 (1,1) 处和 (*n*,*m*) 处的数字为 0，且一定至少存在一条通路。

#### 输入格式

第一行包含两个整数 *n* 和 *m* 。

接下来 *n* 行，每行包含 *m* 个整数（0 或 1），表示完整的二维数组迷宫。

#### 输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

#### 数据范围

1 ≤ *n* , *m* ≤ 100



#### 输入样例：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例：

```
8
```



#### 算法思想：

从 (0, 0) 开始进行广度优先搜索。根据BFS的性质知，第一次走到点 (x, y) 时，当前走过的路径一定是路径长度最短的一条。

1. `bool board[0..n-1][0..m-1]` 维护棋盘状态。`board[i][j] == 1` 表示该点设有障碍。

2. `int dist[0..n-1][0..m-1]` 维护各点 (i, j) 到源点 (0, 0) 的最短路径长度。 
3. `queue<pair<int, int>> que` 为辅助BFS的队列。

 当第一次到达点 (i, j) 时，执行 `board[i][j] = 1` ，即阻断该路径，从而防止当前路径的回退及其他路径的经过。然后更新路径长度。



#### Algorithm 1:

Time Complexity = $O(nm)$ .

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int bfs(vector<vector<bool>>& grid) {
    int n = grid.size(), m = grid[0].size();
    queue<pair<int, int>> que;
    vector<vector<int>> dist(n, vector<int>(m, -1));
    
    que.push({0, 0});
    dist[0][0] = 0;
    
    const int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};
    while (!que.empty()) {
        auto [px, py] = que.front();
        que.pop();
        
        for (int i = 0; i < 4; i++) {
            int x = px + dx[i], y = py + dy[i];
            if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] || dist[x][y] != -1) {
                continue;
            }
            dist[x][y] = dist[px][py] + 1;
            que.push({x, y});
        }
    }
    
    return dist[n - 1][m - 1];
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<bool>> grid(n, vector<bool>(m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            bool x;
            cin >> x;
            grid[i][j] = x;
        }
    }
    
    cout << bfs(grid) << '\n';
    
    return 0;
}
```







### 3.AcWing0845 八数码(medium)

在一个 3×3 的网格中，1∼8 这 8 个数字和一个 `x` 恰好不重不漏地分布在这 3×3 的网格中。

例如：

```
1 2 3
x 4 6
7 5 8
```

在游戏过程中，可以把 `x` 与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

```
1 2 3
4 5 6
7 8 x
```

例如，示例中图形就可以通过让 `x` 先后与右、下、右三个方向的数字交换成功得到正确排列。

交换过程如下：

```
1 2 3   1 2 3   1 2 3   1 2 3
x 4 6   4 x 6   4 5 6   4 5 6
7 5 8   7 5 8   7 x 8   7 8 x
```

现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。

#### 输入格式

输入占一行，将 3×3 的初始网格描绘出来。

例如，如果初始网格如下所示：

```
1 2 3 
x 4 6 
7 5 8 
```

则输入为：`1 2 3 x 4 6 7 5 8`

#### 输出格式

输出占一行，包含一个整数，表示最少交换次数。

如果不存在解决方案，则输出 −1 。

#### 输入样例：

```
2 3 4 1 5 x 7 6 8
```

#### 输出样例

```
19
```



#### 算法思想：

一个长度为 9 的字符串 `string str` 对应一种棋盘状态，最坏情况下需要枚举 9! 种不同的状态。

从始状态 `beg` 出发，通过 BFS 查找到达终状态 `end` 的最短路径，记录路径长度。从状态 `pre` 经上下左右四个方向最多可以到达 4 种不同状态，对于其中的每一种状态 `curr` ，如果是第一次到达，则由BFS的性质知当前路径为到达该状态的最短路径，记录该路径长度，并将当前状态入队；否则，即该路径已经到达过，则什么也不做。访问状态 `curr` 后应将状态回溯至 `pre` 。

当第一次到达终状态 `end` 时，返回当前路径的路径长度。否则，若所有可达的状态已遍历，则说明终状态不可达，返回 -1 。

`unordered_map<string, int> dist` 维护从初始状态到各状态的最短距离。 `dist[str] == d` 表示从初始状态 `beg` 到当前状态 `str` 的最短路径长度为 `d` 。



#### Algorithm 1:

Time Complexity = $O(n \times n!)$ .

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <queue>
#include <unordered_map>

using namespace std;

const int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};

int bfs(string start) {
    const string end = "12345678x";
    
    unordered_map<string, int> dist;
    queue<string> que;
    
    dist[start] = 0;
    que.push(start);
    
    while (!que.empty()) {
        auto u = que.front();
        que.pop();
        
        if (u == end) {
            return dist[end];
        }
        
        int curPos = u.find('x');
        int x = curPos / 3, y = curPos % 3;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i], nextPos = nx * 3 + ny;
            string v = u;
            swap(v[curPos], v[nextPos]);
            if (nx < 0 || nx >= 3 || ny < 0 || ny >= 3 || dist.find(v) != dist.end()) {
                continue;
            }
            dist[v] = dist[u] + 1;
            que.push(v);
        }
    }
    
    return -1;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    string start;
    for (int i = 0; i < 9; i++) {
        char c;
        cin >> c;
        start.push_back(c);
    }
    
    cout << bfs(start) << '\n';
    
    return 0;
}
```



#### 算法2(3732 ms)：

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <unordered_map>
#include <queue>

using namespace std;

int BFS(string beg) {
    // dist[s] 维护状态 s 到 beg 的最短路径长度
    unordered_map<string, int> dist;
    queue<string> que;
    
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    string end = "12345678x";
    
    // 始状态入队
    que.push(beg);
    dist[beg] = 0;
    
    // 由近到远遍历所有状态
    while (que.size()) {
        // 队头出队
        string s = que.front();
        que.pop();
        
        // 若终状态已到达，则返回最短路径长度
        if (s == end) {
            return dist[s];
        }
        
        // 遍历四个方向
        int pk = s.find('x');
        for (int i = 0; i < 4; ++i) {
            int x = pk / 3 + dx[i], y = pk % 3 + dy[i];
            
            // 若越界，则什么也不做
            if (x < 0 || x >= 3 || y < 0 || y >= 3) {
                continue;
            }
            
            // 若当前状态未到达，则访问该状态
            int k = x * 3 + y;
            int d = dist[s];
            swap(s[pk], s[k]);		// s 已更新
            if (!dist.count(s)) {
                que.push(s);
                dist[s] = d + 1;
            }
            
            // 访问结束后，回溯状态
            swap(s[pk], s[k]);
        }
    }
    
    // 所有可达状态均已访问，则返回 -1
    return -1;
}


int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    string beg;
    for (int i = 0; i < 9; ++i) {
        string temp;
        cin >> temp;
        beg += temp;
    }
    
    cout << BFS(beg);
    
    return 0;
}
```





### 4.AcWing0848 有向图的拓扑序列

给定一个 *n* 个点 *m* 条边的有向图，点的编号是 1 到 *n* ，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1 。

若一个由图中所有点构成的序列 *A* 满足：对于图中的每条边 ( *x*, *y* ) ，*x* 在 *A* 中都出现在 *y* 之前，则称 *A* 是该图的一个拓扑序列。

#### 输入格式

第一行包含两个整数 *n* 和 *m* 。

接下来 *m* 行，每行包含两个整数 *x* 和 *y*，表示存在一条从点 *x* 到点 *y* 的有向边 ( *x* , *y* ) 。

#### 输出格式

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出 −1 。

#### 数据范围

1 ≤ *n* , *m* ≤ 10^5



#### 输入样例：

```
3 3
1 2
2 3
1 3
```

#### 输出样例：

```
1 2 3
```



#### Algorithm 1-Kahn:

Time Complexity = $O(n + m)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <queue>

using namespace std;

const int INF = 1e9;

class ALGragh {
private:
    int n;
    vector<list<int>> heads;
    vector<int> indegrees;

public:
    ALGragh(istream& cin, int numVex, int numEdges) {
        n = numVex;
        heads.resize(n + 1);
        indegrees.resize(n + 1, 0);
        
        while (numEdges--) {
            int u, v;
            cin >> u >> v;
            heads[u].push_back(v);
            indegrees[v]++;
        }
    }
    
    bool topoSort(vector<int>& ans) {
        queue<int> que;
        
        for (int i = 1; i <= n; i++) {
            if (!indegrees[i]) {
                que.push(i);
            }
        }
        
        int cnt = 0;
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            
            ans.push_back(u);
            cnt++;
            
            for (auto v : heads[u]) {
                if (--indegrees[v] == 0) {
                    que.push(v);
                }
            }
        }
        
        return cnt == n;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n, m;
    cin >> n >> m;
    ALGragh T(cin, n, m);
    
    vector<int> ans;
    bool ret = T.topoSort(ans);
    if (ret) {
        for (int i = 0; i < ans.size(); i++) {
            cout << ans[i] << ' ';
        }
        cout << '\n';
    } else {
        cout << -1 << '\n';
    }
    
    return 0;
}
```







## 1-4 深度优先搜索







## 1-5.二分图

### 53.AcWing0860 染色法判断二分图

给定一个 *n* 个点 *m* 条边的无向图，图中可能存在重边和自环。

请你判断这个图是否是二分图。

#### 输入格式

第一行包含两个整数 *n* 和 *m* 。

接下来 *m* 行，每行包含两个整数 *u* 和 *v*，表示点 *u* 和点 *v* 之间存在一条边。

#### 输出格式

如果给定图是二分图，则输出 `Yes`，否则输出 `No`。

#### 数据范围

1 ≤ *n* , *m* ≤ 10^5



#### 输入样例：

```
4 4
1 3
1 4
2 3
2 4
```

#### 输出样例：

```
Yes
```



#### 二分图简介：

二分图（Bipartite Graph），又称作二部图或者双分图，是图论中一种特殊的图的类型。一个图被称为二分图，如果图中的所有顶点可以被划分为两个不相交的子集，使得每条边的两个顶点分别属于不同的子集。换句话说，二分图中不存在同一个子集中的顶点之间存在边的情况。

形式化地，对于一个图 \( G = (V, E) \)，如果顶点集 \( V \) 可以被划分为两个不相交的子集 \( $V_1$ \) 和 \( $V_2$ \)，使得图中的每条边 \( (u, v) \) 的两个端点 \( u \) 和 \( v \) 分别属于 \( $V_1$ \) 和 \( $V_2$ \)，则图 \( G \) 是一个二分图。

二分图可以用于建模各种实际问题，例如：

1. 资源分配问题：将资源分配给两个不同的群体，使得每个群体内的成员之间不存在冲突。
2. 匹配问题：寻找一个最大匹配，使得两个群体之间的配对数最大化。
3. 调度问题：在任务和执行者之间建立匹配，以最大化执行者的效率或任务的完成率。

在计算机科学和应用中，二分图经常被用于解决类似的问题，例如网络流、最大匹配、任务分配等。二分图还有许多重要的性质和应用，因此对于二分图有深入的理解是非常有益的。



**[定理]** 二分图中，不存在奇环（点数为奇数的环）。



#### 算法思想：

染色法是一种常用的判断二分图的算法。其基本思想是通过给图的顶点进行染色，使得相邻的顶点颜色不同，如果能够成功地为所有顶点染色且满足相邻顶点颜色不同的条件，则该图是二分图。

具体步骤如下：

1. 选择一个起始顶点，并给它染上一种颜色（比如红色）。
2. 遍历与该顶点相邻的所有顶点，如果相邻顶点尚未被染色，则将其染上另一种颜色（比如蓝色），并继续递归地对相邻顶点进行染色。
3. 对于已经染色的顶点，如果发现与相邻顶点颜色相同，则说明无法将该图染成二分图，算法结束。
4. 如果所有顶点都被成功染色且满足相邻顶点颜色不同的条件，则该图是二分图。

该算法的时间复杂度取决于图的遍历方式，通常采用深度优先搜索（DFS）或广度优先搜索（BFS）来实现。在遍历的过程中，需要对每个顶点进行染色，并检查其相邻顶点的颜色，因此时间复杂度为 \(O(V + E)\)，其中 \(V\) 是顶点数，\(E\) 是边数。



#### 算法1-DFS(110 ms)：

时间复杂度为 \(O(V + E)\)，其中 \(V\) 是顶点数，\(E\) 是边数。

```c++
#include <iostream>

using namespace std;

const int N = 1e5, M = 2e5;

int n, first[N + 1];
int idx, ne[M + 1], vertex[M + 1];

void addEdge(int u, int v) {
	vertex[++idx] = v;
	ne[idx] = first[u];
	first[u] = idx;
}

int color[N + 1];

bool dfs(int u) {
	for (int i = first[u]; i; i = ne[i]) {
		int v = vertex[i];
		if (color[v] == color[u]) {
			return false;
		}
		
		if (!color[v]) {
			color[v] = 3 - color[u];
			if (!dfs(v)) {
				return false;
			}
		}
	}
	
	return true;
}

bool traverse() {
	for (int u = 1; u <= n; ++u) {
		if (!color[u]) {
			color[u] = 1;
			if (!dfs(u)) {
				return false;
			}
		}
	}
	
	return true;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	while (m--) {
		int u, v;
		cin >> u >> v;
		addEdge(u, v);
		addEdge(v, u);
	}
	
	cout << (traverse() ? "Yes" : "No");
	
	return 0;
}
```



#### 算法2-BFS(122 ms)：

```c++
#include <iostream>
#include <queue>

using namespace std;

const int N = 1E5, M = 2E5;

int n, first[N + 1];
int idx, ne[M + 1], vertex[M + 1];

void addEdge(int u, int v) {
	vertex[++idx] = v;
	ne[idx] = first[u];
	first[u] = idx;
}

int color[N + 1];

bool bfs(int u) {
	color[u] = 1; 
	
	queue<int> que;
	que.push(u);
	
	while (que.size()) {
		int u = que.front(); que.pop();
		for (int i = first[u]; i; i = ne[i]) {
			int v = vertex[i];
			if (color[v] == color[u]) {
				return false;
			}
			
			if (!color[v]) {
				color[v] = 3 - color[u];
				que.push(v);
			}
		}
	}
	
	return true;
}

bool traverse() {
	for (int u = 1; u <= n; ++u) {
		if (!color[u] && !bfs(u)) {
			return false;
		}
	}
	
	return true;
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	int m;
	cin >> n >> m;
	
	while (m--) {
		int u, v;
		cin >> u >> v;
		addEdge(u, v);
		addEdge(v, u);
	}
	
	cout << (traverse() ? "Yes" : "No");
	
	return 0;
}
```





#### 算法3 - DFS(110 ms)：

`int color[1..n]` 维护各点的颜色。 `color[u] == c` 表示点 u 的颜色为 c 。其中，0 表示未染色，1 与 2 分别表示两种不同的颜色。初始化为 0 。

遍历所有节点。每次访问节点时，将它染为与上一个节点颜色相反的颜色。如果它相邻的点存在已被染为相反颜色的点，则退出算法，表示二分图不存在。

若所有节点已遍历，返回结果，表示二分图存在。

```c++
#include <iostream>

using namespace std;

const int N = 100000, M = 100000 * 2;

int n, first[N + 1];
int idx, vertex[M + 1], ne[M + 1];

void addEdge(int u, int v) {
    vertex[++idx] = v;
    ne[idx] = first[u];
    first[u] = idx;
    
    vertex[++idx] = u;
    ne[idx] = first[v];
    first[v] = idx;
}

int color[N + 1];

// 从顶点 u 开始 DFS , u 颜色为 c
bool DFS(int u, int c) {
    color[u] = c;
    
    // 遍历 u 的所有邻接点 v
    for (int i = first[u]; i; i = ne[i]) {
        int v = vertex[i];
        
        // 若颜色相同，退出算法，表示不存在二分图
        if (color[v] == c) {
            return false;
        }
        
        // 如果未染色，则染反色并递归遍历 v
        if (!color[v]) {
            bool ret = DFS(v, 3 - c);
            if (!ret) {
                return ret;
            }
        }
    }
    
    return true;
}

// 遍历所有的顶点
bool traverse() {
    // 对所有的联通块调用一次 DFS()
    for (int u = 1; u <= n; ++u) {
        if (!color[u]) {
            bool ret = DFS(u, 1);
            if (!ret) {
                return false;
            }
        }
    }
    
    return true;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    while (m--) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);
    }
    
    cout << (traverse() ? "Yes" : "No");
    
    return 0;
}
```

 



#### 算法2-BFS(123 ms)：

```c++
#include <iostream>
#include <queue>

using namespace std;

const int N = 100000, M = 100000 * 2;

int n, first[N + 1];
int idx, vertex[M + 1], ne[M + 1];

void addEdge(int u, int v) {
    vertex[++idx] = v;
    ne[idx] = first[u];
    first[u] = idx;
    
    vertex[++idx] = u;
    ne[idx] = first[v];
    first[v] = idx;
}

int color[N + 1];

// 从点 u 开始BFS,返回是否存在二分图
bool BFS(int u) {
    queue<int> que;
    
    // 从点 u 出发
    que.push(u);
    color[u] = 1;
    
    while (que.size()) {
        u = que.front();
        que.pop();
        
        // 遍历所有相邻点并染色
        for (int i = first[u]; i; i = ne[i]) {
            int v = vertex[i];
            if (color[v] == color[u]) {
                return false;
            }

            if (!color[v]) {
                color[v] = 3 - color[u];
                que.push(v);
            }
        }
    }
    
    return true;
}

// 遍历所有的顶点
bool traverse() {
    // 对所有的联通块调用一次 BFS()
    for (int u = 1; u <= n; ++u) {
        if (!color[u]) {
            bool ret = BFS(u);
            if (!ret) {
                return false;
            }
        }
    }
    
    return true;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int m;
    cin >> n >> m;
    
    while (m--) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);
    }
    
    cout << (traverse() ? "Yes" : "No");
    
    return 0;
}
```







### 54.AcWing0861 二分图的最大匹配

给定一个二分图，其中左半部包含 $n_1$ 个点（编号 1∼$n_1$），右半部包含 $n_2$ 个点（编号 1∼$n_2$），二分图共包含 *m* 条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图 *G*，在 *G* 的一个子图 *M* 中，*M* 的边集 {*E*} 中的任意两条边都不依附于同一个顶点，则称 *M* 是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

#### 输入格式

第一行包含三个整数 $n_1$ $n_2$ 和 *m* 。

接下来 *m* 行，每行包含两个整数 *u* 和 *v*，表示左半部点集中的点 *u* 和右半部点集中的点 *v* 之间存在一条边。

#### 输出格式

输出一个整数，表示二分图的最大匹配数。

#### 数据范围

1 ≤ $n_1$ , $n_2$ ≤ 500 ,

1 ≤ *u* ≤ $n_1$ ,

1 ≤ *v* ≤ $n_2$  ,

1 ≤ *m* ≤ 10^5



#### 输入样例：

```
2 2 4
1 1
1 2
2 1
2 2
```

#### 输出样例：

```
2
```



#### 算法思想：

匈牙利算法是一种用于解决二分图最大匹配问题的经典算法。其基本思想是通过不断增广路径来寻找增广路，从而达到增大匹配数的目的。

具体算法思想如下：

1. **初始化：** 首先将所有的匹配关系置为空。
2. **寻找增广路径：** 从左边的未匹配顶点开始，尝试寻找增广路径。具体方法是采用深度优先搜索（DFS）或广度优先搜索（BFS）等方式在二分图中寻找增广路径。
3. **增广匹配：** 如果找到了一条增广路径，则将路径上的边加入匹配中。
4. **重复步骤2和3：** 重复执行步骤2和3，直到无法找到增广路径为止。
5. **返回最大匹配数：** 最后，所有增广路径形成的匹配即为最大匹配。

在匈牙利算法中，通常采用递归或迭代的方式来寻找增广路径，每次查找增广路径时，都尽可能地选择一条长度最短的路径。匈牙利算法的最坏时间复杂度为 \(O(VE)\)，其中 \(V\) 是顶点数，\(E\) 是边数。但是在实践中，平均时间开销一般远小于最坏时间。因此，对于大规模的图，匈牙利算法仍然具有较高的效率。



#### 算法1-DFS(81 ms)：

边集使用邻接表存储。只存储左半部的出边。

`int match[N + 1]` ，维护与右半部点匹配的对象。`match[v] == u` 表示右半部的点 v 与左半部的点 u 匹配。初始化为 0 。

`bool vis[1..n2]` ，维护所有已访问的点的集合。

匈牙利算法的主过程，计算并返回最大匹配数。算法过程如下：

1. 计数器初始化为 0 。初始化匹配对象数组 `match[1..n2]` 为 0 ，表示右半部的所有点均未匹配。
2. 进行 `n1` 轮迭代，遍历左半部的所有顶点。对于每个顶点 u ：
   - 初始化访问状态数组 `vis[1..n2]` 为 `false` ，表示右半部所有点均未访问。
   - 若能为顶点 u 找到匹配对象，则递增计数器。调用算法 `dfs(u)` 寻找 `u` 匹配对象。
3. 当左半部的所有点已遍历，返计数器中保存的值。

`bool dfs(int u)` 为左半部的顶点 `u` 寻找匹配对象，返回是否匹配成功。算法过程如下：

1. 遍历 `u` 的所有邻接点。对于邻接点 `v` ：
   - 如果点 `v` 未访问，则访问。访问时，如果点 `v` 暂未匹配或 `v` 的匹配对象有备选，则将 `u` 与 `v` 匹配，并递归地将 `v` 原本的匹配对象与后者的备选匹配。返回 `true` ，表示我们为点 `u` 找到了匹配对象。

2. 若所有邻接点已遍历，则返回 `false` ，表示点 `u` 无可选的匹配对象。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N1 = 500, N2 = 500, M = 100000;

int n1, n2, m;
int first[N1 + 1];
int idx, vertex[M + 1], ne[M + 1];

void addEdge(int u, int v) {
    vertex[++idx] = v;
    ne[idx] = first[u];
    first[u] = idx;
}

bool vis[N2 + 1];
int match[N2 + 1];

// 为左半部的点 u 寻找匹配对象，返回是否匹配成功
bool dfs(int u) {
    // 遍历 u 的所有邻接点
    for (int i = first[u]; i; i = ne[i]) {
        int v = vertex[i];
        
        if (vis[v]) {
            continue;
        }
        
        // 若点 v 未访问，则访问
        vis[v] = true;
        // 如果 v 未匹配或 v 的匹配对象有备选匹配，则与 v 匹配
        if (!match[v] || dfs(match[v])) {
            match[v] = u;
            return true;
        }
    }
    
    return false;
}

// 匈牙利算法，返回最大匹配数
int hungarian() {
    // 为左半部的每个点寻找一次匹配对象
    int res = 0;
    for (int u = 1; u <= n1; ++u) {
        fill_n(vis + 1, n2, false);
        if (dfs(u)) {
            ++res;
        }
    }
    
    return res;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n1 >> n2 >> m;
    
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);
    }
    
    cout << hungarian();
    
    return 0;
}
```





## 1-6 树形DP

### 0.树的存储模板

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

class ALTree {
private:
    int n;						// Number of nodes
    int root;					// Index of root
    vector<list<int>> heads;	// Adjacent list
    vector<int> value;			// Treenode value
public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        value.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            cin >> value[i];
        }
        vector<bool> isRoot(n + 1, true);
        for (int i = 1; i < n; i++) {
            int u, v;
            cin >> u >> v;
            heads[v].push_back(u);
            isRoot[u] = false;
        }
        root = 1;
        while (!isRoot[root]) {
            root++;
        }
    }
    
    
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    ALTree T(cin, n);
    
    
    
    return 0;
}
```





### 1.AcWing0285 没有上司的舞会

Ural 大学有 *N* 名职员，编号为 1∼*N* 。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 *Hi* 给出，其中 1 ≤ *i* ≤ *N* 。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

#### 输入格式

第一行一个整数 *N* 。

接下来 *N* 行，第 *i* 行表示 *i* 号职员的快乐指数 *Hi* 。

接下来 *N*−1 行，每行输入一对整数 *L*,*K*，表示 *K* 是 *L* 的直接上司。（注意一下，后一个数是前一个数的**父节点**，不要搞反）。

#### 输出格式

输出最大的快乐指数。

#### 数据范围

1 ≤ *N* ≤ 6000 ,

−128 ≤ *Hi* ≤ 127



#### 输入样例：

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

#### 输出样例：

```
5
```



#### 算法思想(最大独立集问题)：

1. 状态表示： `int dp[u][0]` 表示以 u 为根节点的子树，且不包括点 u 的最大快乐指数；

   `int dp[u][1]` 表示以 u 为根节点的子树，且包括点 u 的最大快乐指数。

2. 状态转移：假设 v 是 u 的孩子节点，则
   $$
   dp[u][0] = \sum_i max(dp[v_i][0], dp[v_i][1])
   $$

   $$
   dp[u][1] = \sum_i dp[v_i][0]
   $$

   



#### 算法1-最大独立集(18 ms)：

时间复杂度：O(n)。 n 为树中顶点的数量。

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

class ALTree {
private:
    int n;
    int root;
    vector<list<int>> head;
    vector<int> value;
public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        head.resize(n + 1);
        value.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            cin >> value[i];
        }
        vector<bool> isRoot(n + 1, true);
        for (int i = 1; i < n; i++) {
            int u, v;
            cin >> u >> v;
            head[v].push_back(u);
            isRoot[u] = false;
        }
        root = 1;
        while (!isRoot[root]) {
            root++;
        }
    }
    
    // DFS to compute the maximum happiness
    // res0: maximum happiness without including the node
    // res1: maximum happiness including the node
    pair<int, int> dfs(int u) {
        // If u is not selected, res0; if selected, res1
        int res0 = 0, res1 = value[u];
        for (auto v : head[u]) {
            auto [ret0, ret1] = dfs(v);     // Recursively calculate for child v
            res0 += max(ret0, ret1);
            res1 += ret0;
        }
        // Return the pair of max happiness values for u
        return {res0, res1};
    }
    
    int maxHappiness() {
        auto [res0, res1] = dfs(root);
        return max(res0, res1);
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    ALTree T(cin, n);
    
    cout << T.maxHappiness() << '\n';
    
    return 0;
}
```





### 2.LeetCode 0968 Binary Tree Cameras

You are given the `root` of a binary tree. We install cameras on the tree nodes where each  camera at a node can monitor its parent, itself, and its immediate  children.

Return *the minimum number of cameras needed to monitor all nodes of the tree*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png)

```
Input: root = [0,0,null,0,0]
Output: 1
Explanation: One camera is enough to monitor all nodes if placed as shown.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png)

```
Input: root = [0,0,null,0,null,0,null,null,0]
Output: 2
Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `Node.val == 0`



#### Algorithm 1:

Time Complesity = $O(n)$ .

```c++
class Solution {
    // Depth-first search (DFS) helper function to determine the state of each node
    // 0,1,2 represent  uncovered, placed a camera, covered  states respectively
    int dfs(TreeNode* root, int& ans) {
        if (!root) {
            return 2;  // Null node is considered covered
        }

        int left = dfs(root->left, ans), right = dfs(root->right, ans);
        
        // Case 1: Both children are covered, current node needs no camera
        if (left == 2 && right == 2) {
            return 0;  // No camera needed, node is covered
        } 
        // Case 2: One child is not covered, place a camera at the current node
        else if (left == 0 || right == 0) {
            ans++;  // Increment camera count
            return 1;  // Camera placed at this node
        } 
        // Case 3: One child has a camera, this node is covered
        else {
            return 2;  // Node is covered by a child camera
        }
    }

    // Function to traverse the tree and compute the minimum number of cameras
    int traverse(TreeNode* root) {
        int ans = 0;
        if (dfs(root, ans) == 0) {
            ans++;  // Place camera at root if it is uncovered
        }
        return ans;
    }

public:
    int minCameraCover(TreeNode* root) {
        return traverse(root);
    }
};

```





### 3.AcWing0846 树的重心

给定一棵树，树中包含 *n* 个结点（编号 1∼*n*）和 *n*−1 条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

#### 输入格式

第一行包含整数 *n*，表示树的结点数。

接下来 *n*−1 行，每行包含两个整数 *a* 和 *b*，表示点 *a* 和点 *b* 之间存在一条边。

#### 输出格式

输出一个整数 *m* ，表示将重心删除后，剩余各个连通块中点数的最大值。

#### 数据范围

1 ≤ *n* ≤ 10^5



#### 输入样例

```
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```

#### 输出样例：

```
4
```



#### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

class ALTree {
private:
    int n;							// Number of nodes
    vector<list<int>> heads;		// Adjacent list
    
public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        
        for (int i = 1; i < n; i++) {
            int u, v;
            cin >> u >> v;
            heads[v].push_back(u);
            heads[u].push_back(v);
        }
    }
    
    int dfs(int u, int fa, int& ans) {
        int maxNodes = 0, total = 1;
        for (auto v : heads[u]) {
            if (v == fa) {
                continue;
            }
            int curNodes = dfs(v, u, ans);
            maxNodes = max(maxNodes, curNodes);
            total += curNodes;
        }
        
        maxNodes = max(maxNodes, n - total);
        ans = min(ans, maxNodes);
        
        return total;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    ALTree T(cin, n);
    
    int ans = INF;
    T.dfs(1, 0, ans);
    cout << ans << '\n';
    
    return 0;
}
```





### 4.AcWing 1072 树的直径

给定一棵树，树中包含 *n* 个结点（编号 1~*n*）和 *n*−1 条无向边，每条边都有一个权值。

现在请你找到树中的一条最长路径。

换句话说，要找到一条路径，使得使得路径两端的点的距离最远。

注意：路径中可以只包含一个点。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n*−1 行，每行包含三个整数 *ai*,*bi*,*ci*，表示点 *ai* 和 *bi* 之间存在一条权值为 *ci* 的边。

#### 输出格式

输出一个整数，表示树的最长路径的长度。

#### 数据范围

1 ≤ *n* ≤ 10000 ,

1 ≤ *ai* , *bi* ≤ *n* ,

−10\^5 ≤ *ci* ≤ 10\^5



#### 输入样例：

```
6
5 1 6
1 4 5
6 3 9
2 6 8
6 1 7
```

#### 输出样例：

```
22
```



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

struct Edge {
    int adjvex, weight;
};

class ALTree {
private:
    int n;						// Number of nodes
    vector<list<Edge>> heads;	// Adjacent list
    
public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        
        for (int i = 1; i < n; i++) {
            int u, v, w;
            cin >> u >> v >> w;
            heads[u].push_back({v, w});
            heads[v].push_back({u, w});
        }
    }
    
    // Return the maximum distance from u to the leaf node 
    // in the subtree with u as the root.
    int dfs(int u, int fa, int& ans) {
        int maxDist = 0;
        for (auto [v, w] : heads[u]) {
            if (v == fa) {
                continue;
            }
            int curDist = dfs(v, u, ans) + w;
            ans = max(ans, maxDist + curDist);
            maxDist = max(maxDist, curDist);
        }
        return maxDist;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    ALTree T(cin, n);
    
    int ans = 0;
    T.dfs(1, 0, ans);
    cout << ans << '\n';
    
    return 0;
}
```





### 5.AcWing 1073 树的中心

给定一棵树，树中包含 *n* 个结点（编号1~*n*）和 *n*−1 条无向边，每条边都有一个权值。

请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。

#### 输入格式

第一行包含整数 *n* 。

接下来 *n*−1 行，每行包含三个整数 *ai*,*bi*,*ci*，表示点 *ai* 和 *bi* 之间存在一条权值为 *ci* 的边。

#### 输出格式

输出一个整数，表示所求点到树中其他结点的最远距离。

#### 数据范围

1 ≤ *n* ≤ 10000 ,

1 ≤ *ai* , *bi* ≤ *n* ,

1 ≤ *ci* ≤ 10^5



#### 输入样例：

```
5 
2 1 1 
3 2 1 
4 3 1 
5 1 1
```

#### 输出样例：

```
2
```



##### Algorithm 1:

Time Complexity = $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

struct Edge {
    int adjvex;
    int weight;
};

class ALTree {
private:
    int n;
    vector<list<Edge>> heads;

public:
    ALTree(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        
        for (int i = 1; i < n; i++) {
            int u, v, w;
            cin >> u >> v >> w;
            heads[u].push_back({v, w});
            heads[v].push_back({u, w});
        }
    }

    struct Path {
        int dist;
        int vex;
    };

    // Maintain the node to the farthest and sub-farthest leaf child
    vector<Path> far, subfar;
    
    // Maintain the maximum distance from current node 
    // to the non-leaf child through the parent node
    vector<int> up;
    
    int minMaxDist() {
        far.resize(n + 1, {0, 0});
        subfar.resize(n + 1, {0, 0});
        dfs_down(1, 0);
        
        up.resize(n + 1);
        dfs_up(1, 0);
        
        int ans = INF;
        for (int i = 1; i <= n; i++) {
            ans = min(ans, max(up[i], far[i].dist));
        }
        return ans;
    }
    
    void dfs_down(int u, int fa) {
        for (auto [v, w] : heads[u] ) {
            if (v == fa) {
                continue;
            }
            
            dfs_down(v, u);
            int curDist = w + far[v].dist;
            // Greater than the farthest, update far and subfar
            if (curDist > far[u].dist) {
                subfar[u] = far[u];
                far[u] = {curDist, v};
            }
            // Not greater than farthest, and greater than sub-farthest, 
            // only update sub-farthest
            else if (curDist > subfar[u].dist) {
                subfar[u] = {curDist, v};
            }
        }
    }
    
    void dfs_up(int u, int fa) {
        for (auto [v, w] : heads[u]) {
            if (v == fa) {
                continue;
            }
            
            up[v] = up[u];
            if (far[u].vex == v) {
                up[v] = max(up[v], subfar[u].dist);
            } else {
                up[v] = max(up[v], far[u].dist);
            }
            up[v] += w;
            
            dfs_up(v, u);
        }
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    ALTree T(cin, n);
    
    cout << T.minMaxDist() << '\n';
    
    return 0;
}
```





### 6.AcWing 1075 数字转换

如果一个数 *x* 的约数之和 *y*（不包括他本身）比他本身小，那么 *x* 可以变成 *y*，*y* 也可以变成 *x* 。

例如，4 可以变为 3，1 可以变为 7。

限定所有数字变换在不超过 *n* 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。

#### 输入格式

输入一个正整数 *n* 。

#### 输出格式

输出不断进行数字变换且不出现重复数字的最多变换步数。

#### 数据范围

1 ≤ *n* ≤ 50000



#### 输入样例：

```
7
```

#### 输出样例：

```
3
```

#### 样例解释

一种方案为：4→3→1→7 。



##### Algorithm 1:

Time Complexity = $O(n \times \sqrt n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

class ALGragh {
private:
    int n;
    vector<list<int>> heads;
    
public:
    ALGragh(int num) {
        n = num;
        heads.resize(n + 1);
        
        for (int i = 1; i <= n; i++) {
            int sum = 1;
            int j;
            for (j = 2; j * j < i; j++) {
                if (i % j == 0) {
                    sum += j + i / j;
                }
            }
            if (j * j == i) {
                sum += j;
            }
            
            if (sum < i) {
                heads[sum].push_back(i);
            }
        }
    }
    
    int ans;
    vector<bool> vis;
    
    // Return the maximum distance from u to the leaf node 
    int dfs(int u, int fa) {  // ans is diameter of this tree
        vis[u] = true;
        int maxDist = 0;
        for (auto v : heads[u]) {
            if (v == fa) {
                continue;
            }
            
            int curDist = dfs(v, u) + 1;
            ans = max(ans, curDist + maxDist);
            maxDist = max(maxDist, curDist);
        }
        return maxDist;
    }
    
    int maxDiameterOfTree() {
        ans = 0;
        vis.resize(n + 1, false);
        for (int i = 1; i <= n; i++) {
            if (!vis[i]) {
                dfs(i, 0);
            }
        }
        return ans;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    
    ALGragh G(n);
    
    cout << G.maxDiameterOfTree() << '\n';
    
    return 0;
}
```





### 50.AcWing 1074 二叉苹果树

有一棵二叉苹果树，如果树枝有分叉，一定是分两叉，即没有只有一个儿子的节点。

这棵树共 *N* 个节点，编号为 1 至 *N*，树根编号一定为 1 。

我们用一根树枝两端连接的节点编号描述一根树枝的位置。

一棵苹果树的树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。

这里的保留是指最终与1号点连通。

#### 输入格式

第一行包含两个整数 *N* 和 *Q* ，分别表示树的节点数以及要保留的树枝数量。

接下来 *N*−1 行描述树枝信息，每行三个整数，前两个是它连接的节点的编号，第三个数是这根树枝上苹果数量。

#### 输出格式

输出仅一行，表示最多能留住的苹果的数量。

#### 数据范围

1 ≤ *Q* < *N* ≤ 100 .

*N* ≠ 1 ,

每根树枝上苹果不超过 30000 个。



#### 输入样例：

```
5 2
1 3 1
1 4 10
2 3 20
3 5 20
```

#### 输出样例：

```
21
```



```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

class ALTree1 {
private:
    struct Edge {
        int adjvex;
        int weight;
    };

    int n;
    vector<list<Edge>> heads;

public:
    ALTree1(istream& cin, int numVex) {
        n = numVex;
        heads.resize(n + 1);
        for (int i = 1; i < n; i++) {
            int u, v, w;
            cin >> u >> v >> w;
            heads[u].push_back({v, w});
            heads[v].push_back({u, w});
        }
    }
};

class ALTree2 {
private:
    struct Vertex {
        int apples;       // Apples on subtree
        int nodes;   // Number of nodes on subtree
    };

    int n;
    vector<Vertex> vertices;
    vector<list<int>> heads;

public:
    friend class ALTree1;
    
    ALGragh(ALTree1& T) {
        n = T.n;
        heads.resize(n + 1);
        vertices.resize(n + 1, {0, 1});
        // Count the number of apples and nodes on the subtree
        dfs1(1, 0, T);
    }
    
    void dfs1(int u, int fa, ALTree1& T) {
        auto& [apples, nodes] = vertices[u];
        for (auto [v, w] : T.heads[u]) {
            if (v == fa) {
                continue;
            }
            heads[u].push_back(v);
            dfs(v, u, T);
            apples += vertices[v].apples + w;
            nodes += vertices[v].nodes;
        }
    }
    
    int m;      // Number of branches to be cut off
    // dp[u][j] 表示在子树 u 中，恰好减去 j 根树枝的所有方案中最少损失的苹果数量
    vector<vector<int>> dp;
    
    int maxRemaningApples(int q) {
        m = n - 1 - q;
        dp.resize(n + 1, vector<int>(m + 1, 0));
        
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    
    int n, q;
    cin >> n >> q;
    
    ALGragh G(cin, n);
    
    cout << G.maxRemaningApples(q) << '\n';
    
    return 0;
}
```





#### 算法1(24 ms)：

时间复杂度：O(nm^2)。n, m 分别为树的节点数，要保留的树枝的数量。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100, M = (N - 1) * 2, Q = N - 1;

int n, q, first[N + 1];
int idx = 1, ne[M + 1], adjvex[M + 1], weight[M + 1];

void add_edge(int u, int v, int w) {
    weight[idx] = w;
    adjvex[idx] = v;
    ne[idx] = first[u];
    first[u] = idx++;
}

// dp[u][cnt] 表示以 u 为树根, 边数不超过 cnt 的子树的最大权重和
int dp[N + 1][Q + 1];

void dfs(int u, int fa) {
    for (int i = first[u]; i; i = ne[i]) {
        int v = adjvex[i];
        if (v == fa) {
            continue;
        }
        dfs(v, u);
        
        // 遍历背包容量
        for (int j = q; j; j--) {
            // 尝试给孩子节点 v 分配容量 k
            for (int k = 0; k < j; k++) {
                dp[u][j] = max(dp[u][j], dp[u][j - k - 1] + dp[v][k] + weight[i]);
            }
        }
    }
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    cin >> n >> q;
    for (int i = 0; i < n - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        add_edge(u, v, w);
        add_edge(v, u, w);
    }
    
    dfs(1, 0);
    
    cout << dp[1][q] << '\n';
    
    return 0;
}
```





### 51.AcWing 0323 战略游戏

鲍勃喜欢玩电脑游戏，特别是战略游戏，但有时他找不到解决问题的方法，这让他很伤心。

现在他有以下问题。

他必须保护一座中世纪城市，这条城市的道路构成了一棵树。

每个节点上的士兵可以观察到所有和这个点相连的边。

他必须在节点上放置最少数量的士兵，以便他们可以观察到所有的边。

你能帮助他吗？

例如，下面的树：

![1463_1.jpg.gif](https://cdn.acwing.com/media/article/image/2019/02/05/19_0f47f44029-1463_1.jpg.gif) 

只需要放置 1 名士兵（在节点 1 处），就可观察到所有的边。

#### 输入格式

输入包含多组测试数据，每组测试数据用以描述一棵树。

对于每组测试数据，第一行包含整数 *N* ，表示树的节点数目。

接下来 *N* 行，每行按如下方法描述一个节点。

节点编号：(子节点数目) 子节点 子节点 …

节点编号从 0 到 *N*−1，每个节点的子节点数量均不超过 10，每个边在输入数据中只出现一次。

#### 输出格式

对于每组测试数据，输出一个占据一行的结果，表示最少需要的士兵数。

#### 数据范围

0 < *N* ≤ 1500 ,

一个测试点所有 *N* 相加之和不超过 300650 。



#### 输入样例：

```
4
0:(1) 1
1:(2) 2 3
2:(0)
3:(0)
5
3:(3) 1 4 2
1:(1) 0
2:(0)
0:(0)
4:(0)
```

#### 输出样例：

```
1
2
```



#### 算法1(75 ms)：

时间复杂度：O(tn)。t 为测试数据的组数，t 为每组数据的树的节点数。

```c++
#include <iostream>

using namespace std;

const int N = 1500, M = (N - 1) * 2;

int n, first[N];
int idx, ne[M + 1], adjvex[M + 1];

void add_edge(int u, int v) {
    adjvex[idx] = v;
    ne[idx] = first[u];
    first[u] = idx++;
}

// dp[u][0/1] 表示以 u 为根的子树中, 在点 u 分别 不放/放 士兵,
// 且能照亮所有边的所有方案中的最小花费
int dp[N][2];

void dfs(int u, int fa) {
    dp[u][0] = 0;
    dp[u][1] = 1;
    for (int i = first[u]; i != -1; i = ne[i]) {
        int v = adjvex[i];
        if (v == fa) {
            continue;
        }
        dfs(v, u);
        dp[u][0] += dp[v][1];
        dp[u][1] += min(dp[v][0], dp[v][1]);
    }
}

int main() {
    while (cin >> n) {
        idx = 0;
        fill_n(first, n, -1);
        
        for (int i = 0; i < n; i++) {
            int u, cnt;
            scanf("%d:(%d)", &u, &cnt);
            while (cnt--) {
                int v;
                scanf("%d", &v);
                add_edge(u, v);
                add_edge(v, u);
            }
        }
        
        dfs(0, -1);
        printf("%d\n", min(dp[0][0], dp[0][1]));
    }
    
    return 0;
}
```





### 52.AcWing 1077 皇宫看守(medium)

太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。

皇宫各个宫殿的分布，呈一棵树的形状，宫殿可视为树中结点，两个宫殿之间如果存在道路直接相连，则该道路视为树中的一条边。

已知，在一个宫殿镇守的守卫不仅能够观察到本宫殿的状况，还能观察到与该宫殿直接存在道路相连的其他宫殿的状况。

大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。

可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。

帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。

#### 输入格式

输入中数据描述一棵树，描述如下：

第一行 *n* ，表示树中结点的数目。

第二行至第 *n*+1 行，每行描述每个宫殿结点信息，依次为：该宫殿结点标号 *i*，在该宫殿安置侍卫所需的经费 *k*，该结点的子结点数 *m*，接下来 *m* 个数，分别是这个结点的 *m* 个子结点的标号 *r*1 , *r*2 , … , *rm* 。

对于一个 *n* 个结点的树，结点标号在 1 到 *n* 之间，且标号不重复。

#### 输出格式

输出一个整数，表示最少的经费。

#### 数据范围

1 ≤ *n* ≤ 1500



#### 输入样例：

```
6
1 30 3 2 3 4
2 16 2 5 6
3 5 0
4 4 0
5 11 0
6 5 0
```

#### 输出样例：

```
25
```

#### 样例解释：

在2、3、4结点安排护卫，可以观察到全部宫殿，所需经费最少，为 16 + 5 + 4 = 25。







### x53.AcWing 1207 大臣的旅费(树的直径)

很久以前，*T* 王国空前繁荣。

为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，*T* 国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。

同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

*J* 是 *T* 国重要大臣，他巡查于各大城市之间，体察民情。

所以，从一个城市马不停蹄地到另一个城市成了 *J* 最常做的事情。

他有一个钱袋，用于存放往来城市间的路费。

聪明的 *J* 发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关。

具体来说，一段连续的旅途里，第 1 千米的花费为 11，第 2 千米的花费为 12，第 3 千米的花费为 13，…，第 *x* 千米的花费为 *x*+10 。

也就是说，如果一段旅途的总长度为 1 千米，则刚好需要花费 11，如果一段旅途的总长度为 2 千米，则第 1 千米花费 11，第 2 千米花费 12，一共需要花费 11+12=23 。

*J* 大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？

#### 输入格式

输入的第一行包含一个整数 *n*，表示包括首都在内的 *T* 王国的城市数。

城市从 1 开始依次编号，1 号城市为首都。

接下来 *n*−1 行，描述 *T* 国的高速路（*T* 国的高速路一定是 *n*−1 条）。

每行三个整数 *Pi*,*Qi*,*Di* ，表示城市 *Pi* 和城市 *Qi* 之间有一条**双向**高速路，长度为 *Di* 千米。

#### 输出格式

输出一个整数，表示大臣 *J* 最多花费的路费是多少。 

#### 数据范围

1 ≤ *n* ≤ 10^5 ,

1 ≤ *Pi* , *Qi* ≤ *n* ,

1 ≤ *Di* ≤ 1000



#### 输入样例：

```
5
1 2 2
1 3 1
2 4 5
2 5 4
```

#### 输出样例：

```
135
```



#### 算法思想：

建立一棵数。DFS遍历所有节点每个节点维护其到最远孩子叶节点的最大距离。待求值即为任意两个叶节点间的最远距离。



##### Algorithm 1:

Time complexity : $O(n)$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

const int INF = 1e9;

struct Edge {
    int adjvex, weight;
};

class ALTree {
private:
    int n;						// Number of nodes
    vector<list<Edge>> heads;	// Adjacent list
    
public:
    ALTree(istream& cin) {
        cin >> n;
        heads.resize(n + 1);
        
        for (int i = 1; i < n; i++) {
            int u, v, w;
            cin >> u >> v >> w;
            heads[u].push_back({v, w});
            heads[v].push_back({u, w});
        }
    }
    
    // Return the maximum distance from u to the leaf node 
    // in the subtree with u as the root.
    int dfs(int u, int fa, int& ans) {
        int maxDist = 0;
        for (auto [v, w] : heads[u]) {
            if (v == fa) {
                continue;
            }
            int curDist = dfs(v, u, ans) + w;
            ans = max(ans, maxDist + curDist);
            maxDist = max(maxDist, curDist);
        }
        return maxDist;
    }
    
    long long minCost() {
        int dia = 0;  // Diameter of the tree
        dfs(1, 0, dia);
        return (long long)(dia + 21) * dia / 2;
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    ALTree T(cin);
    
    cout << T.minCost() << '\n';
    
    return 0;
}
```





## 1-7 最近公共祖先

### 128.AcWing 1172 祖先询问(medium)

给定一棵包含 *n* 个节点的有根无向树，节点编号互不相同，但不一定是 1∼*n* 。

有 *m* 个询问，每个询问给出了一对节点的编号 *x* 和 *y*，询问 *x* 与 *y* 的祖孙关系。

#### 输入格式

输入第一行包括一个整数  表示节点个数；

接下来 *n* 行每行一对整数 *a* 和 *b*，表示 *a* 和 *b* 之间有一条无向边。如果 *b* 是 −1，那么 *a* 就是树的根；

第 *n*+2 行是一个整数 *m* 表示询问个数；

接下来 *m* 行，每行两个不同的正整数 *x* 和 *y* ，表示一个询问。

#### 输出格式

对于每一个询问，若 *x* 是 *y* 的祖先则输出 1，若 *y* 是 *x* 的祖先则输出 2，否则输出 0 。

#### 数据范围

1 ≤ *n* , *m* ≤ 4 × 10^4 ,

1 ≤ 每个节点的编号 ≤ 4 × 10^4



#### 输入样例：

```
10
234 -1
12 234
13 234
14 234
15 234
16 234
17 234
18 234
19 234
233 19
5
234 233
233 12
233 13
233 15
233 19
```

#### 输出样例：

```
1
0
0
0
2
```



```
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

class UFSet {
public:
    vector<int> fa;

    UFSet() {}
    
    void init(int n) {
        fa.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            fa[i] = i;
        }
    }
    
    int find(int u) {
        return fa[u] == u ? u : fa[u] = find(fa[u]);
    }
};

class ALTree {
private:
    struct Query {
        int v, idx, tag;
    };

    const int n = 4e4;
    int root;
    vector<list<int>> heads;
    
    int m;
    vector<list<Query>> queries;
    
public:
    ALTree(istream& cin) {
        int t;
        cin >> t;
        
        heads.resize(n + 1);
        while (t--) {
            int u, v;
            cin >> u >> v;
            
            if (v == -1) {
                root = u;
            } else {
                heads[u].push_back(v);
                heads[v].push_back(u);
            }
        }
        
        cin >> m;
        queries.resize(n + 1);
        for (int i = 0; i < m; i++) {
            int u, v;
            cin >> u >> v;
            queries[u].push_back({v, i, 1});
        }
    }
    
    vector<int> ans;
    vector<bool> vis;
    UFSet ufs;
    
    void dfs(int u) {
        vis[u] = true;
        for (auto v : heads[u]) {
            if (!vis[v]) {
                dfs(v);
                ufs.fa[v] = u;
            }
        }
        
        for (auto [v, idx, tag] : queries[u]) {
            if (vis[v]) {
                ans[idx] = ufs.find(v) == u ? tag : 0;
            } else {
                queries[v].push_back({u, idx, 2});
            }
        }
    }
    
    void tarjan() {
        ans.resize(m, -2);
        vis.resize(n + 1, false);
        ufs.init(n);
        
        dfs(root);
        
        for (auto x : ans) {
            cout << x << '\n';
        }
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);
    
    ALTree T(cin);
    
    T.tarjan();
    
    return 0;
}
```



#### 倍增算法：

对于所有的节点 `u` ,  $\forall u\in [1, N]$ ，

- `depth[u]` ，存储节点 `u` 在树中的深度（定义根的深度为 1 ）。
- `anc[u][i]` ，表示节点 `u` 向上跳 $2^i(i = 0,1,2,\dots, D+1)$ 层，所到达的祖先节点。

特别地，定义 0 号节点为根节点的父节点，且 `depth[0] = 0, anc[root][0] = 0` 。

分析知，树的最大深度为 $D$
$$
D = \lceil log_2 (N + 1) \rceil = \lfloor log_2 N \rfloor +1	\tag{*}
$$



#### ST 表：

在 LCA（Lowest Common Ancestor，最近公共祖先）问题中，ST 表是一种常用的数据结构，用于快速查询任意两个节点的最近公共祖先。ST 表的全称是 Sparse Table，中文翻译为稀疏表。它通过预处理构建一个二维数组，使得对于任意的两个节点 u 和 v，可以在 O(1) 的时间内查询它们的最近公共祖先。

ST 表的构造过程基于动态规划的思想。假设 `f[i][j]` 表示节点 i 向上跳 2^j 步后的节点，那么有如下递推关系：

`f[i][j] = f[f[i][j-1]][j-1]` 

其中 `f[i][j]` 表示节点 i 向上跳 2^j 步后的节点。这个递推关系可以用来构造 ST 表。

ST 表的空间复杂度为 O(nlogn)，构建时间复杂度为 O(nlogn)，查询时间复杂度为 O(1)。在 LCA 问题中，如果需要进行多次查询，使用 ST 表是一种高效的解决方案。



#### 算法1(201 ms)：

时间复杂度：O((n + m) log N)。n, m 分别为顶点个数，询问次数，N 为顶点的最大编号。其中建立 ST 表的时间开销为 O(n log N)， 每次查询的时间开销为 O(log N)。

```c++
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 4e4, M = (N - 1) * 2, D = log2(N) + 1;

int n, first[N + 1];
int idx = 1, ne[M + 1], vertex[M + 1];

int depth[N + 1], anc[N + 1][D + 1];

void addEdge(int u, int v) {
	vertex[idx] = v;
	ne[idx] = first[u];
	first[u] = idx++;
}

// 倍增递推, 得到 depth 与 ancestor 
void dfs(int u, int fa) {
	depth[u] = depth[fa] + 1;
	
	// 倍增递推 
	anc[u][0] = fa;
	for (int i = 1; i <= D; i++) {
		anc[u][i] = anc[anc[u][i - 1]][i - 1];
	}
	
	// 向下搜索
	for (int i = first[u]; i; i = ne[i]) {
		int v = vertex[i];
		if (v != fa) {
			dfs(v, u);
		}
	}
}

int lca(int u, int v) {
	// 保证 u 的深度不小于 v 
	if (depth[u] < depth[v]) {
		swap(u, v);
	}
	
	// 1. 先让 u 跳到 v 的同层
	for (int i = D; i >= 0; i--) {
		if (depth[anc[u][i]] >= depth[v]) {
			u = anc[u][i];
		}
	}
	if (u == v) {
		return v;
	}
	
	// 2. 再一起跳到 lca 的下一层
	for (int i = D; i >= 0; i--) {
		if (anc[u][i] != anc[v][i]) {
			u = anc[u][i];
			v = anc[v][i];
		}
	} 
	
	return anc[u][0];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	int root;
	for (int i = 0; i < n; i++) {
		int u, v;
		cin >> u >> v;
		if (v == -1) {
			root = u;
		}
		else {
			addEdge(u, v);
			addEdge(v, u);
		}
	}
	
	dfs(root, 0);
	
	int m;
	cin >> m;
	
	while (m--) {
		int u, v;
		cin >> u >> v;
		int ret = lca(u, v);
		if (ret == u) {
			cout << 1 << '\n';
		}
		else if (ret == v) {
			cout << 2 << '\n';
		}
		else {
			cout << 0 << '\n';
		}
	}
	
	return 0;
}
```



#### 算法2(362 ms)：

```c++
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 4e4, D = log2(N) + 1;

int n;
vector<int> edges[N + 1];

int depth[N + 1], anc[N + 1][D + 1];

void dfs(int u, int fa) {
	depth[u] = depth[fa] + 1;
	
	anc[u][0] = fa;
	for (int i = 1; i <= D; i++) {
		anc[u][i] = anc[anc[u][i - 1]][i - 1];
	}
	
	for (int v : edges[u]) {
		if (v != fa) {
			dfs(v, u);
		}
	}
}

int lca(int u, int v) {
	if (depth[u] < depth[v]) {
		swap(u, v);
	}
	
	for (int i = D; i >= 0; i--) {
		if (depth[anc[u][i]] >= depth[v]) {
			u = anc[u][i];
		}
	}
	if (u == v) {
		return u;
	}
	
	for (int i = D; i >= 0; i--) {
		if (anc[u][i] != anc[v][i]) {
			u = anc[u][i];
			v = anc[v][i];
		}
	}
	
	return anc[u][0];
}

int main() {
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	cin >> n;
	int root;
	
	for (int i = 0; i < n; i++) {
		int u, v;
		cin >> u >> v;
		if (v == -1) {
			root = u;
		}
		else {
			edges[u].push_back(v);
			edges[v].push_back(u);
		}
	}
	
	dfs(root, 0);
	
	int m;
	cin >> m;
	
	while (m--) {
		int u, v;
		cin >> u >> v;
		int ret = lca(u, v);
		if (ret == u) {
			cout << 1 << '\n';
		}
		else if (ret == v) {
			cout << 2 << '\n';
		}
		else {
			cout << 0 << '\n';
		}
	}
	
	return 0;
}
```





### 2.AcWing 1171 距离(tarjan)

给出 *n* 个点的一棵树，多次询问两点之间的最短距离。

注意：

- 边是**无向**的。
- 所有节点的编号是 1,2,…,*n* 。

#### 输入格式

第一行为两个整数 *n* 和 *m*。*n* 表示点数，*m* 表示询问次数；

接下来 *n*−1 行，每行三个整数 *x*,*y*,*k*，表示点 *x* 和点 *y* 之间存在一条边长度为 *k* ；

再接下来 *m* 行，每行两个整数 *x*,*y*，表示询问点 *x* 到点 *y* 的最短距离。

树中结点编号从 1 到 *n* 。

#### 输出格式

共 *m* 行，对于每次询问，输出一行询问结果。

#### 数据范围

$2≤ n ≤10^4$ ,

$1 ≤ m ≤ 2×10^4$ ,

$0<k≤100$ ,

$1≤x,y≤n$ .



#### 输入样例1：

```
2 2 
1 2 100 
1 2 
2 1
```

#### 输出样例1：

```
100
100
```

#### 输入样例2：

```
3 2
1 2 10
3 1 15
1 2
3 2
```

#### 输出样例2：

```
10
25
```



##### Algorithm 1:

Time complexity : $O(n + m \alpha (n))$ .

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

// Union-Find (Disjoint Set) with path compression
class UFSet {
public:
    int n;
    vector<int> fa;

    UFSet() {}

    // Initialize the union-find set
    void init(int size) {
        n = size;
        fa.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            fa[i] = i; // Each node is its own parent initially
        }
    }

    // Find the root with path compression
    int find(int u) {
        return fa[u] == u ? u : fa[u] = find(fa[u]);
    }
};

// Adjacency List representation of a Tree with Tarjan's LCA Algorithm
class ALTree {
private:
    int n, q;
    vector<list<pair<int, int>>> heads;     // Adjacency list for tree edges: <v, weight>
    vector<list<pair<int, int>>> queries;   // Query list for LCA computation: <v, index>

public:
    // Read input and build the tree and queries
    ALTree(istream& cin) {
        cin >> n >> q;

        heads.resize(n + 1);
        for (int i = 1; i < n; i++) { // Read n-1 edges (Tree has n-1 edges)
            int u, v, w;
            cin >> u >> v >> w;
            heads[u].push_back({v, w});
            heads[v].push_back({u, w});
        }

        queries.resize(n + 1);
        for (int i = 0; i < q; i++) { // Read q queries
            int u, v;
            cin >> u >> v;
            queries[u].push_back({v, i});
        }
    }

    vector<int> ans;   // Stores answers for each query
    vector<int> dist;  // Stores distance from root
    UFSet ufs;         // Union-Find Set for LCA computation

    // Depth-first search to compute distances and process LCA queries
    void dfs(int u) {
        for (auto [v, w] : heads[u]) {
            if (dist[v] == -1) { // If not visited
                dist[v] = dist[u] + w; // Calculate distance from root
                dfs(v);
                ufs.fa[v] = u; // Mark u as the parent of v in Union-Find
            }
        }

        // Process stored queries
        for (auto [v, idx] : queries[u]) {
            if (dist[v] != -1) { // If the other node in the query has been visited
                int lca = ufs.find(v); // Find the lowest common ancestor
                ans[idx] = dist[u] + dist[v] - 2 * dist[lca]; // Compute distance using LCA
            } else {
                queries[v].push_back({u, idx}); // Store the query for later processing
            }
        }
    }

    // Tarjan's algorithm for LCA and distance queries
    void tarjan() {
        ans.resize(q);
        dist.resize(n + 1, -1);
        ufs.init(n);

        dist[1] = 0; // Start DFS from node 1
        dfs(1);

        // Print all query results
        for (auto x : ans) {
            cout << x << '\n';
        }
    }
};

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    ALTree T(cin); // Read input and initialize the tree

    T.tarjan(); // Process LCA queries and print results

    return 0;
}

```





### 130.AcWing 0356 次小生成树(hard)

给定一张 *N* 个点 *M* 条边的无向图，求无向图的严格次小生成树。

设最小生成树的边权之和为 sum ，严格次小生成树就是指边权之和大于 sum 的生成树中最小的一个。

#### 输入格式

第一行包含两个整数 *N* 和 *M* 。

接下来 *M* 行，每行包含三个整数 *x*，*y*，*z*，表示点 *x* 和点 *y* 之前存在一条边，边的权值为 *z* 。

#### 输出格式

包含一行，仅一个数，表示严格次小生成树的边权和。(数据保证必定存在严格次小生成树)

#### 数据范围

*N* ≤ 10^5 , *M* ≤ 3 × 10^5 ,

1 ≤ *x* , *y* ≤ *N* ,

0 ≤ *z* ≤ 10^6



#### 输入样例：

```
5 6
1 2 1
1 3 2
2 4 3
3 5 4
3 4 3
4 5 6
```

#### 输出样例：

```
11
```









```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010, M = 300010, INF = 0x3f3f3f3f;

// 边的结构体
struct Edge
{
    int a, b, w; // 起点，终点，权值
    bool used;   // 是否被使用
    bool operator< (const Edge &t) const // 重载小于号，用于排序
    {
        return w < t.w;
    }
}edge[M];

// 并查集相关
int p[N]; // 并查集的父节点数组
int find(int x) // 查找根节点
{
    if (p[x] != x) p[x] = find(p[x]); // 路径压缩
    return p[x];
}

// 图的邻接表相关
int h[N], e[M], w[M], ne[M], idx; // 邻接表
void add(int a, int b, int c) // 添加边
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

// 预处理最短路径需要的数组和变量
int depth[N], fa[N][17], d1[N][17], d2[N][17]; // 深度、父节点、最大边权、次大边权
int q[N]; // BFS队列

// Kruskal算法求最小生成树
LL kruskal()
{
    for (int i = 1; i <= n; i ++ ) p[i] = i; // 初始化并查集
    sort(edge, edge + m); // 按边权排序
    LL res = 0; // 最小生成树的总权值
    for (int i = 0; i < m; i ++ )
    {
        int a = find(edge[i].a), b = find(edge[i].b), w = edge[i].w; // 查找边的两个端点的根节点
        if (a != b) // 如果两个端点不在同一个连通块中
        {
            p[a] = b; // 合并两个连通块
            res += w; // 更新总权值
            edge[i].used = true; // 标记边被使用
        }
    }

    return res; // 返回最小生成树的总权值
}

// 建图
void build()
{
    memset(h, -1, sizeof h); // 初始化邻接表
    for (int i = 0; i < m; i ++ )
        if (edge[i].used) // 如果边被使用
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w; // 边的两个端点和权值
            add(a, b, w), add(b, a, w); // 添加双向边到邻接表
        }
}

// BFS计算节点深度和父节点，并预处理距离
void bfs()
{
    memset(depth, 0x3f, sizeof depth); // 初始化深度数组
    depth[0] = 0, depth[1] = 1; // 根节点的深度为1
    q[0] = 1; // 将根节点入队
    int hh = 0, tt = 0; // BFS队列的头尾指针
    while (hh <= tt) // 队列不为空
    {
        int t = q[hh ++ ]; // 出队一个节点
        for (int i = h[t]; ~i; i = ne[i]) // 遍历该节点的所有邻接点
        {
            int j = e[i]; // 邻接点的编号
            if (depth[j] > depth[t] + 1) // 如果邻接点的深度大于当前节点的深度加一
            {
                depth[j] = depth[t] + 1; // 更新邻接点的深度
                q[ ++ tt] = j; // 将邻接点入队
                fa[j][0] = t; // 更新邻接点的父节点
                d1[j][0] = w[i], d2[j][0] = -INF; // 更新邻接点到父节点的两条边的最大边权和次大边权
                for (int k = 1; k <= 16; k ++ ) // 从1到16进行倍增计算
                {
                    int anc = fa[j][k - 1]; // 获取j的2^k-1祖先
                    fa[j][k] = fa[anc][k - 1]; // 更新j的2^k祖先
                    int distance[4] = {d1[j][k - 1], d2[j][k - 1], d1[anc][k - 1], d2[anc][k - 1]}; // 保存四个距离值
                    d1[j][k] = d2[j][k] = -INF; // 初始化j到2^k祖先的最大边权和次大边权
                    for (int u = 0; u < 4; u ++ ) // 枚举四种情况
                    {
                        int d = distance[u]; // 获取距离值
                        if (d > d1[j][k]) d2[j][k] = d1[j][k], d1[j][k] = d; // 更新最大边权和次大边权
                        else if (d != d1[j][k] && d > d2[j][k]) d2[j][k] = d; // 更新次大边权
                    }
                }
            }
        }
    }
}

// 计算两个节点之间的最短路径长度
int lca(int a, int b, int w)
{
    static int distance[N * 2]; // 静态数组保存距离值
    int cnt = 0; // 记录距离值的个数
    if (depth[a] < depth[b]) swap(a, b); // 保证a的深度大于等于b的深度
    for (int k = 16; k >= 0; k -- ) // 从16到0进行倍增
        if (depth[fa[a][k]] >= depth[b]) // 如果a的2^k祖先的深度大于等于b的深度
        {
            distance[cnt ++ ] = d1[a][k]; // 将a到2^k祖先的距离值加入数组
            distance[cnt ++ ] = d2[a][k]; // 将a到2^k祖先的距离值加入数组
            a = fa[a][k]; // 更新a为2^k祖先
        }
    if (a != b) // 如果a不等于b
    {
        for (int k = 16; k >= 0; k -- ) // 从16到0进行倍增
            if (fa[a][k] != fa[b][k]) // 如果a和b的2^k祖先不相等
            {
                distance[cnt ++ ] = d1[a][k]; // 将a到2^k祖先的距离值加入数组
                distance[cnt ++ ] = d2[a][k]; // 将a到2^k祖先的距离值加入数组
                distance[cnt ++ ] = d1[b][k]; // 将b到2^k祖先的距离值加入数组
                distance[cnt ++ ] = d2[b][k]; // 将b到2^k祖先的距离值加入数组
                a = fa[a][k], b = fa[b][k]; // 更新a和b为各自的2^k祖先
            }
        distance[cnt ++ ] = d1[a][0]; // 将a到根节点的距离值加入数组
        distance[cnt ++ ] = d1[b][0]; // 将b到根节点的距离值加入数组
    }

    int dist1 = -INF, dist2 = -INF; // 最大边权和次大边权
    for (int i = 0; i < cnt; i ++ ) // 遍历距离值数组
    {
        int d = distance[i]; // 获取距离值
        if (d > dist1) dist2 = dist1, dist1 = d; // 更新最大边权和次大边权
        else if (d != dist1 && d > dist2) dist2 = d; // 更新次大边权
    }

    if (w > dist1) return w - dist1; // 如果边权大于最大边权，返回边权减最大边权
    if (w > dist2) return w - dist2; // 如果边权大于次大边权，返回边权减次大边权
    return INF; // 否则返回无穷大
}

int main()
{
    scanf("%d%d", &n, &m); // 输入节点数和边数
    for (int i = 0; i < m; i ++ ) // 输入边的信息
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edge[i] = {a, b, c}; // 将边的信息存入数组中
    }

    LL sum = kruskal(); // 求解最小生成树的总权值
    build(); // 建图
    bfs(); // BFS预处理节点信息

    LL res = 1e18; // 初始化结果
    for (int i = 0; i < m; i ++ ) // 枚举每一条不在最小生成树中的边
        if (!edge[i].used) // 如果边没有被使用
        {
            int a = edge[i].a, b = edge[i].b, w = edge[i].w; // 边的两个端点和权值
            res = min(res, sum + lca(a, b, w)); // 计算最短路径长度，并更新结果
        }
    printf("%lld\n", res); // 输出结果

    return 0;
}
```



















# END.

### 1.

### `std::fixed` 和 `std::setprecision` 的详细介绍

在 C++ 中，`std::fixed` 和 `std::setprecision` 是控制浮点数输出格式的常用方法，属于 `<iomanip>` 头文件。它们主要用于控制数字的显示格式和精度。

------

### **1. `std::fixed`**

#### 功能：

- 指定浮点数的输出为 **固定点格式**（即非科学计数法）。
- 浮点数的小数部分的位数由 `std::setprecision` 控制。

#### 示例：

```cpp
#include <iostream>
#include <iomanip>

int main() {
    double value = 12345.6789;

    // 默认输出格式
    std::cout << value << std::endl;

    // 使用 std::fixed 格式化输出
    std::cout << std::fixed << std::setprecision(2) << value << std::endl;

    return 0;
}
```

#### 输出：

```
12345.6789  // 默认格式
12345.68    // 固定点格式，保留小数点后 2 位
```

------

### **2. `std::setprecision`**

#### 功能：

- 用于设置浮点数的输出精度。

- 配合 

  ```
  std::fixed
  ```

   时：

  - 控制小数点后保留的位数。

- 不使用 

  ```
  std::fixed
  ```

   时：

  - 控制输出的 **总有效位数**（包括整数部分和小数部分）。

#### 示例：

```cpp
#include <iostream>
#include <iomanip>

int main() {
    double value = 12345.6789;

    // 默认格式
    std::cout << value << std::endl;

    // 设置总有效位数为 4（默认格式）
    std::cout << std::setprecision(4) << value << std::endl;

    // 设置小数点后 4 位（固定格式）
    std::cout << std::fixed << std::setprecision(4) << value << std::endl;

    return 0;
}
```

#### 输出：

```
12345.6789  // 默认格式
1.235e+04   // 总有效位数为 4，使用科学计数法
12345.6789  // 小数点后 4 位
```

------

### **3. 结合使用：`std::fixed` 和 `std::setprecision`**

#### 使用方法：

1. 加入 `<iomanip>` 头文件。
2. 配置输出流：
   - `std::fixed` 设置为固定点格式。
   - `std::setprecision(n)` 指定小数点后保留 `n` 位数字。

#### 示例：

```cpp
#include <iostream>
#include <iomanip>

int main() {
    double a = 3.14159265359;
    double b = 123456.789;

    // 保留 8 位小数
    std::cout << std::fixed << std::setprecision(8) << a << std::endl;

    // 改为保留 2 位小数
    std::cout << std::fixed << std::setprecision(2) << b << std::endl;

    return 0;
}
```

#### 输出：

```
3.14159265  // 保留小数点后 8 位
123456.79   // 保留小数点后 2 位
```

------

### **4. 不使用 `std::fixed` 时的行为**

如果不使用 `std::fixed`：

- `std::setprecision(n)` 会控制浮点数的 **总有效位数**（包括整数部分和小数部分）。
- 如果数字较大，可能会以科学计数法显示。

#### 示例：

```cpp
#include <iostream>
#include <iomanip>

int main() {
    double value = 12345.6789;

    // 设置总有效位数为 6
    std::cout << std::setprecision(6) << value << std::endl;

    // 设置总有效位数为 3
    std::cout << std::setprecision(3) << value << std::endl;

    return 0;
}
```

#### 输出：

```
12345.7    // 总有效位数为 6
1.23e+04   // 总有效位数为 3，使用科学计数法
```

------

### **5. 常见用法总结**

- **保留固定的小数位数（常用）**：

  ```cpp
  std::cout << std::fixed << std::setprecision(3) << value << std::endl;
  ```

- **科学计数法格式化输出**：

  ```cpp
  std::cout << std::scientific << std::setprecision(3) << value << std::endl;
  ```

- **切换回默认格式**：

  ```cpp
  std::cout.unsetf(std::ios::fixed | std::ios::scientific);
  ```

------

### **6. 注意事项**

- **`std::fixed` 是持久设置**：

  - 一旦设置，后续输出都将使用固定点格式，直到手动取消。

  ```cpp
  std::cout.unsetf(std::ios::fixed);
  ```

- **数值精度与显示无关**：

  - `std::setprecision` 仅影响显示格式，不会更改数值本身的精度或存储方式。





`<iomanip>` 是 **input/output manipulators** 的缩写，它是 C++ 标准库中用于输入输出操作的头文件。这个名字来源于其功能：提供了一组工具（操纵器 manipulators）来格式化输入和输出流的行为。

------

### 主要功能

`<iomanip>` 提供了一系列操纵器，用于：

1. **控制输出格式**：设置浮点数精度、格式化宽度、对齐方式等。
2. **流行为设置**：管理流的状态，如启用/禁用科学计数法、固定点格式等。

------

### 常用的 `<iomanip>` 功能示例

#### 1. **浮点数格式化**

```cpp
#include <iostream>
#include <iomanip>

int main() {
    double pi = 3.14159265359;

    // 默认格式
    std::cout << pi << std::endl;

    // 固定点格式，保留小数点后 4 位
    std::cout << std::fixed << std::setprecision(4) << pi << std::endl;

    // 科学计数法格式，保留小数点后 4 位
    std::cout << std::scientific << std::setprecision(4) << pi << std::endl;

    return 0;
}
```

输出：

```
3.14159
3.1416
3.1416e+00
```

#### 2. **控制对齐与宽度**

```cpp
#include <iostream>
#include <iomanip>

int main() {
    int a = 42, b = 7, c = 123;

    // 设置输出宽度为 5，右对齐
    std::cout << std::setw(5) << a << std::endl;
    std::cout << std::setw(5) << b << std::endl;
    std::cout << std::setw(5) << c << std::endl;

    // 设置宽度为 5，左对齐
    std::cout << std::left << std::setw(5) << a << std::endl;
    std::cout << std::left << std::setw(5) << b << std::endl;
    std::cout << std::left << std::setw(5) << c << std::endl;

    return 0;
}
```

输出：

```
   42
    7
  123
42   
7    
123  
```

#### 3. **十六进制与填充字符**

```cpp
#include <iostream>
#include <iomanip>

int main() {
    int value = 255;

    // 十六进制表示，宽度为 6，填充字符为 '0'
    std::cout << std::hex << std::setw(6) << std::setfill('0') << value << std::endl;

    return 0;
}
```

输出：

```
0000ff
```

------

### 总结

`<iomanip>` 是格式化输入输出流的强大工具。它名字的来源直观地反映了其作用：`input/output manipulators`（输入输出操纵器）。





